//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0 {
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.IO;
    using System.Linq;
    using System.Diagnostics;
    using System.Xml;
    using System.Xml.Schema;
    using System.Xml.Linq;
    using Xml.Schema.Linq;
    
    
    /// <summary>
    /// <para>
    /// Root element of the instance document.
    /// </para>
    /// <para>
    /// Regular expression: (CvList, Provider?, AuditCollection?, AnalysisSummary, InputFiles, SoftwareList, DataProcessingList, BibliographicReference*, AssayList, StudyVariableList?, RatioList?, ProteinGroupList?, ProteinList?, PeptideConsensusList*, SmallMoleculeList?, FeatureList*)
    /// </para>
    /// </summary>
    public partial class MzQuantMLType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName CvListXName = System.Xml.Linq.XName.Get("CvList", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName ProviderXName = System.Xml.Linq.XName.Get("Provider", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName AuditCollectionXName = System.Xml.Linq.XName.Get("AuditCollection", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName AnalysisSummaryXName = System.Xml.Linq.XName.Get("AnalysisSummary", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName InputFilesXName = System.Xml.Linq.XName.Get("InputFiles", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName SoftwareListXName = System.Xml.Linq.XName.Get("SoftwareList", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName DataProcessingListXName = System.Xml.Linq.XName.Get("DataProcessingList", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName BibliographicReferenceXName = System.Xml.Linq.XName.Get("BibliographicReference", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<BibliographicReferenceType> BibliographicReferenceField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName AssayListXName = System.Xml.Linq.XName.Get("AssayList", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName StudyVariableListXName = System.Xml.Linq.XName.Get("StudyVariableList", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName RatioListXName = System.Xml.Linq.XName.Get("RatioList", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName ProteinGroupListXName = System.Xml.Linq.XName.Get("ProteinGroupList", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName ProteinListXName = System.Xml.Linq.XName.Get("ProteinList", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName PeptideConsensusListXName = System.Xml.Linq.XName.Get("PeptideConsensusList", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<PeptideConsensusListType> PeptideConsensusListField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName SmallMoleculeListXName = System.Xml.Linq.XName.Get("SmallMoleculeList", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName FeatureListXName = System.Xml.Linq.XName.Get("FeatureList", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<FeatureListType> FeatureListField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName creationDateXName = System.Xml.Linq.XName.Get("creationDate", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName versionXName = System.Xml.Linq.XName.Get("version", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName idXName = System.Xml.Linq.XName.Get("id", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName nameXName = System.Xml.Linq.XName.Get("name", "");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("MzQuantMLType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator MzQuantMLType(XElement xe) { return XTypedServices.ToXTypedElement<MzQuantMLType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static MzQuantMLType() {
            BuildElementDictionary();
            contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(CvListXName), new NamedContentModelEntity(ProviderXName), new NamedContentModelEntity(AuditCollectionXName), new NamedContentModelEntity(AnalysisSummaryXName), new NamedContentModelEntity(InputFilesXName), new NamedContentModelEntity(SoftwareListXName), new NamedContentModelEntity(DataProcessingListXName), new NamedContentModelEntity(BibliographicReferenceXName), new NamedContentModelEntity(AssayListXName), new NamedContentModelEntity(StudyVariableListXName), new NamedContentModelEntity(RatioListXName), new NamedContentModelEntity(ProteinGroupListXName), new NamedContentModelEntity(ProteinListXName), new NamedContentModelEntity(PeptideConsensusListXName), new NamedContentModelEntity(SmallMoleculeListXName), new NamedContentModelEntity(FeatureListXName));
        }
        
        /// <summary>
        /// <para>
        /// Root element of the instance document.
        /// </para>
        /// <para>
        /// Regular expression: (CvList, Provider?, AuditCollection?, AnalysisSummary, InputFiles, SoftwareList, DataProcessingList, BibliographicReference*, AssayList, StudyVariableList?, RatioList?, ProteinGroupList?, ProteinList?, PeptideConsensusList*, SmallMoleculeList?, FeatureList*)
        /// </para>
        /// </summary>
        public MzQuantMLType() {
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// <para>
        /// Regular expression: (CvList, Provider?, AuditCollection?, AnalysisSummary, InputFiles, SoftwareList, DataProcessingList, BibliographicReference*, AssayList, StudyVariableList?, RatioList?, ProteinGroupList?, ProteinList?, PeptideConsensusList*, SmallMoleculeList?, FeatureList*)
        /// </para>
        /// </summary>
        public virtual CvListType CvList {
            get {
                XElement x = this.GetElement(CvListXName);
                return ((CvListType)(x));
            }
            set {
                this.SetElement(CvListXName, value);
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// <para>
        /// Regular expression: (CvList, Provider?, AuditCollection?, AnalysisSummary, InputFiles, SoftwareList, DataProcessingList, BibliographicReference*, AssayList, StudyVariableList?, RatioList?, ProteinGroupList?, ProteinList?, PeptideConsensusList*, SmallMoleculeList?, FeatureList*)
        /// </para>
        /// </summary>
        public virtual ProviderType Provider {
            get {
                XElement x = this.GetElement(ProviderXName);
                return ((ProviderType)(x));
            }
            set {
                this.SetElement(ProviderXName, value);
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// <para>
        /// Regular expression: (CvList, Provider?, AuditCollection?, AnalysisSummary, InputFiles, SoftwareList, DataProcessingList, BibliographicReference*, AssayList, StudyVariableList?, RatioList?, ProteinGroupList?, ProteinList?, PeptideConsensusList*, SmallMoleculeList?, FeatureList*)
        /// </para>
        /// </summary>
        public virtual AuditCollectionType AuditCollection {
            get {
                XElement x = this.GetElement(AuditCollectionXName);
                return ((AuditCollectionType)(x));
            }
            set {
                this.SetElement(AuditCollectionXName, value);
            }
        }
        
        /// <summary>
        /// <para>
        /// Summary information about the analysis in terms of the type of analysis, any global scores or metrics and global thresholds used.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// <para>
        /// Regular expression: (CvList, Provider?, AuditCollection?, AnalysisSummary, InputFiles, SoftwareList, DataProcessingList, BibliographicReference*, AssayList, StudyVariableList?, RatioList?, ProteinGroupList?, ProteinList?, PeptideConsensusList*, SmallMoleculeList?, FeatureList*)
        /// </para>
        /// </summary>
        public virtual ParamListType AnalysisSummary {
            get {
                XElement x = this.GetElement(AnalysisSummaryXName);
                return ((ParamListType)(x));
            }
            set {
                this.SetElement(AnalysisSummaryXName, value);
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// <para>
        /// Regular expression: (CvList, Provider?, AuditCollection?, AnalysisSummary, InputFiles, SoftwareList, DataProcessingList, BibliographicReference*, AssayList, StudyVariableList?, RatioList?, ProteinGroupList?, ProteinList?, PeptideConsensusList*, SmallMoleculeList?, FeatureList*)
        /// </para>
        /// </summary>
        public virtual InputFilesType InputFiles {
            get {
                XElement x = this.GetElement(InputFilesXName);
                return ((InputFilesType)(x));
            }
            set {
                this.SetElement(InputFilesXName, value);
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// <para>
        /// Regular expression: (CvList, Provider?, AuditCollection?, AnalysisSummary, InputFiles, SoftwareList, DataProcessingList, BibliographicReference*, AssayList, StudyVariableList?, RatioList?, ProteinGroupList?, ProteinList?, PeptideConsensusList*, SmallMoleculeList?, FeatureList*)
        /// </para>
        /// </summary>
        public virtual SoftwareListType SoftwareList {
            get {
                XElement x = this.GetElement(SoftwareListXName);
                return ((SoftwareListType)(x));
            }
            set {
                this.SetElement(SoftwareListXName, value);
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// <para>
        /// Regular expression: (CvList, Provider?, AuditCollection?, AnalysisSummary, InputFiles, SoftwareList, DataProcessingList, BibliographicReference*, AssayList, StudyVariableList?, RatioList?, ProteinGroupList?, ProteinList?, PeptideConsensusList*, SmallMoleculeList?, FeatureList*)
        /// </para>
        /// </summary>
        public virtual DataProcessingListType DataProcessingList {
            get {
                XElement x = this.GetElement(DataProcessingListXName);
                return ((DataProcessingListType)(x));
            }
            set {
                this.SetElement(DataProcessingListXName, value);
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional, repeating
        /// </para>
        /// <para>
        /// Regular expression: (CvList, Provider?, AuditCollection?, AnalysisSummary, InputFiles, SoftwareList, DataProcessingList, BibliographicReference*, AssayList, StudyVariableList?, RatioList?, ProteinGroupList?, ProteinList?, PeptideConsensusList*, SmallMoleculeList?, FeatureList*)
        /// </para>
        /// </summary>
        public virtual IList<BibliographicReferenceType> BibliographicReference {
            get {
                if ((this.BibliographicReferenceField == null)) {
                    this.BibliographicReferenceField = new XTypedList<BibliographicReferenceType>(this, LinqToXsdTypeManager.Instance, BibliographicReferenceXName);
                }
                return this.BibliographicReferenceField;
            }
            set {
                if ((value == null)) {
                    this.BibliographicReferenceField = null;
                }
                else {
                    if ((this.BibliographicReferenceField == null)) {
                        this.BibliographicReferenceField = XTypedList<BibliographicReferenceType>.Initialize(this, LinqToXsdTypeManager.Instance, value, BibliographicReferenceXName);
                    }
                    else {
                        XTypedServices.SetList<BibliographicReferenceType>(this.BibliographicReferenceField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// <para>
        /// Regular expression: (CvList, Provider?, AuditCollection?, AnalysisSummary, InputFiles, SoftwareList, DataProcessingList, BibliographicReference*, AssayList, StudyVariableList?, RatioList?, ProteinGroupList?, ProteinList?, PeptideConsensusList*, SmallMoleculeList?, FeatureList*)
        /// </para>
        /// </summary>
        public virtual AssayListType AssayList {
            get {
                XElement x = this.GetElement(AssayListXName);
                return ((AssayListType)(x));
            }
            set {
                this.SetElement(AssayListXName, value);
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// <para>
        /// Regular expression: (CvList, Provider?, AuditCollection?, AnalysisSummary, InputFiles, SoftwareList, DataProcessingList, BibliographicReference*, AssayList, StudyVariableList?, RatioList?, ProteinGroupList?, ProteinList?, PeptideConsensusList*, SmallMoleculeList?, FeatureList*)
        /// </para>
        /// </summary>
        public virtual StudyVariableListType StudyVariableList {
            get {
                XElement x = this.GetElement(StudyVariableListXName);
                return ((StudyVariableListType)(x));
            }
            set {
                this.SetElement(StudyVariableListXName, value);
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// <para>
        /// Regular expression: (CvList, Provider?, AuditCollection?, AnalysisSummary, InputFiles, SoftwareList, DataProcessingList, BibliographicReference*, AssayList, StudyVariableList?, RatioList?, ProteinGroupList?, ProteinList?, PeptideConsensusList*, SmallMoleculeList?, FeatureList*)
        /// </para>
        /// </summary>
        public virtual RatioListType RatioList {
            get {
                XElement x = this.GetElement(RatioListXName);
                return ((RatioListType)(x));
            }
            set {
                this.SetElement(RatioListXName, value);
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// <para>
        /// Regular expression: (CvList, Provider?, AuditCollection?, AnalysisSummary, InputFiles, SoftwareList, DataProcessingList, BibliographicReference*, AssayList, StudyVariableList?, RatioList?, ProteinGroupList?, ProteinList?, PeptideConsensusList*, SmallMoleculeList?, FeatureList*)
        /// </para>
        /// </summary>
        public virtual ProteinGroupListType ProteinGroupList {
            get {
                XElement x = this.GetElement(ProteinGroupListXName);
                return ((ProteinGroupListType)(x));
            }
            set {
                this.SetElement(ProteinGroupListXName, value);
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// <para>
        /// Regular expression: (CvList, Provider?, AuditCollection?, AnalysisSummary, InputFiles, SoftwareList, DataProcessingList, BibliographicReference*, AssayList, StudyVariableList?, RatioList?, ProteinGroupList?, ProteinList?, PeptideConsensusList*, SmallMoleculeList?, FeatureList*)
        /// </para>
        /// </summary>
        public virtual ProteinListType ProteinList {
            get {
                XElement x = this.GetElement(ProteinListXName);
                return ((ProteinListType)(x));
            }
            set {
                this.SetElement(ProteinListXName, value);
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional, repeating
        /// </para>
        /// <para>
        /// Regular expression: (CvList, Provider?, AuditCollection?, AnalysisSummary, InputFiles, SoftwareList, DataProcessingList, BibliographicReference*, AssayList, StudyVariableList?, RatioList?, ProteinGroupList?, ProteinList?, PeptideConsensusList*, SmallMoleculeList?, FeatureList*)
        /// </para>
        /// </summary>
        public virtual IList<PeptideConsensusListType> PeptideConsensusList {
            get {
                if ((this.PeptideConsensusListField == null)) {
                    this.PeptideConsensusListField = new XTypedList<PeptideConsensusListType>(this, LinqToXsdTypeManager.Instance, PeptideConsensusListXName);
                }
                return this.PeptideConsensusListField;
            }
            set {
                if ((value == null)) {
                    this.PeptideConsensusListField = null;
                }
                else {
                    if ((this.PeptideConsensusListField == null)) {
                        this.PeptideConsensusListField = XTypedList<PeptideConsensusListType>.Initialize(this, LinqToXsdTypeManager.Instance, value, PeptideConsensusListXName);
                    }
                    else {
                        XTypedServices.SetList<PeptideConsensusListType>(this.PeptideConsensusListField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// <para>
        /// Regular expression: (CvList, Provider?, AuditCollection?, AnalysisSummary, InputFiles, SoftwareList, DataProcessingList, BibliographicReference*, AssayList, StudyVariableList?, RatioList?, ProteinGroupList?, ProteinList?, PeptideConsensusList*, SmallMoleculeList?, FeatureList*)
        /// </para>
        /// </summary>
        public virtual SmallMoleculeListType SmallMoleculeList {
            get {
                XElement x = this.GetElement(SmallMoleculeListXName);
                return ((SmallMoleculeListType)(x));
            }
            set {
                this.SetElement(SmallMoleculeListXName, value);
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional, repeating
        /// </para>
        /// <para>
        /// Regular expression: (CvList, Provider?, AuditCollection?, AnalysisSummary, InputFiles, SoftwareList, DataProcessingList, BibliographicReference*, AssayList, StudyVariableList?, RatioList?, ProteinGroupList?, ProteinList?, PeptideConsensusList*, SmallMoleculeList?, FeatureList*)
        /// </para>
        /// </summary>
        public virtual IList<FeatureListType> FeatureList {
            get {
                if ((this.FeatureListField == null)) {
                    this.FeatureListField = new XTypedList<FeatureListType>(this, LinqToXsdTypeManager.Instance, FeatureListXName);
                }
                return this.FeatureListField;
            }
            set {
                if ((value == null)) {
                    this.FeatureListField = null;
                }
                else {
                    if ((this.FeatureListField == null)) {
                        this.FeatureListField = XTypedList<FeatureListType>.Initialize(this, LinqToXsdTypeManager.Instance, value, FeatureListXName);
                    }
                    else {
                        XTypedServices.SetList<FeatureListType>(this.FeatureListField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// The date on which the file was produced.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual System.DateTime? creationDate {
            get {
                XAttribute x = this.Attribute(creationDateXName);
                if ((x == null)) {
                    return null;
                }
                return XTypedServices.ParseValue<System.DateTime>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.DateTime).Datatype);
            }
            set {
                this.SetAttribute(creationDateXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.DateTime).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The version of the schema this instance document refers to, in the format x.y.z. Changes to z should not affect prevent instance documents from validating. 
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual string version {
            get {
                XAttribute x = this.Attribute(versionXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(versionXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The unique identifier for the mzQuantML file or experiment.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual string id {
            get {
                XAttribute x = this.Attribute(idXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Id).Datatype);
            }
            set {
                this.SetAttribute(idXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Id).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// Optional name for the file or experiment.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string name {
            get {
                XAttribute x = this.Attribute(nameXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(nameXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<MzQuantMLType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(CvListXName, typeof(CvListType));
            localElementDictionary.Add(ProviderXName, typeof(ProviderType));
            localElementDictionary.Add(AuditCollectionXName, typeof(AuditCollectionType));
            localElementDictionary.Add(AnalysisSummaryXName, typeof(ParamListType));
            localElementDictionary.Add(InputFilesXName, typeof(InputFilesType));
            localElementDictionary.Add(SoftwareListXName, typeof(SoftwareListType));
            localElementDictionary.Add(DataProcessingListXName, typeof(DataProcessingListType));
            localElementDictionary.Add(BibliographicReferenceXName, typeof(BibliographicReferenceType));
            localElementDictionary.Add(AssayListXName, typeof(AssayListType));
            localElementDictionary.Add(StudyVariableListXName, typeof(StudyVariableListType));
            localElementDictionary.Add(RatioListXName, typeof(RatioListType));
            localElementDictionary.Add(ProteinGroupListXName, typeof(ProteinGroupListType));
            localElementDictionary.Add(ProteinListXName, typeof(ProteinListType));
            localElementDictionary.Add(PeptideConsensusListXName, typeof(PeptideConsensusListType));
            localElementDictionary.Add(SmallMoleculeListXName, typeof(SmallMoleculeListType));
            localElementDictionary.Add(FeatureListXName, typeof(FeatureListType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    /// <summary>
    /// <para>
    /// The list of controlled vocabularies used in the file.
    /// </para>
    /// <para>
    /// Regular expression: (Cv+)
    /// </para>
    /// </summary>
    public partial class CvListType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName CvXName = System.Xml.Linq.XName.Get("Cv", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<CvType> CvField;
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("CvListType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator CvListType(XElement xe) { return XTypedServices.ToXTypedElement<CvListType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static CvListType() {
            BuildElementDictionary();
            contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(CvXName));
        }
        
        /// <summary>
        /// <para>
        /// The list of controlled vocabularies used in the file.
        /// </para>
        /// <para>
        /// Regular expression: (Cv+)
        /// </para>
        /// </summary>
        public CvListType() {
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, repeating
        /// </para>
        /// <para>
        /// Regular expression: (Cv+)
        /// </para>
        /// </summary>
        public virtual IList<CvType> Cv {
            get {
                if ((this.CvField == null)) {
                    this.CvField = new XTypedList<CvType>(this, LinqToXsdTypeManager.Instance, CvXName);
                }
                return this.CvField;
            }
            set {
                if ((value == null)) {
                    this.CvField = null;
                }
                else {
                    if ((this.CvField == null)) {
                        this.CvField = XTypedList<CvType>.Initialize(this, LinqToXsdTypeManager.Instance, value, CvXName);
                    }
                    else {
                        XTypedServices.SetList<CvType>(this.CvField, value);
                    }
                }
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<CvListType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(CvXName, typeof(CvType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    /// <summary>
    /// <para>
    /// All the raw files, identification files and databases used in the quantitation.
    /// </para>
    /// <para>
    /// Regular expression: (RawFilesGroup*, MethodFiles?, IdentificationFiles?, SearchDatabase*, SourceFile*)
    /// </para>
    /// </summary>
    public partial class InputFilesType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName RawFilesGroupXName = System.Xml.Linq.XName.Get("RawFilesGroup", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<RawFilesGroupType> RawFilesGroupField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName MethodFilesXName = System.Xml.Linq.XName.Get("MethodFiles", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName IdentificationFilesXName = System.Xml.Linq.XName.Get("IdentificationFiles", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName SearchDatabaseXName = System.Xml.Linq.XName.Get("SearchDatabase", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<SearchDatabaseType> SearchDatabaseField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName SourceFileXName = System.Xml.Linq.XName.Get("SourceFile", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<SourceFileType> SourceFileField;
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("InputFilesType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator InputFilesType(XElement xe) { return XTypedServices.ToXTypedElement<InputFilesType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static InputFilesType() {
            BuildElementDictionary();
            contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(RawFilesGroupXName), new NamedContentModelEntity(MethodFilesXName), new NamedContentModelEntity(IdentificationFilesXName), new NamedContentModelEntity(SearchDatabaseXName), new NamedContentModelEntity(SourceFileXName));
        }
        
        /// <summary>
        /// <para>
        /// All the raw files, identification files and databases used in the quantitation.
        /// </para>
        /// <para>
        /// Regular expression: (RawFilesGroup*, MethodFiles?, IdentificationFiles?, SearchDatabase*, SourceFile*)
        /// </para>
        /// </summary>
        public InputFilesType() {
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional, repeating
        /// </para>
        /// <para>
        /// Regular expression: (RawFilesGroup*, MethodFiles?, IdentificationFiles?, SearchDatabase*, SourceFile*)
        /// </para>
        /// </summary>
        public virtual IList<RawFilesGroupType> RawFilesGroup {
            get {
                if ((this.RawFilesGroupField == null)) {
                    this.RawFilesGroupField = new XTypedList<RawFilesGroupType>(this, LinqToXsdTypeManager.Instance, RawFilesGroupXName);
                }
                return this.RawFilesGroupField;
            }
            set {
                if ((value == null)) {
                    this.RawFilesGroupField = null;
                }
                else {
                    if ((this.RawFilesGroupField == null)) {
                        this.RawFilesGroupField = XTypedList<RawFilesGroupType>.Initialize(this, LinqToXsdTypeManager.Instance, value, RawFilesGroupXName);
                    }
                    else {
                        XTypedServices.SetList<RawFilesGroupType>(this.RawFilesGroupField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// <para>
        /// Regular expression: (RawFilesGroup*, MethodFiles?, IdentificationFiles?, SearchDatabase*, SourceFile*)
        /// </para>
        /// </summary>
        public virtual MethodFilesType MethodFiles {
            get {
                XElement x = this.GetElement(MethodFilesXName);
                return ((MethodFilesType)(x));
            }
            set {
                this.SetElement(MethodFilesXName, value);
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// <para>
        /// Regular expression: (RawFilesGroup*, MethodFiles?, IdentificationFiles?, SearchDatabase*, SourceFile*)
        /// </para>
        /// </summary>
        public virtual IdentificationFilesType IdentificationFiles {
            get {
                XElement x = this.GetElement(IdentificationFilesXName);
                return ((IdentificationFilesType)(x));
            }
            set {
                this.SetElement(IdentificationFilesXName, value);
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional, repeating
        /// </para>
        /// <para>
        /// Regular expression: (RawFilesGroup*, MethodFiles?, IdentificationFiles?, SearchDatabase*, SourceFile*)
        /// </para>
        /// </summary>
        public virtual IList<SearchDatabaseType> SearchDatabase {
            get {
                if ((this.SearchDatabaseField == null)) {
                    this.SearchDatabaseField = new XTypedList<SearchDatabaseType>(this, LinqToXsdTypeManager.Instance, SearchDatabaseXName);
                }
                return this.SearchDatabaseField;
            }
            set {
                if ((value == null)) {
                    this.SearchDatabaseField = null;
                }
                else {
                    if ((this.SearchDatabaseField == null)) {
                        this.SearchDatabaseField = XTypedList<SearchDatabaseType>.Initialize(this, LinqToXsdTypeManager.Instance, value, SearchDatabaseXName);
                    }
                    else {
                        XTypedServices.SetList<SearchDatabaseType>(this.SearchDatabaseField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional, repeating
        /// </para>
        /// <para>
        /// Regular expression: (RawFilesGroup*, MethodFiles?, IdentificationFiles?, SearchDatabase*, SourceFile*)
        /// </para>
        /// </summary>
        public virtual IList<SourceFileType> SourceFile {
            get {
                if ((this.SourceFileField == null)) {
                    this.SourceFileField = new XTypedList<SourceFileType>(this, LinqToXsdTypeManager.Instance, SourceFileXName);
                }
                return this.SourceFileField;
            }
            set {
                if ((value == null)) {
                    this.SourceFileField = null;
                }
                else {
                    if ((this.SourceFileField == null)) {
                        this.SourceFileField = XTypedList<SourceFileType>.Initialize(this, LinqToXsdTypeManager.Instance, value, SourceFileXName);
                    }
                    else {
                        XTypedServices.SetList<SourceFileType>(this.SourceFileField, value);
                    }
                }
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<InputFilesType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(RawFilesGroupXName, typeof(RawFilesGroupType));
            localElementDictionary.Add(MethodFilesXName, typeof(MethodFilesType));
            localElementDictionary.Add(IdentificationFilesXName, typeof(IdentificationFilesType));
            localElementDictionary.Add(SearchDatabaseXName, typeof(SearchDatabaseType));
            localElementDictionary.Add(SourceFileXName, typeof(SourceFileType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    /// <summary>
    /// <para>
    /// A database used for searching mass spectra. Examples include a set of amino acid sequence entries, or annotated spectra libraries. 
    /// </para>
    /// <para>
    /// Regular expression: (ExternalFormatDocumentation?, FileFormat?, DatabaseName, cvParam*)
    /// </para>
    /// </summary>
    public partial class SearchDatabaseType : global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.ExternalDataType, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName DatabaseNameXName = System.Xml.Linq.XName.Get("DatabaseName", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName cvParamXName = System.Xml.Linq.XName.Get("cvParam", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<CVParamType> cvParamField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName versionXName = System.Xml.Linq.XName.Get("version", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName releaseDateXName = System.Xml.Linq.XName.Get("releaseDate", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName numDatabaseEntriesXName = System.Xml.Linq.XName.Get("numDatabaseEntries", "");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("SearchDatabaseType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator SearchDatabaseType(XElement xe) { return XTypedServices.ToXTypedElement<SearchDatabaseType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static SearchDatabaseType() {
            BuildElementDictionary();
            contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(ExternalFormatDocumentationXName), new NamedContentModelEntity(FileFormatXName), new NamedContentModelEntity(DatabaseNameXName), new NamedContentModelEntity(cvParamXName));
        }
        
        /// <summary>
        /// <para>
        /// A database used for searching mass spectra. Examples include a set of amino acid sequence entries, or annotated spectra libraries. 
        /// </para>
        /// <para>
        /// Regular expression: (ExternalFormatDocumentation?, FileFormat?, DatabaseName, cvParam*)
        /// </para>
        /// </summary>
        public SearchDatabaseType() {
        }
        
        /// <summary>
        /// <para>
        /// The database name may be given as a cvParam if it maps exactly to one of the release databases listed in the CV, otherwise a userParam should be used. 
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// <para>
        /// Regular expression: (ExternalFormatDocumentation?, FileFormat?, DatabaseName, cvParam*)
        /// </para>
        /// </summary>
        public virtual ParamType DatabaseName {
            get {
                XElement x = this.GetElement(DatabaseNameXName);
                return ((ParamType)(x));
            }
            set {
                this.SetElement(DatabaseNameXName, value);
            }
        }
        
        /// <summary>
        /// <para>
        /// Any additional parameters describing the database.
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating
        /// </para>
        /// <para>
        /// Regular expression: (ExternalFormatDocumentation?, FileFormat?, DatabaseName, cvParam*)
        /// </para>
        /// </summary>
        public virtual IList<CVParamType> cvParam {
            get {
                if ((this.cvParamField == null)) {
                    this.cvParamField = new XTypedList<CVParamType>(this, LinqToXsdTypeManager.Instance, cvParamXName);
                }
                return this.cvParamField;
            }
            set {
                if ((value == null)) {
                    this.cvParamField = null;
                }
                else {
                    if ((this.cvParamField == null)) {
                        this.cvParamField = XTypedList<CVParamType>.Initialize(this, LinqToXsdTypeManager.Instance, value, cvParamXName);
                    }
                    else {
                        XTypedServices.SetList<CVParamType>(this.cvParamField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// The version of the database.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string version {
            get {
                XAttribute x = this.Attribute(versionXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(versionXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The date and time the database was released to the public; omit this attribute when the date and time are unknown or not applicable (e.g. custom databases). 
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual System.DateTime? releaseDate {
            get {
                XAttribute x = this.Attribute(releaseDateXName);
                if ((x == null)) {
                    return null;
                }
                return XTypedServices.ParseValue<System.DateTime>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.DateTime).Datatype);
            }
            set {
                this.SetAttribute(releaseDateXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.DateTime).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The total number of entries in the database.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual System.Int64? numDatabaseEntries {
            get {
                XAttribute x = this.Attribute(numDatabaseEntriesXName);
                if ((x == null)) {
                    return null;
                }
                return XTypedServices.ParseValue<long>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Long).Datatype);
            }
            set {
                this.SetAttribute(numDatabaseEntriesXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Long).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<SearchDatabaseType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(ExternalFormatDocumentationXName, typeof(System.Uri));
            localElementDictionary.Add(FileFormatXName, typeof(FileFormatType));
            localElementDictionary.Add(DatabaseNameXName, typeof(ParamType));
            localElementDictionary.Add(cvParamXName, typeof(CVParamType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    /// <summary>
    /// <para>
    /// A file from which this MzQuantML instance was created, including potentially MzQuantML files for earlier stages in a workflow.
    /// </para>
    /// <para>
    /// Regular expression: (ExternalFormatDocumentation?, FileFormat?)
    /// </para>
    /// </summary>
    public partial class SourceFileType : global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.ExternalDataType, IXMetaData {
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("SourceFileType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator SourceFileType(XElement xe) { return XTypedServices.ToXTypedElement<SourceFileType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static SourceFileType() {
            BuildElementDictionary();
            contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(ExternalFormatDocumentationXName), new NamedContentModelEntity(FileFormatXName));
        }
        
        /// <summary>
        /// <para>
        /// A file from which this MzQuantML instance was created, including potentially MzQuantML files for earlier stages in a workflow.
        /// </para>
        /// <para>
        /// Regular expression: (ExternalFormatDocumentation?, FileFormat?)
        /// </para>
        /// </summary>
        public SourceFileType() {
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<SourceFileType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(ExternalFormatDocumentationXName, typeof(System.Uri));
            localElementDictionary.Add(FileFormatXName, typeof(FileFormatType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    /// <summary>
    /// <para>
    /// The list of experimental conditions used to group results.
    /// </para>
    /// <para>
    /// Regular expression: (StudyVariable+)
    /// </para>
    /// </summary>
    public partial class StudyVariableListType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName StudyVariableXName = System.Xml.Linq.XName.Get("StudyVariable", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<StudyVariableType> StudyVariableField;
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("StudyVariableListType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator StudyVariableListType(XElement xe) { return XTypedServices.ToXTypedElement<StudyVariableListType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static StudyVariableListType() {
            BuildElementDictionary();
            contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(StudyVariableXName));
        }
        
        /// <summary>
        /// <para>
        /// The list of experimental conditions used to group results.
        /// </para>
        /// <para>
        /// Regular expression: (StudyVariable+)
        /// </para>
        /// </summary>
        public StudyVariableListType() {
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, repeating
        /// </para>
        /// <para>
        /// Regular expression: (StudyVariable+)
        /// </para>
        /// </summary>
        public virtual IList<StudyVariableType> StudyVariable {
            get {
                if ((this.StudyVariableField == null)) {
                    this.StudyVariableField = new XTypedList<StudyVariableType>(this, LinqToXsdTypeManager.Instance, StudyVariableXName);
                }
                return this.StudyVariableField;
            }
            set {
                if ((value == null)) {
                    this.StudyVariableField = null;
                }
                else {
                    if ((this.StudyVariableField == null)) {
                        this.StudyVariableField = XTypedList<StudyVariableType>.Initialize(this, LinqToXsdTypeManager.Instance, value, StudyVariableXName);
                    }
                    else {
                        XTypedServices.SetList<StudyVariableType>(this.StudyVariableField, value);
                    }
                }
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<StudyVariableListType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(StudyVariableXName, typeof(StudyVariableType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    /// <summary>
    /// <para>
    /// A source controlled vocabulary from which cvParams will be obtained.
    /// </para>
    /// </summary>
    public partial class CvType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName fullNameXName = System.Xml.Linq.XName.Get("fullName", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName versionXName = System.Xml.Linq.XName.Get("version", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName uriXName = System.Xml.Linq.XName.Get("uri", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName idXName = System.Xml.Linq.XName.Get("id", "");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("CvType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
		public static explicit operator CvType(XElement xe) { return XTypedServices.ToXTypedElement<CvType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        /// <summary>
        /// <para>
        /// A source controlled vocabulary from which cvParams will be obtained.
        /// </para>
        /// </summary>
        public CvType() {
        }
        
        /// <summary>
        /// <para>
        /// The full name of the CV.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual string fullName {
            get {
                XAttribute x = this.Attribute(fullNameXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(fullNameXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The version of the CV.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string version {
            get {
                XAttribute x = this.Attribute(versionXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(versionXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The URI of the source CV.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual System.Uri uri {
            get {
                XAttribute x = this.Attribute(uriXName);
                return XTypedServices.ParseValue<System.Uri>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.AnyUri).Datatype);
            }
            set {
                this.SetAttribute(uriXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.AnyUri).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The unique identifier of this cv within the document to be referenced by cvParam elements.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual string id {
            get {
                XAttribute x = this.Attribute(idXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Id).Datatype);
            }
            set {
                this.SetAttribute(idXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Id).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<CvType>(this);
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
    }
    
    /// <summary>
    /// <para>
    /// The definition of ratios of study variables or assays, referenced elsewhere in the document.
    /// </para>
    /// <para>
    /// Regular expression: (Ratio+)
    /// </para>
    /// </summary>
    public partial class RatioListType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName RatioXName = System.Xml.Linq.XName.Get("Ratio", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<RatioType> RatioField;
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("RatioListType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator RatioListType(XElement xe) { return XTypedServices.ToXTypedElement<RatioListType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static RatioListType() {
            BuildElementDictionary();
            contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(RatioXName));
        }
        
        /// <summary>
        /// <para>
        /// The definition of ratios of study variables or assays, referenced elsewhere in the document.
        /// </para>
        /// <para>
        /// Regular expression: (Ratio+)
        /// </para>
        /// </summary>
        public RatioListType() {
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, repeating
        /// </para>
        /// <para>
        /// Regular expression: (Ratio+)
        /// </para>
        /// </summary>
        public virtual IList<RatioType> Ratio {
            get {
                if ((this.RatioField == null)) {
                    this.RatioField = new XTypedList<RatioType>(this, LinqToXsdTypeManager.Instance, RatioXName);
                }
                return this.RatioField;
            }
            set {
                if ((value == null)) {
                    this.RatioField = null;
                }
                else {
                    if ((this.RatioField == null)) {
                        this.RatioField = XTypedList<RatioType>.Initialize(this, LinqToXsdTypeManager.Instance, value, RatioXName);
                    }
                    else {
                        XTypedServices.SetList<RatioType>(this.RatioField, value);
                    }
                }
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<RatioListType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(RatioXName, typeof(RatioType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    /// <summary>
    /// <para>
    /// The list of all groups of proteins with conflicting evidence for which quantitation values are being reported along with quantitative values about those protein groups. If quantitation is done on individual proteins only, ProteinGroupsList should not be included.
    /// </para>
    /// <para>
    /// Regular expression: (ProteinGroup+, GlobalQuantLayer*, AssayQuantLayer*, StudyVariableQuantLayer*, RatioQuantLayer?, (cvParam | userParam)*)
    /// </para>
    /// </summary>
    public partial class ProteinGroupListType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName ProteinGroupXName = System.Xml.Linq.XName.Get("ProteinGroup", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<ProteinGroupType> ProteinGroupField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName GlobalQuantLayerXName = System.Xml.Linq.XName.Get("GlobalQuantLayer", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<GlobalQuantLayerType> GlobalQuantLayerField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName AssayQuantLayerXName = System.Xml.Linq.XName.Get("AssayQuantLayer", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<QuantLayerType> AssayQuantLayerField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName StudyVariableQuantLayerXName = System.Xml.Linq.XName.Get("StudyVariableQuantLayer", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<QuantLayerType> StudyVariableQuantLayerField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName RatioQuantLayerXName = System.Xml.Linq.XName.Get("RatioQuantLayer", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName cvParamXName = System.Xml.Linq.XName.Get("cvParam", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<CVParamType> cvParamField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName userParamXName = System.Xml.Linq.XName.Get("userParam", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<UserParamType> userParamField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName idXName = System.Xml.Linq.XName.Get("id", "");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("ProteinGroupListType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator ProteinGroupListType(XElement xe) { return XTypedServices.ToXTypedElement<ProteinGroupListType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static ProteinGroupListType() {
            BuildElementDictionary();
            contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(ProteinGroupXName), new NamedContentModelEntity(GlobalQuantLayerXName), new NamedContentModelEntity(AssayQuantLayerXName), new NamedContentModelEntity(StudyVariableQuantLayerXName), new NamedContentModelEntity(RatioQuantLayerXName), new ChoiceContentModelEntity(new NamedContentModelEntity(cvParamXName), new NamedContentModelEntity(userParamXName)));
        }
        
        /// <summary>
        /// <para>
        /// The list of all groups of proteins with conflicting evidence for which quantitation values are being reported along with quantitative values about those protein groups. If quantitation is done on individual proteins only, ProteinGroupsList should not be included.
        /// </para>
        /// <para>
        /// Regular expression: (ProteinGroup+, GlobalQuantLayer*, AssayQuantLayer*, StudyVariableQuantLayer*, RatioQuantLayer?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public ProteinGroupListType() {
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, repeating
        /// </para>
        /// <para>
        /// Regular expression: (ProteinGroup+, GlobalQuantLayer*, AssayQuantLayer*, StudyVariableQuantLayer*, RatioQuantLayer?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<ProteinGroupType> ProteinGroup {
            get {
                if ((this.ProteinGroupField == null)) {
                    this.ProteinGroupField = new XTypedList<ProteinGroupType>(this, LinqToXsdTypeManager.Instance, ProteinGroupXName);
                }
                return this.ProteinGroupField;
            }
            set {
                if ((value == null)) {
                    this.ProteinGroupField = null;
                }
                else {
                    if ((this.ProteinGroupField == null)) {
                        this.ProteinGroupField = XTypedList<ProteinGroupType>.Initialize(this, LinqToXsdTypeManager.Instance, value, ProteinGroupXName);
                    }
                    else {
                        XTypedServices.SetList<ProteinGroupType>(this.ProteinGroupField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Global values corresponding to the ProteinGroup such as the total intensity of the protein group in all assays, Anova etc. 
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating
        /// </para>
        /// <para>
        /// Regular expression: (ProteinGroup+, GlobalQuantLayer*, AssayQuantLayer*, StudyVariableQuantLayer*, RatioQuantLayer?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<GlobalQuantLayerType> GlobalQuantLayer {
            get {
                if ((this.GlobalQuantLayerField == null)) {
                    this.GlobalQuantLayerField = new XTypedList<GlobalQuantLayerType>(this, LinqToXsdTypeManager.Instance, GlobalQuantLayerXName);
                }
                return this.GlobalQuantLayerField;
            }
            set {
                if ((value == null)) {
                    this.GlobalQuantLayerField = null;
                }
                else {
                    if ((this.GlobalQuantLayerField == null)) {
                        this.GlobalQuantLayerField = XTypedList<GlobalQuantLayerType>.Initialize(this, LinqToXsdTypeManager.Instance, value, GlobalQuantLayerXName);
                    }
                    else {
                        XTypedServices.SetList<GlobalQuantLayerType>(this.GlobalQuantLayerField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Quant layer for reporting data values about protein groups related to different assays i.e. the column index MUST refer to Assays defined in the file.  
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating
        /// </para>
        /// <para>
        /// Regular expression: (ProteinGroup+, GlobalQuantLayer*, AssayQuantLayer*, StudyVariableQuantLayer*, RatioQuantLayer?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<QuantLayerType> AssayQuantLayer {
            get {
                if ((this.AssayQuantLayerField == null)) {
                    this.AssayQuantLayerField = new XTypedList<QuantLayerType>(this, LinqToXsdTypeManager.Instance, AssayQuantLayerXName);
                }
                return this.AssayQuantLayerField;
            }
            set {
                if ((value == null)) {
                    this.AssayQuantLayerField = null;
                }
                else {
                    if ((this.AssayQuantLayerField == null)) {
                        this.AssayQuantLayerField = XTypedList<QuantLayerType>.Initialize(this, LinqToXsdTypeManager.Instance, value, AssayQuantLayerXName);
                    }
                    else {
                        XTypedServices.SetList<QuantLayerType>(this.AssayQuantLayerField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Quant layer for reporting data values about protein groups related to different study variables i.e. the column index MUST refer to StudyVariables defined in the file. 
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating
        /// </para>
        /// <para>
        /// Regular expression: (ProteinGroup+, GlobalQuantLayer*, AssayQuantLayer*, StudyVariableQuantLayer*, RatioQuantLayer?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<QuantLayerType> StudyVariableQuantLayer {
            get {
                if ((this.StudyVariableQuantLayerField == null)) {
                    this.StudyVariableQuantLayerField = new XTypedList<QuantLayerType>(this, LinqToXsdTypeManager.Instance, StudyVariableQuantLayerXName);
                }
                return this.StudyVariableQuantLayerField;
            }
            set {
                if ((value == null)) {
                    this.StudyVariableQuantLayerField = null;
                }
                else {
                    if ((this.StudyVariableQuantLayerField == null)) {
                        this.StudyVariableQuantLayerField = XTypedList<QuantLayerType>.Initialize(this, LinqToXsdTypeManager.Instance, value, StudyVariableQuantLayerXName);
                    }
                    else {
                        XTypedServices.SetList<QuantLayerType>(this.StudyVariableQuantLayerField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Quant layer for reporting data values about protein groups related to different ratios i.e. the column index MUST refer to Ratio elements defined in the file.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// <para>
        /// Regular expression: (ProteinGroup+, GlobalQuantLayer*, AssayQuantLayer*, StudyVariableQuantLayer*, RatioQuantLayer?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual RatioQuantLayerType RatioQuantLayer {
            get {
                XElement x = this.GetElement(RatioQuantLayerXName);
                return ((RatioQuantLayerType)(x));
            }
            set {
                this.SetElement(RatioQuantLayerXName, value);
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Setter: Appends
        /// </para>
        /// <para>
        /// Regular expression: (ProteinGroup+, GlobalQuantLayer*, AssayQuantLayer*, StudyVariableQuantLayer*, RatioQuantLayer?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<CVParamType> cvParam {
            get {
                if ((this.cvParamField == null)) {
                    this.cvParamField = new XTypedList<CVParamType>(this, LinqToXsdTypeManager.Instance, cvParamXName);
                }
                return this.cvParamField;
            }
            set {
                if ((value == null)) {
                    this.cvParamField = null;
                }
                else {
                    if ((this.cvParamField == null)) {
                        this.cvParamField = XTypedList<CVParamType>.Initialize(this, LinqToXsdTypeManager.Instance, value, cvParamXName);
                    }
                    else {
                        XTypedServices.SetList<CVParamType>(this.cvParamField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Setter: Appends
        /// </para>
        /// <para>
        /// Regular expression: (ProteinGroup+, GlobalQuantLayer*, AssayQuantLayer*, StudyVariableQuantLayer*, RatioQuantLayer?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<UserParamType> userParam {
            get {
                if ((this.userParamField == null)) {
                    this.userParamField = new XTypedList<UserParamType>(this, LinqToXsdTypeManager.Instance, userParamXName);
                }
                return this.userParamField;
            }
            set {
                if ((value == null)) {
                    this.userParamField = null;
                }
                else {
                    if ((this.userParamField == null)) {
                        this.userParamField = XTypedList<UserParamType>.Initialize(this, LinqToXsdTypeManager.Instance, value, userParamXName);
                    }
                    else {
                        XTypedServices.SetList<UserParamType>(this.userParamField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// The unique identifier for the object within the file.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual string id {
            get {
                XAttribute x = this.Attribute(idXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Id).Datatype);
            }
            set {
                this.SetAttribute(idXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Id).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<ProteinGroupListType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(ProteinGroupXName, typeof(ProteinGroupType));
            localElementDictionary.Add(GlobalQuantLayerXName, typeof(GlobalQuantLayerType));
            localElementDictionary.Add(AssayQuantLayerXName, typeof(QuantLayerType));
            localElementDictionary.Add(StudyVariableQuantLayerXName, typeof(QuantLayerType));
            localElementDictionary.Add(RatioQuantLayerXName, typeof(RatioQuantLayerType));
            localElementDictionary.Add(cvParamXName, typeof(CVParamType));
            localElementDictionary.Add(userParamXName, typeof(UserParamType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    /// <summary>
    /// <para>
    /// The list of all individual proteins (i.e. ungrouped) for which quantitation values are being reported. If quantitation is done on protein groups, the constituent proteins should be listed here with no QuantLayers.
    /// </para>
    /// <para>
    /// Regular expression: (Protein+, GlobalQuantLayer*, AssayQuantLayer*, StudyVariableQuantLayer*, RatioQuantLayer?, (cvParam | userParam)*)
    /// </para>
    /// </summary>
    public partial class ProteinListType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName ProteinXName = System.Xml.Linq.XName.Get("Protein", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<ProteinType> ProteinField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName GlobalQuantLayerXName = System.Xml.Linq.XName.Get("GlobalQuantLayer", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<GlobalQuantLayerType> GlobalQuantLayerField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName AssayQuantLayerXName = System.Xml.Linq.XName.Get("AssayQuantLayer", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<QuantLayerType> AssayQuantLayerField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName StudyVariableQuantLayerXName = System.Xml.Linq.XName.Get("StudyVariableQuantLayer", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<QuantLayerType> StudyVariableQuantLayerField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName RatioQuantLayerXName = System.Xml.Linq.XName.Get("RatioQuantLayer", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName cvParamXName = System.Xml.Linq.XName.Get("cvParam", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<CVParamType> cvParamField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName userParamXName = System.Xml.Linq.XName.Get("userParam", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<UserParamType> userParamField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName idXName = System.Xml.Linq.XName.Get("id", "");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("ProteinListType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator ProteinListType(XElement xe) { return XTypedServices.ToXTypedElement<ProteinListType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static ProteinListType() {
            BuildElementDictionary();
            contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(ProteinXName), new NamedContentModelEntity(GlobalQuantLayerXName), new NamedContentModelEntity(AssayQuantLayerXName), new NamedContentModelEntity(StudyVariableQuantLayerXName), new NamedContentModelEntity(RatioQuantLayerXName), new ChoiceContentModelEntity(new NamedContentModelEntity(cvParamXName), new NamedContentModelEntity(userParamXName)));
        }
        
        /// <summary>
        /// <para>
        /// The list of all individual proteins (i.e. ungrouped) for which quantitation values are being reported. If quantitation is done on protein groups, the constituent proteins should be listed here with no QuantLayers.
        /// </para>
        /// <para>
        /// Regular expression: (Protein+, GlobalQuantLayer*, AssayQuantLayer*, StudyVariableQuantLayer*, RatioQuantLayer?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public ProteinListType() {
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, repeating
        /// </para>
        /// <para>
        /// Regular expression: (Protein+, GlobalQuantLayer*, AssayQuantLayer*, StudyVariableQuantLayer*, RatioQuantLayer?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<ProteinType> Protein {
            get {
                if ((this.ProteinField == null)) {
                    this.ProteinField = new XTypedList<ProteinType>(this, LinqToXsdTypeManager.Instance, ProteinXName);
                }
                return this.ProteinField;
            }
            set {
                if ((value == null)) {
                    this.ProteinField = null;
                }
                else {
                    if ((this.ProteinField == null)) {
                        this.ProteinField = XTypedList<ProteinType>.Initialize(this, LinqToXsdTypeManager.Instance, value, ProteinXName);
                    }
                    else {
                        XTypedServices.SetList<ProteinType>(this.ProteinField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Global values corresponding to the Protein such as the total intensity of the protein in all assays, Anova etc. 
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating
        /// </para>
        /// <para>
        /// Regular expression: (Protein+, GlobalQuantLayer*, AssayQuantLayer*, StudyVariableQuantLayer*, RatioQuantLayer?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<GlobalQuantLayerType> GlobalQuantLayer {
            get {
                if ((this.GlobalQuantLayerField == null)) {
                    this.GlobalQuantLayerField = new XTypedList<GlobalQuantLayerType>(this, LinqToXsdTypeManager.Instance, GlobalQuantLayerXName);
                }
                return this.GlobalQuantLayerField;
            }
            set {
                if ((value == null)) {
                    this.GlobalQuantLayerField = null;
                }
                else {
                    if ((this.GlobalQuantLayerField == null)) {
                        this.GlobalQuantLayerField = XTypedList<GlobalQuantLayerType>.Initialize(this, LinqToXsdTypeManager.Instance, value, GlobalQuantLayerXName);
                    }
                    else {
                        XTypedServices.SetList<GlobalQuantLayerType>(this.GlobalQuantLayerField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Quant layer for reporting data values about proteins related to different assays i.e. the column index MUST refer to Assays defined in the file.  
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating
        /// </para>
        /// <para>
        /// Regular expression: (Protein+, GlobalQuantLayer*, AssayQuantLayer*, StudyVariableQuantLayer*, RatioQuantLayer?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<QuantLayerType> AssayQuantLayer {
            get {
                if ((this.AssayQuantLayerField == null)) {
                    this.AssayQuantLayerField = new XTypedList<QuantLayerType>(this, LinqToXsdTypeManager.Instance, AssayQuantLayerXName);
                }
                return this.AssayQuantLayerField;
            }
            set {
                if ((value == null)) {
                    this.AssayQuantLayerField = null;
                }
                else {
                    if ((this.AssayQuantLayerField == null)) {
                        this.AssayQuantLayerField = XTypedList<QuantLayerType>.Initialize(this, LinqToXsdTypeManager.Instance, value, AssayQuantLayerXName);
                    }
                    else {
                        XTypedServices.SetList<QuantLayerType>(this.AssayQuantLayerField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Quant layer for reporting data values about proteins related to different study variables i.e. the column index MUST refer to StudyVariables defined in the file. 
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating
        /// </para>
        /// <para>
        /// Regular expression: (Protein+, GlobalQuantLayer*, AssayQuantLayer*, StudyVariableQuantLayer*, RatioQuantLayer?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<QuantLayerType> StudyVariableQuantLayer {
            get {
                if ((this.StudyVariableQuantLayerField == null)) {
                    this.StudyVariableQuantLayerField = new XTypedList<QuantLayerType>(this, LinqToXsdTypeManager.Instance, StudyVariableQuantLayerXName);
                }
                return this.StudyVariableQuantLayerField;
            }
            set {
                if ((value == null)) {
                    this.StudyVariableQuantLayerField = null;
                }
                else {
                    if ((this.StudyVariableQuantLayerField == null)) {
                        this.StudyVariableQuantLayerField = XTypedList<QuantLayerType>.Initialize(this, LinqToXsdTypeManager.Instance, value, StudyVariableQuantLayerXName);
                    }
                    else {
                        XTypedServices.SetList<QuantLayerType>(this.StudyVariableQuantLayerField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Quant layer for reporting data values about proteins related to different ratios i.e. the column index MUST refer to Ratio elements defined in the file.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// <para>
        /// Regular expression: (Protein+, GlobalQuantLayer*, AssayQuantLayer*, StudyVariableQuantLayer*, RatioQuantLayer?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual RatioQuantLayerType RatioQuantLayer {
            get {
                XElement x = this.GetElement(RatioQuantLayerXName);
                return ((RatioQuantLayerType)(x));
            }
            set {
                this.SetElement(RatioQuantLayerXName, value);
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Setter: Appends
        /// </para>
        /// <para>
        /// Regular expression: (Protein+, GlobalQuantLayer*, AssayQuantLayer*, StudyVariableQuantLayer*, RatioQuantLayer?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<CVParamType> cvParam {
            get {
                if ((this.cvParamField == null)) {
                    this.cvParamField = new XTypedList<CVParamType>(this, LinqToXsdTypeManager.Instance, cvParamXName);
                }
                return this.cvParamField;
            }
            set {
                if ((value == null)) {
                    this.cvParamField = null;
                }
                else {
                    if ((this.cvParamField == null)) {
                        this.cvParamField = XTypedList<CVParamType>.Initialize(this, LinqToXsdTypeManager.Instance, value, cvParamXName);
                    }
                    else {
                        XTypedServices.SetList<CVParamType>(this.cvParamField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Setter: Appends
        /// </para>
        /// <para>
        /// Regular expression: (Protein+, GlobalQuantLayer*, AssayQuantLayer*, StudyVariableQuantLayer*, RatioQuantLayer?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<UserParamType> userParam {
            get {
                if ((this.userParamField == null)) {
                    this.userParamField = new XTypedList<UserParamType>(this, LinqToXsdTypeManager.Instance, userParamXName);
                }
                return this.userParamField;
            }
            set {
                if ((value == null)) {
                    this.userParamField = null;
                }
                else {
                    if ((this.userParamField == null)) {
                        this.userParamField = XTypedList<UserParamType>.Initialize(this, LinqToXsdTypeManager.Instance, value, userParamXName);
                    }
                    else {
                        XTypedServices.SetList<UserParamType>(this.userParamField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// The unique identifier for the object within the file.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual string id {
            get {
                XAttribute x = this.Attribute(idXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Id).Datatype);
            }
            set {
                this.SetAttribute(idXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Id).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<ProteinListType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(ProteinXName, typeof(ProteinType));
            localElementDictionary.Add(GlobalQuantLayerXName, typeof(GlobalQuantLayerType));
            localElementDictionary.Add(AssayQuantLayerXName, typeof(QuantLayerType));
            localElementDictionary.Add(StudyVariableQuantLayerXName, typeof(QuantLayerType));
            localElementDictionary.Add(RatioQuantLayerXName, typeof(RatioQuantLayerType));
            localElementDictionary.Add(cvParamXName, typeof(CVParamType));
            localElementDictionary.Add(userParamXName, typeof(UserParamType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    /// <summary>
    /// <para>
    /// A grouping of quantified proteins based on ambiguous assignment of peptide evidence to protein identification. The semantics of elements within the group, such as a leading protein or those sharing equal evidence can be reported using cvParams.
    /// </para>
    /// <para>
    /// Regular expression: (IdentificationRef*, ProteinRef+, (cvParam | userParam)*)
    /// </para>
    /// </summary>
    public partial class ProteinGroupType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName IdentificationRefXName = System.Xml.Linq.XName.Get("IdentificationRef", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<IdentificationRefType> IdentificationRefField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName ProteinRefXName = System.Xml.Linq.XName.Get("ProteinRef", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<ProteinRefType> ProteinRefField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName cvParamXName = System.Xml.Linq.XName.Get("cvParam", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<CVParamType> cvParamField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName userParamXName = System.Xml.Linq.XName.Get("userParam", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<UserParamType> userParamField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName idXName = System.Xml.Linq.XName.Get("id", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName searchDatabase_refXName = System.Xml.Linq.XName.Get("searchDatabase_ref", "");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("ProteinGroupType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator ProteinGroupType(XElement xe) { return XTypedServices.ToXTypedElement<ProteinGroupType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static ProteinGroupType() {
            BuildElementDictionary();
            contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(IdentificationRefXName), new NamedContentModelEntity(ProteinRefXName), new ChoiceContentModelEntity(new NamedContentModelEntity(cvParamXName), new NamedContentModelEntity(userParamXName)));
        }
        
        /// <summary>
        /// <para>
        /// A grouping of quantified proteins based on ambiguous assignment of peptide evidence to protein identification. The semantics of elements within the group, such as a leading protein or those sharing equal evidence can be reported using cvParams.
        /// </para>
        /// <para>
        /// Regular expression: (IdentificationRef*, ProteinRef+, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public ProteinGroupType() {
        }
        
        /// <summary>
        /// <para>
        /// Reference for the identification evidence for peptides from the referenced external file and unique identifier e.g. a link to an mzIdentML file and ID for the ProteinAmbiguityGroup.
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating
        /// </para>
        /// <para>
        /// Regular expression: (IdentificationRef*, ProteinRef+, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<IdentificationRefType> IdentificationRef {
            get {
                if ((this.IdentificationRefField == null)) {
                    this.IdentificationRefField = new XTypedList<IdentificationRefType>(this, LinqToXsdTypeManager.Instance, IdentificationRefXName);
                }
                return this.IdentificationRefField;
            }
            set {
                if ((value == null)) {
                    this.IdentificationRefField = null;
                }
                else {
                    if ((this.IdentificationRefField == null)) {
                        this.IdentificationRefField = XTypedList<IdentificationRefType>.Initialize(this, LinqToXsdTypeManager.Instance, value, IdentificationRefXName);
                    }
                    else {
                        XTypedServices.SetList<IdentificationRefType>(this.IdentificationRefField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, repeating
        /// </para>
        /// <para>
        /// Regular expression: (IdentificationRef*, ProteinRef+, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<ProteinRefType> ProteinRef {
            get {
                if ((this.ProteinRefField == null)) {
                    this.ProteinRefField = new XTypedList<ProteinRefType>(this, LinqToXsdTypeManager.Instance, ProteinRefXName);
                }
                return this.ProteinRefField;
            }
            set {
                if ((value == null)) {
                    this.ProteinRefField = null;
                }
                else {
                    if ((this.ProteinRefField == null)) {
                        this.ProteinRefField = XTypedList<ProteinRefType>.Initialize(this, LinqToXsdTypeManager.Instance, value, ProteinRefXName);
                    }
                    else {
                        XTypedServices.SetList<ProteinRefType>(this.ProteinRefField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Setter: Appends
        /// </para>
        /// <para>
        /// Regular expression: (IdentificationRef*, ProteinRef+, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<CVParamType> cvParam {
            get {
                if ((this.cvParamField == null)) {
                    this.cvParamField = new XTypedList<CVParamType>(this, LinqToXsdTypeManager.Instance, cvParamXName);
                }
                return this.cvParamField;
            }
            set {
                if ((value == null)) {
                    this.cvParamField = null;
                }
                else {
                    if ((this.cvParamField == null)) {
                        this.cvParamField = XTypedList<CVParamType>.Initialize(this, LinqToXsdTypeManager.Instance, value, cvParamXName);
                    }
                    else {
                        XTypedServices.SetList<CVParamType>(this.cvParamField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Setter: Appends
        /// </para>
        /// <para>
        /// Regular expression: (IdentificationRef*, ProteinRef+, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<UserParamType> userParam {
            get {
                if ((this.userParamField == null)) {
                    this.userParamField = new XTypedList<UserParamType>(this, LinqToXsdTypeManager.Instance, userParamXName);
                }
                return this.userParamField;
            }
            set {
                if ((value == null)) {
                    this.userParamField = null;
                }
                else {
                    if ((this.userParamField == null)) {
                        this.userParamField = XTypedList<UserParamType>.Initialize(this, LinqToXsdTypeManager.Instance, value, userParamXName);
                    }
                    else {
                        XTypedServices.SetList<UserParamType>(this.userParamField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// The unique identifier for the object within the file.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual string id {
            get {
                XAttribute x = this.Attribute(idXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Id).Datatype);
            }
            set {
                this.SetAttribute(idXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Id).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The search database from which this protein group was identified
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual string searchDatabase_ref {
            get {
                XAttribute x = this.Attribute(searchDatabase_refXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
            set {
                this.SetAttribute(searchDatabase_refXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<ProteinGroupType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(IdentificationRefXName, typeof(IdentificationRefType));
            localElementDictionary.Add(ProteinRefXName, typeof(ProteinRefType));
            localElementDictionary.Add(cvParamXName, typeof(CVParamType));
            localElementDictionary.Add(userParamXName, typeof(UserParamType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    /// <summary>
    /// <para>
    /// A reference to one of the Proteins contained within this group, along with CV terms describing the role it plays within the group, such as representative or anchor protein, same set or sub-set.
    /// </para>
    /// <para>
    /// Regular expression: ((cvParam | userParam)*)
    /// </para>
    /// </summary>
    public partial class ProteinRefType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName cvParamXName = System.Xml.Linq.XName.Get("cvParam", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<CVParamType> cvParamField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName userParamXName = System.Xml.Linq.XName.Get("userParam", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<UserParamType> userParamField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName protein_refXName = System.Xml.Linq.XName.Get("protein_ref", "");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("ProteinRefType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator ProteinRefType(XElement xe) { return XTypedServices.ToXTypedElement<ProteinRefType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static ProteinRefType() {
            BuildElementDictionary();
            contentModel = new SequenceContentModelEntity(new ChoiceContentModelEntity(new NamedContentModelEntity(cvParamXName), new NamedContentModelEntity(userParamXName)));
        }
        
        /// <summary>
        /// <para>
        /// A reference to one of the Proteins contained within this group, along with CV terms describing the role it plays within the group, such as representative or anchor protein, same set or sub-set.
        /// </para>
        /// <para>
        /// Regular expression: ((cvParam | userParam)*)
        /// </para>
        /// </summary>
        public ProteinRefType() {
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Setter: Appends
        /// </para>
        /// <para>
        /// Regular expression: ((cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<CVParamType> cvParam {
            get {
                if ((this.cvParamField == null)) {
                    this.cvParamField = new XTypedList<CVParamType>(this, LinqToXsdTypeManager.Instance, cvParamXName);
                }
                return this.cvParamField;
            }
            set {
                if ((value == null)) {
                    this.cvParamField = null;
                }
                else {
                    if ((this.cvParamField == null)) {
                        this.cvParamField = XTypedList<CVParamType>.Initialize(this, LinqToXsdTypeManager.Instance, value, cvParamXName);
                    }
                    else {
                        XTypedServices.SetList<CVParamType>(this.cvParamField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Setter: Appends
        /// </para>
        /// <para>
        /// Regular expression: ((cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<UserParamType> userParam {
            get {
                if ((this.userParamField == null)) {
                    this.userParamField = new XTypedList<UserParamType>(this, LinqToXsdTypeManager.Instance, userParamXName);
                }
                return this.userParamField;
            }
            set {
                if ((value == null)) {
                    this.userParamField = null;
                }
                else {
                    if ((this.userParamField == null)) {
                        this.userParamField = XTypedList<UserParamType>.Initialize(this, LinqToXsdTypeManager.Instance, value, userParamXName);
                    }
                    else {
                        XTypedServices.SetList<UserParamType>(this.userParamField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Reference to one of the proteins within the ProteinList.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual string protein_ref {
            get {
                XAttribute x = this.Attribute(protein_refXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
            set {
                this.SetAttribute(protein_refXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<ProteinRefType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(cvParamXName, typeof(CVParamType));
            localElementDictionary.Add(userParamXName, typeof(UserParamType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    /// <summary>
    /// <para>
    /// One protein that has been quantified in the file, including references to peptides on which the quantification is based.
    /// </para>
    /// <para>
    /// Regular expression: (IdentificationRef*, PeptideConsensus_refs?, (cvParam | userParam)*)
    /// </para>
    /// </summary>
    public partial class ProteinType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName IdentificationRefXName = System.Xml.Linq.XName.Get("IdentificationRef", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<IdentificationRefType> IdentificationRefField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName PeptideConsensus_refsXName = System.Xml.Linq.XName.Get("PeptideConsensus_refs", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName cvParamXName = System.Xml.Linq.XName.Get("cvParam", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<CVParamType> cvParamField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName userParamXName = System.Xml.Linq.XName.Get("userParam", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<UserParamType> userParamField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName idXName = System.Xml.Linq.XName.Get("id", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName accessionXName = System.Xml.Linq.XName.Get("accession", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName searchDatabase_refXName = System.Xml.Linq.XName.Get("searchDatabase_ref", "");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("ProteinType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator ProteinType(XElement xe) { return XTypedServices.ToXTypedElement<ProteinType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static ProteinType() {
            BuildElementDictionary();
            contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(IdentificationRefXName), new NamedContentModelEntity(PeptideConsensus_refsXName), new ChoiceContentModelEntity(new NamedContentModelEntity(cvParamXName), new NamedContentModelEntity(userParamXName)));
        }
        
        /// <summary>
        /// <para>
        /// One protein that has been quantified in the file, including references to peptides on which the quantification is based.
        /// </para>
        /// <para>
        /// Regular expression: (IdentificationRef*, PeptideConsensus_refs?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public ProteinType() {
        }
        
        /// <summary>
        /// <para>
        /// Reference for the identification evidence for peptides from the referenced external file and unique identifier e.g. a link to an mzIdentML file and ID for the ProteinDetectionHypothesis.
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating
        /// </para>
        /// <para>
        /// Regular expression: (IdentificationRef*, PeptideConsensus_refs?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<IdentificationRefType> IdentificationRef {
            get {
                if ((this.IdentificationRefField == null)) {
                    this.IdentificationRefField = new XTypedList<IdentificationRefType>(this, LinqToXsdTypeManager.Instance, IdentificationRefXName);
                }
                return this.IdentificationRefField;
            }
            set {
                if ((value == null)) {
                    this.IdentificationRefField = null;
                }
                else {
                    if ((this.IdentificationRefField == null)) {
                        this.IdentificationRefField = XTypedList<IdentificationRefType>.Initialize(this, LinqToXsdTypeManager.Instance, value, IdentificationRefXName);
                    }
                    else {
                        XTypedServices.SetList<IdentificationRefType>(this.IdentificationRefField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// The peptides on which the quantitative protein values in the QuantLayer(s) are based. Note this should not be used to report all peptides that can support the protein identification, only quantitation.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// <para>
        /// Regular expression: (IdentificationRef*, PeptideConsensus_refs?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<string> PeptideConsensus_refs {
            get {
                XElement x = this.GetElement(PeptideConsensus_refsXName);
                return XTypedServices.ParseListValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
            set {
                this.SetListElement(PeptideConsensus_refsXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Setter: Appends
        /// </para>
        /// <para>
        /// Regular expression: (IdentificationRef*, PeptideConsensus_refs?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<CVParamType> cvParam {
            get {
                if ((this.cvParamField == null)) {
                    this.cvParamField = new XTypedList<CVParamType>(this, LinqToXsdTypeManager.Instance, cvParamXName);
                }
                return this.cvParamField;
            }
            set {
                if ((value == null)) {
                    this.cvParamField = null;
                }
                else {
                    if ((this.cvParamField == null)) {
                        this.cvParamField = XTypedList<CVParamType>.Initialize(this, LinqToXsdTypeManager.Instance, value, cvParamXName);
                    }
                    else {
                        XTypedServices.SetList<CVParamType>(this.cvParamField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Setter: Appends
        /// </para>
        /// <para>
        /// Regular expression: (IdentificationRef*, PeptideConsensus_refs?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<UserParamType> userParam {
            get {
                if ((this.userParamField == null)) {
                    this.userParamField = new XTypedList<UserParamType>(this, LinqToXsdTypeManager.Instance, userParamXName);
                }
                return this.userParamField;
            }
            set {
                if ((value == null)) {
                    this.userParamField = null;
                }
                else {
                    if ((this.userParamField == null)) {
                        this.userParamField = XTypedList<UserParamType>.Initialize(this, LinqToXsdTypeManager.Instance, value, userParamXName);
                    }
                    else {
                        XTypedServices.SetList<UserParamType>(this.userParamField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// The unique identifier for the object within the file.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual string id {
            get {
                XAttribute x = this.Attribute(idXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Id).Datatype);
            }
            set {
                this.SetAttribute(idXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Id).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The accession of the protein in the source database. In most use cases it is expected that accession will be unique within the ProteinList, although in rare cases there may be different entries for the same protein for example if quantifying different PTMs on the same protein.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual string accession {
            get {
                XAttribute x = this.Attribute(accessionXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(accessionXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The search database from which this protein was identified
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual string searchDatabase_ref {
            get {
                XAttribute x = this.Attribute(searchDatabase_refXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
            set {
                this.SetAttribute(searchDatabase_refXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<ProteinType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(IdentificationRefXName, typeof(IdentificationRefType));
            localElementDictionary.Add(PeptideConsensus_refsXName, typeof(string));
            localElementDictionary.Add(cvParamXName, typeof(CVParamType));
            localElementDictionary.Add(userParamXName, typeof(UserParamType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    /// <summary>
    /// <para>
    /// A reference to an external identification file defined in the document, plus a unique identifier for the object in that file, such as an ID of a SpectrumIdentificationItem, ProteinDetectionHypothesis or ProteinAmbiguityGroup in mzIdentML. 
    /// </para>
    /// </summary>
    public partial class IdentificationRefType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName id_refsXName = System.Xml.Linq.XName.Get("id_refs", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName identificationFile_refXName = System.Xml.Linq.XName.Get("identificationFile_ref", "");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("IdentificationRefType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
		public static explicit operator IdentificationRefType(XElement xe) { return XTypedServices.ToXTypedElement<IdentificationRefType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        /// <summary>
        /// <para>
        /// A reference to an external identification file defined in the document, plus a unique identifier for the object in that file, such as an ID of a SpectrumIdentificationItem, ProteinDetectionHypothesis or ProteinAmbiguityGroup in mzIdentML. 
        /// </para>
        /// </summary>
        public IdentificationRefType() {
        }
        
        /// <summary>
        /// <para>
        /// One or more reference to the unique identifiers for objects identifying the relevant Peptide, Protein or Protein group in an external file.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual IList<string> id_refs {
            get {
                XAttribute x = this.Attribute(id_refsXName);
                return XTypedServices.ParseListValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetListAttribute(id_refsXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// Reference to the IdentificationFile object in this file.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual string identificationFile_ref {
            get {
                XAttribute x = this.Attribute(identificationFile_refXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
            set {
                this.SetAttribute(identificationFile_refXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<IdentificationRefType>(this);
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
    }
    
    /// <summary>
    /// <para>
    /// Evidence associated with the PeptideConsensus, including mandatory associations to features and optional references to identifications that have been assigned to the feature.
    /// </para>
    /// </summary>
    public partial class EvidenceRefType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName assay_refsXName = System.Xml.Linq.XName.Get("assay_refs", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName id_refsXName = System.Xml.Linq.XName.Get("id_refs", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName identificationFile_refXName = System.Xml.Linq.XName.Get("identificationFile_ref", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName feature_refXName = System.Xml.Linq.XName.Get("feature_ref", "");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("EvidenceRefType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
		public static explicit operator EvidenceRefType(XElement xe) { return XTypedServices.ToXTypedElement<EvidenceRefType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        /// <summary>
        /// <para>
        /// Evidence associated with the PeptideConsensus, including mandatory associations to features and optional references to identifications that have been assigned to the feature.
        /// </para>
        /// </summary>
        public EvidenceRefType() {
        }
        
        /// <summary>
        /// <para>
        /// A reference to the Assay to which the referenced Feature belongs (e.g. in label-free analyses) or has been assigned (e.g. in label-based analyses). Multiple values MUST only be given for MS2-tag approaches where the same feature quantifies multiple assays.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual IList<string> assay_refs {
            get {
                XAttribute x = this.Attribute(assay_refsXName);
                return XTypedServices.ParseListValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
            set {
                this.SetListAttribute(assay_refsXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// One or more reference to the unique identifiers for objects identifying the relevant Peptide in an external file. This attribute MUST be present if an identificationFile_ref is given.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual IList<string> id_refs {
            get {
                XAttribute x = this.Attribute(id_refsXName);
                return XTypedServices.ParseListValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetListAttribute(id_refsXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// Reference to the IdentificationFile object in this file. This attribute MUST be present if id_refs are given.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string identificationFile_ref {
            get {
                XAttribute x = this.Attribute(identificationFile_refXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
            set {
                this.SetAttribute(identificationFile_refXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The feature to which this identification has been assigned.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual string feature_ref {
            get {
                XAttribute x = this.Attribute(feature_refXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
            set {
                this.SetAttribute(feature_refXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<EvidenceRefType>(this);
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
    }
    
    /// <summary>
    /// <para>
    /// A reference to an object identified in the SearchDatabase object defined in this file.
    /// </para>
    /// </summary>
    public partial class DBIdentificationRefType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName id_refXName = System.Xml.Linq.XName.Get("id_ref", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName searchDatabase_refXName = System.Xml.Linq.XName.Get("searchDatabase_ref", "");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("DBIdentificationRefType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
		public static explicit operator DBIdentificationRefType(XElement xe) { return XTypedServices.ToXTypedElement<DBIdentificationRefType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        /// <summary>
        /// <para>
        /// A reference to an object identified in the SearchDatabase object defined in this file.
        /// </para>
        /// </summary>
        public DBIdentificationRefType() {
        }
        
        /// <summary>
        /// <para>
        /// Reference to the unique identifier of this object in the referenced external file.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual string id_ref {
            get {
                XAttribute x = this.Attribute(id_refXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(id_refXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// Reference to the SearchDatabase object in this file from which this identification was made.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual string searchDatabase_ref {
            get {
                XAttribute x = this.Attribute(searchDatabase_refXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
            set {
                this.SetAttribute(searchDatabase_refXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<DBIdentificationRefType>(this);
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
    }
    
    /// <summary>
    /// <para>
    /// The list of all peptides for which quantitation values are reported.
    /// </para>
    /// <para>
    /// Regular expression: (PeptideConsensus+, GlobalQuantLayer*, AssayQuantLayer*, StudyVariableQuantLayer*, RatioQuantLayer?, (cvParam | userParam)*)
    /// </para>
    /// </summary>
    public partial class PeptideConsensusListType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName PeptideConsensusXName = System.Xml.Linq.XName.Get("PeptideConsensus", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<PeptideConsensusType> PeptideConsensusField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName GlobalQuantLayerXName = System.Xml.Linq.XName.Get("GlobalQuantLayer", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<GlobalQuantLayerType> GlobalQuantLayerField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName AssayQuantLayerXName = System.Xml.Linq.XName.Get("AssayQuantLayer", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<QuantLayerType> AssayQuantLayerField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName StudyVariableQuantLayerXName = System.Xml.Linq.XName.Get("StudyVariableQuantLayer", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<QuantLayerType> StudyVariableQuantLayerField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName RatioQuantLayerXName = System.Xml.Linq.XName.Get("RatioQuantLayer", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName cvParamXName = System.Xml.Linq.XName.Get("cvParam", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<CVParamType> cvParamField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName userParamXName = System.Xml.Linq.XName.Get("userParam", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<UserParamType> userParamField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName idXName = System.Xml.Linq.XName.Get("id", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName finalResultXName = System.Xml.Linq.XName.Get("finalResult", "");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("PeptideConsensusListType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator PeptideConsensusListType(XElement xe) { return XTypedServices.ToXTypedElement<PeptideConsensusListType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static PeptideConsensusListType() {
            BuildElementDictionary();
            contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(PeptideConsensusXName), new NamedContentModelEntity(GlobalQuantLayerXName), new NamedContentModelEntity(AssayQuantLayerXName), new NamedContentModelEntity(StudyVariableQuantLayerXName), new NamedContentModelEntity(RatioQuantLayerXName), new ChoiceContentModelEntity(new NamedContentModelEntity(cvParamXName), new NamedContentModelEntity(userParamXName)));
        }
        
        /// <summary>
        /// <para>
        /// The list of all peptides for which quantitation values are reported.
        /// </para>
        /// <para>
        /// Regular expression: (PeptideConsensus+, GlobalQuantLayer*, AssayQuantLayer*, StudyVariableQuantLayer*, RatioQuantLayer?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public PeptideConsensusListType() {
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, repeating
        /// </para>
        /// <para>
        /// Regular expression: (PeptideConsensus+, GlobalQuantLayer*, AssayQuantLayer*, StudyVariableQuantLayer*, RatioQuantLayer?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<PeptideConsensusType> PeptideConsensus {
            get {
                if ((this.PeptideConsensusField == null)) {
                    this.PeptideConsensusField = new XTypedList<PeptideConsensusType>(this, LinqToXsdTypeManager.Instance, PeptideConsensusXName);
                }
                return this.PeptideConsensusField;
            }
            set {
                if ((value == null)) {
                    this.PeptideConsensusField = null;
                }
                else {
                    if ((this.PeptideConsensusField == null)) {
                        this.PeptideConsensusField = XTypedList<PeptideConsensusType>.Initialize(this, LinqToXsdTypeManager.Instance, value, PeptideConsensusXName);
                    }
                    else {
                        XTypedServices.SetList<PeptideConsensusType>(this.PeptideConsensusField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Global values corresponding to the Peptide such as the total intensity of peptide in all assays, Anova in a quantitative peptidome experiment etc. 
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating
        /// </para>
        /// <para>
        /// Regular expression: (PeptideConsensus+, GlobalQuantLayer*, AssayQuantLayer*, StudyVariableQuantLayer*, RatioQuantLayer?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<GlobalQuantLayerType> GlobalQuantLayer {
            get {
                if ((this.GlobalQuantLayerField == null)) {
                    this.GlobalQuantLayerField = new XTypedList<GlobalQuantLayerType>(this, LinqToXsdTypeManager.Instance, GlobalQuantLayerXName);
                }
                return this.GlobalQuantLayerField;
            }
            set {
                if ((value == null)) {
                    this.GlobalQuantLayerField = null;
                }
                else {
                    if ((this.GlobalQuantLayerField == null)) {
                        this.GlobalQuantLayerField = XTypedList<GlobalQuantLayerType>.Initialize(this, LinqToXsdTypeManager.Instance, value, GlobalQuantLayerXName);
                    }
                    else {
                        XTypedServices.SetList<GlobalQuantLayerType>(this.GlobalQuantLayerField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Quant layer for reporting data values about peptides related to different assays i.e. the column index MUST refer to Assays defined in the file.  
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating
        /// </para>
        /// <para>
        /// Regular expression: (PeptideConsensus+, GlobalQuantLayer*, AssayQuantLayer*, StudyVariableQuantLayer*, RatioQuantLayer?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<QuantLayerType> AssayQuantLayer {
            get {
                if ((this.AssayQuantLayerField == null)) {
                    this.AssayQuantLayerField = new XTypedList<QuantLayerType>(this, LinqToXsdTypeManager.Instance, AssayQuantLayerXName);
                }
                return this.AssayQuantLayerField;
            }
            set {
                if ((value == null)) {
                    this.AssayQuantLayerField = null;
                }
                else {
                    if ((this.AssayQuantLayerField == null)) {
                        this.AssayQuantLayerField = XTypedList<QuantLayerType>.Initialize(this, LinqToXsdTypeManager.Instance, value, AssayQuantLayerXName);
                    }
                    else {
                        XTypedServices.SetList<QuantLayerType>(this.AssayQuantLayerField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Quant layer for reporting data values about peptides related to different study variables i.e. the column index MUST refer to StudyVariables defined in the file. 
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating
        /// </para>
        /// <para>
        /// Regular expression: (PeptideConsensus+, GlobalQuantLayer*, AssayQuantLayer*, StudyVariableQuantLayer*, RatioQuantLayer?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<QuantLayerType> StudyVariableQuantLayer {
            get {
                if ((this.StudyVariableQuantLayerField == null)) {
                    this.StudyVariableQuantLayerField = new XTypedList<QuantLayerType>(this, LinqToXsdTypeManager.Instance, StudyVariableQuantLayerXName);
                }
                return this.StudyVariableQuantLayerField;
            }
            set {
                if ((value == null)) {
                    this.StudyVariableQuantLayerField = null;
                }
                else {
                    if ((this.StudyVariableQuantLayerField == null)) {
                        this.StudyVariableQuantLayerField = XTypedList<QuantLayerType>.Initialize(this, LinqToXsdTypeManager.Instance, value, StudyVariableQuantLayerXName);
                    }
                    else {
                        XTypedServices.SetList<QuantLayerType>(this.StudyVariableQuantLayerField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Quant layer for reporting data values about peptides related to different ratios i.e. the column index MUST refer to Ratio elements defined in the file.  
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// <para>
        /// Regular expression: (PeptideConsensus+, GlobalQuantLayer*, AssayQuantLayer*, StudyVariableQuantLayer*, RatioQuantLayer?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual RatioQuantLayerType RatioQuantLayer {
            get {
                XElement x = this.GetElement(RatioQuantLayerXName);
                return ((RatioQuantLayerType)(x));
            }
            set {
                this.SetElement(RatioQuantLayerXName, value);
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Setter: Appends
        /// </para>
        /// <para>
        /// Regular expression: (PeptideConsensus+, GlobalQuantLayer*, AssayQuantLayer*, StudyVariableQuantLayer*, RatioQuantLayer?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<CVParamType> cvParam {
            get {
                if ((this.cvParamField == null)) {
                    this.cvParamField = new XTypedList<CVParamType>(this, LinqToXsdTypeManager.Instance, cvParamXName);
                }
                return this.cvParamField;
            }
            set {
                if ((value == null)) {
                    this.cvParamField = null;
                }
                else {
                    if ((this.cvParamField == null)) {
                        this.cvParamField = XTypedList<CVParamType>.Initialize(this, LinqToXsdTypeManager.Instance, value, cvParamXName);
                    }
                    else {
                        XTypedServices.SetList<CVParamType>(this.cvParamField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Setter: Appends
        /// </para>
        /// <para>
        /// Regular expression: (PeptideConsensus+, GlobalQuantLayer*, AssayQuantLayer*, StudyVariableQuantLayer*, RatioQuantLayer?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<UserParamType> userParam {
            get {
                if ((this.userParamField == null)) {
                    this.userParamField = new XTypedList<UserParamType>(this, LinqToXsdTypeManager.Instance, userParamXName);
                }
                return this.userParamField;
            }
            set {
                if ((value == null)) {
                    this.userParamField = null;
                }
                else {
                    if ((this.userParamField == null)) {
                        this.userParamField = XTypedList<UserParamType>.Initialize(this, LinqToXsdTypeManager.Instance, value, userParamXName);
                    }
                    else {
                        XTypedServices.SetList<UserParamType>(this.userParamField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// The unique identifier for the object within the file.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual string id {
            get {
                XAttribute x = this.Attribute(idXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Id).Datatype);
            }
            set {
                this.SetAttribute(idXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Id).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// Multiple peptide lists are allowed for reporting the evidence trail to create a final peptide list, but the final result e.g. to be loaded into a database, MUST be flagged with finalResult=true
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual bool finalResult {
            get {
                XAttribute x = this.Attribute(finalResultXName);
                return XTypedServices.ParseValue<bool>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Boolean).Datatype);
            }
            set {
                this.SetAttribute(finalResultXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Boolean).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<PeptideConsensusListType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(PeptideConsensusXName, typeof(PeptideConsensusType));
            localElementDictionary.Add(GlobalQuantLayerXName, typeof(GlobalQuantLayerType));
            localElementDictionary.Add(AssayQuantLayerXName, typeof(QuantLayerType));
            localElementDictionary.Add(StudyVariableQuantLayerXName, typeof(QuantLayerType));
            localElementDictionary.Add(RatioQuantLayerXName, typeof(RatioQuantLayerType));
            localElementDictionary.Add(cvParamXName, typeof(CVParamType));
            localElementDictionary.Add(userParamXName, typeof(UserParamType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    /// <summary>
    /// <para>
    /// List of small molecules and associated data values.
    /// </para>
    /// <para>
    /// Regular expression: (SmallMolecule+, GlobalQuantLayer*, AssayQuantLayer*, StudyVariableQuantLayer*, RatioQuantLayer?, (cvParam | userParam)*)
    /// </para>
    /// </summary>
    public partial class SmallMoleculeListType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName SmallMoleculeXName = System.Xml.Linq.XName.Get("SmallMolecule", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<SmallMoleculeType> SmallMoleculeField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName GlobalQuantLayerXName = System.Xml.Linq.XName.Get("GlobalQuantLayer", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<GlobalQuantLayerType> GlobalQuantLayerField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName AssayQuantLayerXName = System.Xml.Linq.XName.Get("AssayQuantLayer", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<QuantLayerType> AssayQuantLayerField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName StudyVariableQuantLayerXName = System.Xml.Linq.XName.Get("StudyVariableQuantLayer", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<QuantLayerType> StudyVariableQuantLayerField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName RatioQuantLayerXName = System.Xml.Linq.XName.Get("RatioQuantLayer", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName cvParamXName = System.Xml.Linq.XName.Get("cvParam", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<CVParamType> cvParamField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName userParamXName = System.Xml.Linq.XName.Get("userParam", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<UserParamType> userParamField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName idXName = System.Xml.Linq.XName.Get("id", "");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("SmallMoleculeListType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator SmallMoleculeListType(XElement xe) { return XTypedServices.ToXTypedElement<SmallMoleculeListType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static SmallMoleculeListType() {
            BuildElementDictionary();
            contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(SmallMoleculeXName), new NamedContentModelEntity(GlobalQuantLayerXName), new NamedContentModelEntity(AssayQuantLayerXName), new NamedContentModelEntity(StudyVariableQuantLayerXName), new NamedContentModelEntity(RatioQuantLayerXName), new ChoiceContentModelEntity(new NamedContentModelEntity(cvParamXName), new NamedContentModelEntity(userParamXName)));
        }
        
        /// <summary>
        /// <para>
        /// List of small molecules and associated data values.
        /// </para>
        /// <para>
        /// Regular expression: (SmallMolecule+, GlobalQuantLayer*, AssayQuantLayer*, StudyVariableQuantLayer*, RatioQuantLayer?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public SmallMoleculeListType() {
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, repeating
        /// </para>
        /// <para>
        /// Regular expression: (SmallMolecule+, GlobalQuantLayer*, AssayQuantLayer*, StudyVariableQuantLayer*, RatioQuantLayer?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<SmallMoleculeType> SmallMolecule {
            get {
                if ((this.SmallMoleculeField == null)) {
                    this.SmallMoleculeField = new XTypedList<SmallMoleculeType>(this, LinqToXsdTypeManager.Instance, SmallMoleculeXName);
                }
                return this.SmallMoleculeField;
            }
            set {
                if ((value == null)) {
                    this.SmallMoleculeField = null;
                }
                else {
                    if ((this.SmallMoleculeField == null)) {
                        this.SmallMoleculeField = XTypedList<SmallMoleculeType>.Initialize(this, LinqToXsdTypeManager.Instance, value, SmallMoleculeXName);
                    }
                    else {
                        XTypedServices.SetList<SmallMoleculeType>(this.SmallMoleculeField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Global values corresponding to the small molecule such as the total intensity of the molecule in all assays, Anova etc. 
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating
        /// </para>
        /// <para>
        /// Regular expression: (SmallMolecule+, GlobalQuantLayer*, AssayQuantLayer*, StudyVariableQuantLayer*, RatioQuantLayer?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<GlobalQuantLayerType> GlobalQuantLayer {
            get {
                if ((this.GlobalQuantLayerField == null)) {
                    this.GlobalQuantLayerField = new XTypedList<GlobalQuantLayerType>(this, LinqToXsdTypeManager.Instance, GlobalQuantLayerXName);
                }
                return this.GlobalQuantLayerField;
            }
            set {
                if ((value == null)) {
                    this.GlobalQuantLayerField = null;
                }
                else {
                    if ((this.GlobalQuantLayerField == null)) {
                        this.GlobalQuantLayerField = XTypedList<GlobalQuantLayerType>.Initialize(this, LinqToXsdTypeManager.Instance, value, GlobalQuantLayerXName);
                    }
                    else {
                        XTypedServices.SetList<GlobalQuantLayerType>(this.GlobalQuantLayerField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Quant layer for reporting data values about small molecules related to different assays i.e. the column index MUST refer to Assays defined in the file.
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating
        /// </para>
        /// <para>
        /// Regular expression: (SmallMolecule+, GlobalQuantLayer*, AssayQuantLayer*, StudyVariableQuantLayer*, RatioQuantLayer?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<QuantLayerType> AssayQuantLayer {
            get {
                if ((this.AssayQuantLayerField == null)) {
                    this.AssayQuantLayerField = new XTypedList<QuantLayerType>(this, LinqToXsdTypeManager.Instance, AssayQuantLayerXName);
                }
                return this.AssayQuantLayerField;
            }
            set {
                if ((value == null)) {
                    this.AssayQuantLayerField = null;
                }
                else {
                    if ((this.AssayQuantLayerField == null)) {
                        this.AssayQuantLayerField = XTypedList<QuantLayerType>.Initialize(this, LinqToXsdTypeManager.Instance, value, AssayQuantLayerXName);
                    }
                    else {
                        XTypedServices.SetList<QuantLayerType>(this.AssayQuantLayerField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Quant layer for reporting data values about small molecules related to different study variables i.e. the column index MUST refer to StudyVariables defined in the file. 
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating
        /// </para>
        /// <para>
        /// Regular expression: (SmallMolecule+, GlobalQuantLayer*, AssayQuantLayer*, StudyVariableQuantLayer*, RatioQuantLayer?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<QuantLayerType> StudyVariableQuantLayer {
            get {
                if ((this.StudyVariableQuantLayerField == null)) {
                    this.StudyVariableQuantLayerField = new XTypedList<QuantLayerType>(this, LinqToXsdTypeManager.Instance, StudyVariableQuantLayerXName);
                }
                return this.StudyVariableQuantLayerField;
            }
            set {
                if ((value == null)) {
                    this.StudyVariableQuantLayerField = null;
                }
                else {
                    if ((this.StudyVariableQuantLayerField == null)) {
                        this.StudyVariableQuantLayerField = XTypedList<QuantLayerType>.Initialize(this, LinqToXsdTypeManager.Instance, value, StudyVariableQuantLayerXName);
                    }
                    else {
                        XTypedServices.SetList<QuantLayerType>(this.StudyVariableQuantLayerField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Quant layer for reporting data values about small molecules related to different ratios i.e. the column index MUST refer to Ratio elements defined in the file. 
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// <para>
        /// Regular expression: (SmallMolecule+, GlobalQuantLayer*, AssayQuantLayer*, StudyVariableQuantLayer*, RatioQuantLayer?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual RatioQuantLayerType RatioQuantLayer {
            get {
                XElement x = this.GetElement(RatioQuantLayerXName);
                return ((RatioQuantLayerType)(x));
            }
            set {
                this.SetElement(RatioQuantLayerXName, value);
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Setter: Appends
        /// </para>
        /// <para>
        /// Regular expression: (SmallMolecule+, GlobalQuantLayer*, AssayQuantLayer*, StudyVariableQuantLayer*, RatioQuantLayer?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<CVParamType> cvParam {
            get {
                if ((this.cvParamField == null)) {
                    this.cvParamField = new XTypedList<CVParamType>(this, LinqToXsdTypeManager.Instance, cvParamXName);
                }
                return this.cvParamField;
            }
            set {
                if ((value == null)) {
                    this.cvParamField = null;
                }
                else {
                    if ((this.cvParamField == null)) {
                        this.cvParamField = XTypedList<CVParamType>.Initialize(this, LinqToXsdTypeManager.Instance, value, cvParamXName);
                    }
                    else {
                        XTypedServices.SetList<CVParamType>(this.cvParamField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Setter: Appends
        /// </para>
        /// <para>
        /// Regular expression: (SmallMolecule+, GlobalQuantLayer*, AssayQuantLayer*, StudyVariableQuantLayer*, RatioQuantLayer?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<UserParamType> userParam {
            get {
                if ((this.userParamField == null)) {
                    this.userParamField = new XTypedList<UserParamType>(this, LinqToXsdTypeManager.Instance, userParamXName);
                }
                return this.userParamField;
            }
            set {
                if ((value == null)) {
                    this.userParamField = null;
                }
                else {
                    if ((this.userParamField == null)) {
                        this.userParamField = XTypedList<UserParamType>.Initialize(this, LinqToXsdTypeManager.Instance, value, userParamXName);
                    }
                    else {
                        XTypedServices.SetList<UserParamType>(this.userParamField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// The unique identifier for the object within the file.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual string id {
            get {
                XAttribute x = this.Attribute(idXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Id).Datatype);
            }
            set {
                this.SetAttribute(idXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Id).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<SmallMoleculeListType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(SmallMoleculeXName, typeof(SmallMoleculeType));
            localElementDictionary.Add(GlobalQuantLayerXName, typeof(GlobalQuantLayerType));
            localElementDictionary.Add(AssayQuantLayerXName, typeof(QuantLayerType));
            localElementDictionary.Add(StudyVariableQuantLayerXName, typeof(QuantLayerType));
            localElementDictionary.Add(RatioQuantLayerXName, typeof(RatioQuantLayerType));
            localElementDictionary.Add(cvParamXName, typeof(CVParamType));
            localElementDictionary.Add(userParamXName, typeof(UserParamType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    /// <summary>
    /// <para>
    /// An element representing a peptide in different assays that may or may not have been identified. If it has been identified, the sequence and modification(s) SHOULD be reported. Within the parent list, it is allowed for there to be multiple instances of the same peptide sequence, for example capturing different charge states or different modifications, if they are differentially quantified. If peptides with different charge states are aggregated, they should be represented by a single PeptideConsensus element.  
    /// </para>
    /// <para>
    /// Regular expression: (PeptideSequence?, Modification*, EvidenceRef+, (cvParam | userParam)*)
    /// </para>
    /// </summary>
    public partial class PeptideConsensusType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName PeptideSequenceXName = System.Xml.Linq.XName.Get("PeptideSequence", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName ModificationXName = System.Xml.Linq.XName.Get("Modification", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<ModificationType> ModificationField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName EvidenceRefXName = System.Xml.Linq.XName.Get("EvidenceRef", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<EvidenceRefType> EvidenceRefField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName cvParamXName = System.Xml.Linq.XName.Get("cvParam", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<CVParamType> cvParamField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName userParamXName = System.Xml.Linq.XName.Get("userParam", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<UserParamType> userParamField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName idXName = System.Xml.Linq.XName.Get("id", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName chargeXName = System.Xml.Linq.XName.Get("charge", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName searchDatabase_refXName = System.Xml.Linq.XName.Get("searchDatabase_ref", "");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("PeptideConsensusType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator PeptideConsensusType(XElement xe) { return XTypedServices.ToXTypedElement<PeptideConsensusType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static PeptideConsensusType() {
            BuildElementDictionary();
            contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(PeptideSequenceXName), new NamedContentModelEntity(ModificationXName), new NamedContentModelEntity(EvidenceRefXName), new ChoiceContentModelEntity(new NamedContentModelEntity(cvParamXName), new NamedContentModelEntity(userParamXName)));
        }
        
        /// <summary>
        /// <para>
        /// An element representing a peptide in different assays that may or may not have been identified. If it has been identified, the sequence and modification(s) SHOULD be reported. Within the parent list, it is allowed for there to be multiple instances of the same peptide sequence, for example capturing different charge states or different modifications, if they are differentially quantified. If peptides with different charge states are aggregated, they should be represented by a single PeptideConsensus element.  
        /// </para>
        /// <para>
        /// Regular expression: (PeptideSequence?, Modification*, EvidenceRef+, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public PeptideConsensusType() {
        }
        
        /// <summary>
        /// <para>
        ///  The amino acid sequence of the (poly)peptide. If a substitution modification has been found, the original sequence should be reported. The peptide sequence is mandatory unless this is a PeptideConsensus that has not been assigned to a peptide sequence. 
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// <para>
        /// Regular expression: (PeptideSequence?, Modification*, EvidenceRef+, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual string PeptideSequence {
            get {
                XElement x = this.GetElement(PeptideSequenceXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                if (value == null) {
                    this.SetElement(PeptideSequenceXName, null, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
                else {
                    this.SetElementWithValidation(PeptideSequenceXName, value, "PeptideSequence", global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.sequence.TypeDefinition);
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional, repeating
        /// </para>
        /// <para>
        /// Regular expression: (PeptideSequence?, Modification*, EvidenceRef+, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<ModificationType> Modification {
            get {
                if ((this.ModificationField == null)) {
                    this.ModificationField = new XTypedList<ModificationType>(this, LinqToXsdTypeManager.Instance, ModificationXName);
                }
                return this.ModificationField;
            }
            set {
                if ((value == null)) {
                    this.ModificationField = null;
                }
                else {
                    if ((this.ModificationField == null)) {
                        this.ModificationField = XTypedList<ModificationType>.Initialize(this, LinqToXsdTypeManager.Instance, value, ModificationXName);
                    }
                    else {
                        XTypedServices.SetList<ModificationType>(this.ModificationField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, repeating
        /// </para>
        /// <para>
        /// Regular expression: (PeptideSequence?, Modification*, EvidenceRef+, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<EvidenceRefType> EvidenceRef {
            get {
                if ((this.EvidenceRefField == null)) {
                    this.EvidenceRefField = new XTypedList<EvidenceRefType>(this, LinqToXsdTypeManager.Instance, EvidenceRefXName);
                }
                return this.EvidenceRefField;
            }
            set {
                if ((value == null)) {
                    this.EvidenceRefField = null;
                }
                else {
                    if ((this.EvidenceRefField == null)) {
                        this.EvidenceRefField = XTypedList<EvidenceRefType>.Initialize(this, LinqToXsdTypeManager.Instance, value, EvidenceRefXName);
                    }
                    else {
                        XTypedServices.SetList<EvidenceRefType>(this.EvidenceRefField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Setter: Appends
        /// </para>
        /// <para>
        /// Regular expression: (PeptideSequence?, Modification*, EvidenceRef+, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<CVParamType> cvParam {
            get {
                if ((this.cvParamField == null)) {
                    this.cvParamField = new XTypedList<CVParamType>(this, LinqToXsdTypeManager.Instance, cvParamXName);
                }
                return this.cvParamField;
            }
            set {
                if ((value == null)) {
                    this.cvParamField = null;
                }
                else {
                    if ((this.cvParamField == null)) {
                        this.cvParamField = XTypedList<CVParamType>.Initialize(this, LinqToXsdTypeManager.Instance, value, cvParamXName);
                    }
                    else {
                        XTypedServices.SetList<CVParamType>(this.cvParamField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Setter: Appends
        /// </para>
        /// <para>
        /// Regular expression: (PeptideSequence?, Modification*, EvidenceRef+, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<UserParamType> userParam {
            get {
                if ((this.userParamField == null)) {
                    this.userParamField = new XTypedList<UserParamType>(this, LinqToXsdTypeManager.Instance, userParamXName);
                }
                return this.userParamField;
            }
            set {
                if ((value == null)) {
                    this.userParamField = null;
                }
                else {
                    if ((this.userParamField == null)) {
                        this.userParamField = XTypedList<UserParamType>.Initialize(this, LinqToXsdTypeManager.Instance, value, userParamXName);
                    }
                    else {
                        XTypedServices.SetList<UserParamType>(this.userParamField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// The unique identifier for the object within the file.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual string id {
            get {
                XAttribute x = this.Attribute(idXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Id).Datatype);
            }
            set {
                this.SetAttribute(idXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Id).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The charge of this instance of Peptide. If more than one value is provided, it is assumed that this Peptide element is summarising multiple charge states of the Peptide. 
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual IList<object> charge {
            get {
                XAttribute x = this.Attribute(chargeXName);
                return XTypedServices.ParseListValue<object>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.AnyAtomicType).Datatype);
            }
            set {
                this.SetListAttribute(chargeXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.AnyAtomicType).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The search database from which this peptide was identified
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string searchDatabase_ref {
            get {
                XAttribute x = this.Attribute(searchDatabase_refXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
            set {
                this.SetAttribute(searchDatabase_refXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<PeptideConsensusType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(PeptideSequenceXName, typeof(string));
            localElementDictionary.Add(ModificationXName, typeof(ModificationType));
            localElementDictionary.Add(EvidenceRefXName, typeof(EvidenceRefType));
            localElementDictionary.Add(cvParamXName, typeof(CVParamType));
            localElementDictionary.Add(userParamXName, typeof(UserParamType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    /// <summary>
    /// <para>
    /// An element to represent a unique identifier of a small molecule for which quantitative values are reported.
    /// </para>
    /// <para>
    /// Regular expression: (Modification*, DBIdentificationRef*, Feature_refs?, (cvParam | userParam)*)
    /// </para>
    /// </summary>
    public partial class SmallMoleculeType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName ModificationXName = System.Xml.Linq.XName.Get("Modification", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<SmallMolModificationType> ModificationField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName DBIdentificationRefXName = System.Xml.Linq.XName.Get("DBIdentificationRef", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<DBIdentificationRefType> DBIdentificationRefField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName Feature_refsXName = System.Xml.Linq.XName.Get("Feature_refs", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName cvParamXName = System.Xml.Linq.XName.Get("cvParam", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<CVParamType> cvParamField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName userParamXName = System.Xml.Linq.XName.Get("userParam", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<UserParamType> userParamField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName idXName = System.Xml.Linq.XName.Get("id", "");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("SmallMoleculeType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator SmallMoleculeType(XElement xe) { return XTypedServices.ToXTypedElement<SmallMoleculeType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static SmallMoleculeType() {
            BuildElementDictionary();
            contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(ModificationXName), new NamedContentModelEntity(DBIdentificationRefXName), new NamedContentModelEntity(Feature_refsXName), new ChoiceContentModelEntity(new NamedContentModelEntity(cvParamXName), new NamedContentModelEntity(userParamXName)));
        }
        
        /// <summary>
        /// <para>
        /// An element to represent a unique identifier of a small molecule for which quantitative values are reported.
        /// </para>
        /// <para>
        /// Regular expression: (Modification*, DBIdentificationRef*, Feature_refs?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public SmallMoleculeType() {
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional, repeating
        /// </para>
        /// <para>
        /// Regular expression: (Modification*, DBIdentificationRef*, Feature_refs?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<SmallMolModificationType> Modification {
            get {
                if ((this.ModificationField == null)) {
                    this.ModificationField = new XTypedList<SmallMolModificationType>(this, LinqToXsdTypeManager.Instance, ModificationXName);
                }
                return this.ModificationField;
            }
            set {
                if ((value == null)) {
                    this.ModificationField = null;
                }
                else {
                    if ((this.ModificationField == null)) {
                        this.ModificationField = XTypedList<SmallMolModificationType>.Initialize(this, LinqToXsdTypeManager.Instance, value, ModificationXName);
                    }
                    else {
                        XTypedServices.SetList<SmallMolModificationType>(this.ModificationField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// External database references for the small molecule identification.
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating
        /// </para>
        /// <para>
        /// Regular expression: (Modification*, DBIdentificationRef*, Feature_refs?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<DBIdentificationRefType> DBIdentificationRef {
            get {
                if ((this.DBIdentificationRefField == null)) {
                    this.DBIdentificationRefField = new XTypedList<DBIdentificationRefType>(this, LinqToXsdTypeManager.Instance, DBIdentificationRefXName);
                }
                return this.DBIdentificationRefField;
            }
            set {
                if ((value == null)) {
                    this.DBIdentificationRefField = null;
                }
                else {
                    if ((this.DBIdentificationRefField == null)) {
                        this.DBIdentificationRefField = XTypedList<DBIdentificationRefType>.Initialize(this, LinqToXsdTypeManager.Instance, value, DBIdentificationRefXName);
                    }
                    else {
                        XTypedServices.SetList<DBIdentificationRefType>(this.DBIdentificationRefField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Optional references to features on which quantification values about the SmallMolecule in the QuantLayer were based.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// <para>
        /// Regular expression: (Modification*, DBIdentificationRef*, Feature_refs?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<string> Feature_refs {
            get {
                XElement x = this.GetElement(Feature_refsXName);
                return XTypedServices.ParseListValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
            set {
                this.SetListElement(Feature_refsXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Setter: Appends
        /// </para>
        /// <para>
        /// Regular expression: (Modification*, DBIdentificationRef*, Feature_refs?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<CVParamType> cvParam {
            get {
                if ((this.cvParamField == null)) {
                    this.cvParamField = new XTypedList<CVParamType>(this, LinqToXsdTypeManager.Instance, cvParamXName);
                }
                return this.cvParamField;
            }
            set {
                if ((value == null)) {
                    this.cvParamField = null;
                }
                else {
                    if ((this.cvParamField == null)) {
                        this.cvParamField = XTypedList<CVParamType>.Initialize(this, LinqToXsdTypeManager.Instance, value, cvParamXName);
                    }
                    else {
                        XTypedServices.SetList<CVParamType>(this.cvParamField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Setter: Appends
        /// </para>
        /// <para>
        /// Regular expression: (Modification*, DBIdentificationRef*, Feature_refs?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<UserParamType> userParam {
            get {
                if ((this.userParamField == null)) {
                    this.userParamField = new XTypedList<UserParamType>(this, LinqToXsdTypeManager.Instance, userParamXName);
                }
                return this.userParamField;
            }
            set {
                if ((value == null)) {
                    this.userParamField = null;
                }
                else {
                    if ((this.userParamField == null)) {
                        this.userParamField = XTypedList<UserParamType>.Initialize(this, LinqToXsdTypeManager.Instance, value, userParamXName);
                    }
                    else {
                        XTypedServices.SetList<UserParamType>(this.userParamField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// The unique identifier for the object within the file.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual string id {
            get {
                XAttribute x = this.Attribute(idXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Id).Datatype);
            }
            set {
                this.SetAttribute(idXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Id).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<SmallMoleculeType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(ModificationXName, typeof(SmallMolModificationType));
            localElementDictionary.Add(DBIdentificationRefXName, typeof(DBIdentificationRefType));
            localElementDictionary.Add(Feature_refsXName, typeof(string));
            localElementDictionary.Add(cvParamXName, typeof(CVParamType));
            localElementDictionary.Add(userParamXName, typeof(UserParamType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    /// <summary>
    /// <para>
    /// A molecule modification specification. If n modifications have been found on a peptide, there should be n instances of Modification. If multiple	modifications are provided as cvParams, it is assumed that the modification is ambiguous i.e. one modification or another. A cvParam must be provided with the identification of the modification sourced from a suitable CV e.g. UNIMOD. If the modification is not present in the CV (and this will be checked by the semantic validator within a given tolerance window), there is an _unknown modification_CV term that must be used instead. A neutral loss should be defined as an additional CVParam within Modification.
    /// </para>
    /// <para>
    /// Regular expression: (cvParam+)
    /// </para>
    /// </summary>
    public partial class ModificationType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName cvParamXName = System.Xml.Linq.XName.Get("cvParam", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<CVParamType> cvParamField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName locationXName = System.Xml.Linq.XName.Get("location", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName residuesXName = System.Xml.Linq.XName.Get("residues", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName avgMassDeltaXName = System.Xml.Linq.XName.Get("avgMassDelta", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName monoisotopicMassDeltaXName = System.Xml.Linq.XName.Get("monoisotopicMassDelta", "");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("ModificationType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator ModificationType(XElement xe) { return XTypedServices.ToXTypedElement<ModificationType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static ModificationType() {
            BuildElementDictionary();
            contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(cvParamXName));
        }
        
        /// <summary>
        /// <para>
        /// A molecule modification specification. If n modifications have been found on a peptide, there should be n instances of Modification. If multiple	modifications are provided as cvParams, it is assumed that the modification is ambiguous i.e. one modification or another. A cvParam must be provided with the identification of the modification sourced from a suitable CV e.g. UNIMOD. If the modification is not present in the CV (and this will be checked by the semantic validator within a given tolerance window), there is an _unknown modification_CV term that must be used instead. A neutral loss should be defined as an additional CVParam within Modification.
        /// </para>
        /// <para>
        /// Regular expression: (cvParam+)
        /// </para>
        /// </summary>
        public ModificationType() {
        }
        
        /// <summary>
        /// <para>
        /// CV terms capturing the modification, sourced from an appropriate controlled vocabulary.
        /// </para>
        /// <para>
        /// Occurrence: required, repeating
        /// </para>
        /// <para>
        /// Regular expression: (cvParam+)
        /// </para>
        /// </summary>
        public virtual IList<CVParamType> cvParam {
            get {
                if ((this.cvParamField == null)) {
                    this.cvParamField = new XTypedList<CVParamType>(this, LinqToXsdTypeManager.Instance, cvParamXName);
                }
                return this.cvParamField;
            }
            set {
                if ((value == null)) {
                    this.cvParamField = null;
                }
                else {
                    if ((this.cvParamField == null)) {
                        this.cvParamField = XTypedList<CVParamType>.Initialize(this, LinqToXsdTypeManager.Instance, value, cvParamXName);
                    }
                    else {
                        XTypedServices.SetList<CVParamType>(this.cvParamField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Location of the modification within the peptide - position in peptide sequence, counted from the N-terminus residue, starting at position 1.	Specific modifications to the N-terminus should be given the location 0. Modification to the C-terminus should be given as peptide length + 1. If the location is unknown or ambiguous, the location attribute should be omitted and CV params can be used to enumerate the options.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual System.Int32? location {
            get {
                XAttribute x = this.Attribute(locationXName);
                if ((x == null)) {
                    return null;
                }
                return XTypedServices.ParseValue<int>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Int).Datatype);
            }
            set {
                this.SetAttribute(locationXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Int).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// Specification of the residue (amino acid) on which the modification occurs. If multiple values are given, it is assumed that the exact residue modified is unknown i.e. the modification is to ONE of the residues listed. Multiple residues would usually only be specified for PMF data. For N or C terminal modifications, the residue attribute should be omitted.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual IList<string> residues {
            get {
                XAttribute x = this.Attribute(residuesXName);
                return XTypedServices.ParseListValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetListAttribute(residuesXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// Atomic mass delta considering the natural distribution of isotopes in Daltons. 
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual System.Double? avgMassDelta {
            get {
                XAttribute x = this.Attribute(avgMassDeltaXName);
                if ((x == null)) {
                    return null;
                }
                return XTypedServices.ParseValue<double>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Double).Datatype);
            }
            set {
                this.SetAttribute(avgMassDeltaXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Double).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// Atomic mass delta when assuming only the most common isotope of elements in Daltons. 
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual System.Double? monoisotopicMassDelta {
            get {
                XAttribute x = this.Attribute(monoisotopicMassDeltaXName);
                if ((x == null)) {
                    return null;
                }
                return XTypedServices.ParseValue<double>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Double).Datatype);
            }
            set {
                this.SetAttribute(monoisotopicMassDeltaXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Double).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<ModificationType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(cvParamXName, typeof(CVParamType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    /// <summary>
    /// <para>
    /// A small molecule modification specification, given by cvParams.
    /// </para>
    /// <para>
    /// Regular expression: (cvParam+)
    /// </para>
    /// </summary>
    public partial class SmallMolModificationType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName cvParamXName = System.Xml.Linq.XName.Get("cvParam", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<CVParamType> cvParamField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName avgMassDeltaXName = System.Xml.Linq.XName.Get("avgMassDelta", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName monoisotopicMassDeltaXName = System.Xml.Linq.XName.Get("monoisotopicMassDelta", "");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("SmallMolModificationType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator SmallMolModificationType(XElement xe) { return XTypedServices.ToXTypedElement<SmallMolModificationType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static SmallMolModificationType() {
            BuildElementDictionary();
            contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(cvParamXName));
        }
        
        /// <summary>
        /// <para>
        /// A small molecule modification specification, given by cvParams.
        /// </para>
        /// <para>
        /// Regular expression: (cvParam+)
        /// </para>
        /// </summary>
        public SmallMolModificationType() {
        }
        
        /// <summary>
        /// <para>
        /// CV terms capturing the modification, sourced from an appropriate controlled vocabulary.
        /// </para>
        /// <para>
        /// Occurrence: required, repeating
        /// </para>
        /// <para>
        /// Regular expression: (cvParam+)
        /// </para>
        /// </summary>
        public virtual IList<CVParamType> cvParam {
            get {
                if ((this.cvParamField == null)) {
                    this.cvParamField = new XTypedList<CVParamType>(this, LinqToXsdTypeManager.Instance, cvParamXName);
                }
                return this.cvParamField;
            }
            set {
                if ((value == null)) {
                    this.cvParamField = null;
                }
                else {
                    if ((this.cvParamField == null)) {
                        this.cvParamField = XTypedList<CVParamType>.Initialize(this, LinqToXsdTypeManager.Instance, value, cvParamXName);
                    }
                    else {
                        XTypedServices.SetList<CVParamType>(this.cvParamField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Atomic mass delta considering the natural distribution of
        ///					isotopes in Daltons. 
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual System.Double? avgMassDelta {
            get {
                XAttribute x = this.Attribute(avgMassDeltaXName);
                if ((x == null)) {
                    return null;
                }
                return XTypedServices.ParseValue<double>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Double).Datatype);
            }
            set {
                this.SetAttribute(avgMassDeltaXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Double).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// Atomic mass delta when assuming only the most common isotope of
        ///					elements in Daltons. 
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual System.Double? monoisotopicMassDelta {
            get {
                XAttribute x = this.Attribute(monoisotopicMassDeltaXName);
                if ((x == null)) {
                    return null;
                }
                return XTypedServices.ParseValue<double>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Double).Datatype);
            }
            set {
                this.SetAttribute(monoisotopicMassDeltaXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Double).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<SmallMolModificationType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(cvParamXName, typeof(CVParamType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    /// <summary>
    /// <para>
    /// A collection of data relating to the objects within the parent list type (e.g. PeptideConsensus, Protein or ProteinGroup)
    /// </para>
    /// <para>
    /// Regular expression: (DataType, ColumnIndex, DataMatrix)
    /// </para>
    /// </summary>
    public partial class QuantLayerType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName DataTypeXName = System.Xml.Linq.XName.Get("DataType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName ColumnIndexXName = System.Xml.Linq.XName.Get("ColumnIndex", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName DataMatrixXName = System.Xml.Linq.XName.Get("DataMatrix", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName idXName = System.Xml.Linq.XName.Get("id", "");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("QuantLayerType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator QuantLayerType(XElement xe) { return XTypedServices.ToXTypedElement<QuantLayerType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static QuantLayerType() {
            BuildElementDictionary();
            contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(DataTypeXName), new NamedContentModelEntity(ColumnIndexXName), new NamedContentModelEntity(DataMatrixXName));
        }
        
        /// <summary>
        /// <para>
        /// A collection of data relating to the objects within the parent list type (e.g. PeptideConsensus, Protein or ProteinGroup)
        /// </para>
        /// <para>
        /// Regular expression: (DataType, ColumnIndex, DataMatrix)
        /// </para>
        /// </summary>
        public QuantLayerType() {
        }
        
        /// <summary>
        /// <para>
        /// Type of data in the quant layer e.g. cvParam = "Intensity|RawAbundance|NormalisedAbundance|PeptideCount|ConfidenceScore|Anova|MaxFoldChange|...."
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// <para>
        /// Regular expression: (DataType, ColumnIndex, DataMatrix)
        /// </para>
        /// </summary>
        public virtual cvParamRefType DataType {
            get {
                XElement x = this.GetElement(DataTypeXName);
                return ((cvParamRefType)(x));
            }
            set {
                this.SetElement(DataTypeXName, value);
            }
        }
        
        /// <summary>
        /// <para>
        /// Space separated unique identifiers for each column of data, MUST refer to an object in the file i.e. StudyVariable or Assay, depending on the context where the QuantLayer resides.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// <para>
        /// Regular expression: (DataType, ColumnIndex, DataMatrix)
        /// </para>
        /// </summary>
        public virtual IList<string> ColumnIndex {
            get {
                XElement x = this.GetElement(ColumnIndexXName);
                return XTypedServices.ParseListValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
            set {
                this.SetListElement(ColumnIndexXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// <para>
        /// Regular expression: (DataType, ColumnIndex, DataMatrix)
        /// </para>
        /// </summary>
        public virtual DataMatrixType DataMatrix {
            get {
                XElement x = this.GetElement(DataMatrixXName);
                return ((DataMatrixType)(x));
            }
            set {
                this.SetElement(DataMatrixXName, value);
            }
        }
        
        /// <summary>
        /// <para>
        /// The unique identifier for the object within the file.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual string id {
            get {
                XAttribute x = this.Attribute(idXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Id).Datatype);
            }
            set {
                this.SetAttribute(idXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Id).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<QuantLayerType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(DataTypeXName, typeof(cvParamRefType));
            localElementDictionary.Add(ColumnIndexXName, typeof(string));
            localElementDictionary.Add(DataMatrixXName, typeof(DataMatrixType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    /// <summary>
    /// <para>
    /// A collection of data relating to the objects within the parent list type (e.g. PeptideConsensus, Protein or ProteinGroup)
    /// </para>
    /// <para>
    /// Regular expression: (ColumnIndex, DataMatrix)
    /// </para>
    /// </summary>
    public partial class RatioQuantLayerType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName ColumnIndexXName = System.Xml.Linq.XName.Get("ColumnIndex", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName DataMatrixXName = System.Xml.Linq.XName.Get("DataMatrix", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName idXName = System.Xml.Linq.XName.Get("id", "");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("RatioQuantLayerType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator RatioQuantLayerType(XElement xe) { return XTypedServices.ToXTypedElement<RatioQuantLayerType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static RatioQuantLayerType() {
            BuildElementDictionary();
            contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(ColumnIndexXName), new NamedContentModelEntity(DataMatrixXName));
        }
        
        /// <summary>
        /// <para>
        /// A collection of data relating to the objects within the parent list type (e.g. PeptideConsensus, Protein or ProteinGroup)
        /// </para>
        /// <para>
        /// Regular expression: (ColumnIndex, DataMatrix)
        /// </para>
        /// </summary>
        public RatioQuantLayerType() {
        }
        
        /// <summary>
        /// <para>
        /// Space separated unique identifiers for each column of data, MUST refer to an object in the file i.e. Ratio elements.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// <para>
        /// Regular expression: (ColumnIndex, DataMatrix)
        /// </para>
        /// </summary>
        public virtual IList<string> ColumnIndex {
            get {
                XElement x = this.GetElement(ColumnIndexXName);
                return XTypedServices.ParseListValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
            set {
                this.SetListElement(ColumnIndexXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// <para>
        /// Regular expression: (ColumnIndex, DataMatrix)
        /// </para>
        /// </summary>
        public virtual DataMatrixType DataMatrix {
            get {
                XElement x = this.GetElement(DataMatrixXName);
                return ((DataMatrixType)(x));
            }
            set {
                this.SetElement(DataMatrixXName, value);
            }
        }
        
        /// <summary>
        /// <para>
        /// The unique identifier for the object within the file.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual string id {
            get {
                XAttribute x = this.Attribute(idXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Id).Datatype);
            }
            set {
                this.SetAttribute(idXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Id).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<RatioQuantLayerType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(ColumnIndexXName, typeof(string));
            localElementDictionary.Add(DataMatrixXName, typeof(DataMatrixType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    /// <summary>
    /// <para>
    /// A QuantLayer in which different data types are allowed in each column.
    /// </para>
    /// <para>
    /// Regular expression: (ColumnDefinition, DataMatrix)
    /// </para>
    /// </summary>
    public partial class GlobalQuantLayerType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName ColumnDefinitionXName = System.Xml.Linq.XName.Get("ColumnDefinition", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName DataMatrixXName = System.Xml.Linq.XName.Get("DataMatrix", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName idXName = System.Xml.Linq.XName.Get("id", "");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("GlobalQuantLayerType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator GlobalQuantLayerType(XElement xe) { return XTypedServices.ToXTypedElement<GlobalQuantLayerType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static GlobalQuantLayerType() {
            BuildElementDictionary();
            contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(ColumnDefinitionXName), new NamedContentModelEntity(DataMatrixXName));
        }
        
        /// <summary>
        /// <para>
        /// A QuantLayer in which different data types are allowed in each column.
        /// </para>
        /// <para>
        /// Regular expression: (ColumnDefinition, DataMatrix)
        /// </para>
        /// </summary>
        public GlobalQuantLayerType() {
        }
        
        /// <summary>
        /// <para>
        /// Definition of the data types in each column.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// <para>
        /// Regular expression: (ColumnDefinition, DataMatrix)
        /// </para>
        /// </summary>
        public virtual ColumnDefinitionType ColumnDefinition {
            get {
                XElement x = this.GetElement(ColumnDefinitionXName);
                return ((ColumnDefinitionType)(x));
            }
            set {
                this.SetElement(ColumnDefinitionXName, value);
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// <para>
        /// Regular expression: (ColumnDefinition, DataMatrix)
        /// </para>
        /// </summary>
        public virtual DataMatrixType DataMatrix {
            get {
                XElement x = this.GetElement(DataMatrixXName);
                return ((DataMatrixType)(x));
            }
            set {
                this.SetElement(DataMatrixXName, value);
            }
        }
        
        /// <summary>
        /// <para>
        /// The unique identifier for the object within the file.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual string id {
            get {
                XAttribute x = this.Attribute(idXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Id).Datatype);
            }
            set {
                this.SetAttribute(idXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Id).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<GlobalQuantLayerType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(ColumnDefinitionXName, typeof(ColumnDefinitionType));
            localElementDictionary.Add(DataMatrixXName, typeof(DataMatrixType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    /// <summary>
    /// <para>
    /// The definition of all the columns of data about the features.
    /// </para>
    /// <para>
    /// Regular expression: (Column+)
    /// </para>
    /// </summary>
    public partial class ColumnDefinitionType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName ColumnXName = System.Xml.Linq.XName.Get("Column", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<ColumnType> ColumnField;
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("ColumnDefinitionType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator ColumnDefinitionType(XElement xe) { return XTypedServices.ToXTypedElement<ColumnDefinitionType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static ColumnDefinitionType() {
            BuildElementDictionary();
            contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(ColumnXName));
        }
        
        /// <summary>
        /// <para>
        /// The definition of all the columns of data about the features.
        /// </para>
        /// <para>
        /// Regular expression: (Column+)
        /// </para>
        /// </summary>
        public ColumnDefinitionType() {
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, repeating
        /// </para>
        /// <para>
        /// Regular expression: (Column+)
        /// </para>
        /// </summary>
        public virtual IList<ColumnType> Column {
            get {
                if ((this.ColumnField == null)) {
                    this.ColumnField = new XTypedList<ColumnType>(this, LinqToXsdTypeManager.Instance, ColumnXName);
                }
                return this.ColumnField;
            }
            set {
                if ((value == null)) {
                    this.ColumnField = null;
                }
                else {
                    if ((this.ColumnField == null)) {
                        this.ColumnField = XTypedList<ColumnType>.Initialize(this, LinqToXsdTypeManager.Instance, value, ColumnXName);
                    }
                    else {
                        XTypedServices.SetList<ColumnType>(this.ColumnField, value);
                    }
                }
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<ColumnDefinitionType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(ColumnXName, typeof(ColumnType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    /// <summary>
    /// <para>
    /// The datatype and index position of one column of data in the DataMatrix.
    /// </para>
    /// <para>
    /// Regular expression: (DataType)
    /// </para>
    /// </summary>
    public partial class ColumnType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName DataTypeXName = System.Xml.Linq.XName.Get("DataType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName indexXName = System.Xml.Linq.XName.Get("index", "");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("ColumnType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator ColumnType(XElement xe) { return XTypedServices.ToXTypedElement<ColumnType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static ColumnType() {
            BuildElementDictionary();
            contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(DataTypeXName));
        }
        
        /// <summary>
        /// <para>
        /// The datatype and index position of one column of data in the DataMatrix.
        /// </para>
        /// <para>
        /// Regular expression: (DataType)
        /// </para>
        /// </summary>
        public ColumnType() {
        }
        
        /// <summary>
        /// <para>
        /// Type of data in the column e.g. cvParam = "Intensity|RawAbundance|NormalisedAbundance".
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// <para>
        /// Regular expression: (DataType)
        /// </para>
        /// </summary>
        public virtual cvParamRefType DataType {
            get {
                XElement x = this.GetElement(DataTypeXName);
                return ((cvParamRefType)(x));
            }
            set {
                this.SetElement(DataTypeXName, value);
            }
        }
        
        /// <summary>
        /// <para>
        /// The column position within the data matrix - incrementing positive integers starting from zero.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual decimal index {
            get {
                XAttribute x = this.Attribute(indexXName);
                return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NonNegativeInteger).Datatype);
            }
            set {
                this.SetAttribute(indexXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NonNegativeInteger).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<ColumnType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(DataTypeXName, typeof(cvParamRefType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    /// <summary>
    /// <para>
    /// A matrix of data stored in rows and columns, as defined in the parent QuantLayer.
    /// </para>
    /// <para>
    /// Regular expression: (Row+)
    /// </para>
    /// </summary>
    public partial class DataMatrixType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName RowXName = System.Xml.Linq.XName.Get("Row", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<RowType> RowField;
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("DataMatrixType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator DataMatrixType(XElement xe) { return XTypedServices.ToXTypedElement<DataMatrixType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static DataMatrixType() {
            BuildElementDictionary();
            contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(RowXName));
        }
        
        /// <summary>
        /// <para>
        /// A matrix of data stored in rows and columns, as defined in the parent QuantLayer.
        /// </para>
        /// <para>
        /// Regular expression: (Row+)
        /// </para>
        /// </summary>
        public DataMatrixType() {
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, repeating
        /// </para>
        /// <para>
        /// Regular expression: (Row+)
        /// </para>
        /// </summary>
        public virtual IList<RowType> Row {
            get {
                if ((this.RowField == null)) {
                    this.RowField = new XTypedList<RowType>(this, LinqToXsdTypeManager.Instance, RowXName);
                }
                return this.RowField;
            }
            set {
                if ((value == null)) {
                    this.RowField = null;
                }
                else {
                    if ((this.RowField == null)) {
                        this.RowField = XTypedList<RowType>.Initialize(this, LinqToXsdTypeManager.Instance, value, RowXName);
                    }
                    else {
                        XTypedServices.SetList<RowType>(this.RowField, value);
                    }
                }
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<DataMatrixType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(RowXName, typeof(RowType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    /// <summary>
    /// <para>
    /// One row of data in a data matrix.
    /// </para>
    /// </summary>
    public partial class RowType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName TypedValueXName = System.Xml.Linq.XName.Get("TypedValue", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName object_refXName = System.Xml.Linq.XName.Get("object_ref", "");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("RowType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
		public static explicit operator RowType(XElement xe) { return XTypedServices.ToXTypedElement<RowType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        /// <summary>
        /// <para>
        /// One row of data in a data matrix.
        /// </para>
        /// </summary>
        public RowType() {
        }
        
        public virtual IList<object> TypedValue {
            get {
                XElement x = this.Untyped;
                return XTypedServices.ParseListValue<object>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.AnyAtomicType).Datatype);
            }
            set {
                this.SetListValueWithValidation(value, "TypedValue", global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.listOfDoublesOrNulls.TypeDefinition);
            }
        }
        
        /// <summary>
        /// <para>
        /// Reference to the data type represented in this row e.g. Feature, Peptide, Protein.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual string object_ref {
            get {
                XAttribute x = this.Attribute(object_refXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
            set {
                this.SetAttribute(object_refXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<RowType>(this);
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
    }
    
    /// <summary>
    /// <para>
    /// A logical grouping of assays into conditions or user-defined study variables such as wild-type versus disease or time points in a time course.
    /// </para>
    /// <para>
    /// Regular expression: ((cvParam | userParam)*, Assay_refs)
    /// </para>
    /// </summary>
    public partial class StudyVariableType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName cvParamXName = System.Xml.Linq.XName.Get("cvParam", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<CVParamType> cvParamField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName userParamXName = System.Xml.Linq.XName.Get("userParam", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<UserParamType> userParamField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName Assay_refsXName = System.Xml.Linq.XName.Get("Assay_refs", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName idXName = System.Xml.Linq.XName.Get("id", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName nameXName = System.Xml.Linq.XName.Get("name", "");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("StudyVariableType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator StudyVariableType(XElement xe) { return XTypedServices.ToXTypedElement<StudyVariableType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static StudyVariableType() {
            BuildElementDictionary();
            contentModel = new SequenceContentModelEntity(new ChoiceContentModelEntity(new NamedContentModelEntity(cvParamXName), new NamedContentModelEntity(userParamXName)), new NamedContentModelEntity(Assay_refsXName));
        }
        
        /// <summary>
        /// <para>
        /// A logical grouping of assays into conditions or user-defined study variables such as wild-type versus disease or time points in a time course.
        /// </para>
        /// <para>
        /// Regular expression: ((cvParam | userParam)*, Assay_refs)
        /// </para>
        /// </summary>
        public StudyVariableType() {
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Setter: Appends
        /// </para>
        /// <para>
        /// Regular expression: ((cvParam | userParam)*, Assay_refs)
        /// </para>
        /// </summary>
        public virtual IList<CVParamType> cvParam {
            get {
                if ((this.cvParamField == null)) {
                    this.cvParamField = new XTypedList<CVParamType>(this, LinqToXsdTypeManager.Instance, cvParamXName);
                }
                return this.cvParamField;
            }
            set {
                if ((value == null)) {
                    this.cvParamField = null;
                }
                else {
                    if ((this.cvParamField == null)) {
                        this.cvParamField = XTypedList<CVParamType>.Initialize(this, LinqToXsdTypeManager.Instance, value, cvParamXName);
                    }
                    else {
                        XTypedServices.SetList<CVParamType>(this.cvParamField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Setter: Appends
        /// </para>
        /// <para>
        /// Regular expression: ((cvParam | userParam)*, Assay_refs)
        /// </para>
        /// </summary>
        public virtual IList<UserParamType> userParam {
            get {
                if ((this.userParamField == null)) {
                    this.userParamField = new XTypedList<UserParamType>(this, LinqToXsdTypeManager.Instance, userParamXName);
                }
                return this.userParamField;
            }
            set {
                if ((value == null)) {
                    this.userParamField = null;
                }
                else {
                    if ((this.userParamField == null)) {
                        this.userParamField = XTypedList<UserParamType>.Initialize(this, LinqToXsdTypeManager.Instance, value, userParamXName);
                    }
                    else {
                        XTypedServices.SetList<UserParamType>(this.userParamField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Reference to the assays that are contained within this study variable.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// <para>
        /// Regular expression: ((cvParam | userParam)*, Assay_refs)
        /// </para>
        /// </summary>
        public virtual IList<string> Assay_refs {
            get {
                XElement x = this.GetElement(Assay_refsXName);
                return XTypedServices.ParseListValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
            set {
                this.SetListElement(Assay_refsXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The unique identifier for the object within the file.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual string id {
            get {
                XAttribute x = this.Attribute(idXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Id).Datatype);
            }
            set {
                this.SetAttribute(idXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Id).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// A human readable name for the study variable.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string name {
            get {
                XAttribute x = this.Attribute(nameXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(nameXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<StudyVariableType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(cvParamXName, typeof(CVParamType));
            localElementDictionary.Add(userParamXName, typeof(UserParamType));
            localElementDictionary.Add(Assay_refsXName, typeof(string));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    /// <summary>
    /// <para>
    /// The list of assays represented by the file, where each assay captures the concept of one sample analysed - this can be one or more raw files.
    /// </para>
    /// <para>
    /// Regular expression: (Assay+)
    /// </para>
    /// </summary>
    public partial class AssayListType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName AssayXName = System.Xml.Linq.XName.Get("Assay", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<AssayType> AssayField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName idXName = System.Xml.Linq.XName.Get("id", "");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("AssayListType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator AssayListType(XElement xe) { return XTypedServices.ToXTypedElement<AssayListType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static AssayListType() {
            BuildElementDictionary();
            contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(AssayXName));
        }
        
        /// <summary>
        /// <para>
        /// The list of assays represented by the file, where each assay captures the concept of one sample analysed - this can be one or more raw files.
        /// </para>
        /// <para>
        /// Regular expression: (Assay+)
        /// </para>
        /// </summary>
        public AssayListType() {
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, repeating
        /// </para>
        /// <para>
        /// Regular expression: (Assay+)
        /// </para>
        /// </summary>
        public virtual IList<AssayType> Assay {
            get {
                if ((this.AssayField == null)) {
                    this.AssayField = new XTypedList<AssayType>(this, LinqToXsdTypeManager.Instance, AssayXName);
                }
                return this.AssayField;
            }
            set {
                if ((value == null)) {
                    this.AssayField = null;
                }
                else {
                    if ((this.AssayField == null)) {
                        this.AssayField = XTypedList<AssayType>.Initialize(this, LinqToXsdTypeManager.Instance, value, AssayXName);
                    }
                    else {
                        XTypedServices.SetList<AssayType>(this.AssayField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// The unique identifier for the object within the file.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual string id {
            get {
                XAttribute x = this.Attribute(idXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Id).Datatype);
            }
            set {
                this.SetAttribute(idXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Id).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<AssayListType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(AssayXName, typeof(AssayType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    /// <summary>
    /// <para>
    /// Describes a single analysis of a sample (e.g. with the channel mapping in iTRAQ), which could constitute multiple raw files e.g. if pre-separation steps have occurred.
    /// </para>
    /// <para>
    /// Regular expression: (Label, IdentificationFile_refs?, (cvParam | userParam)*)
    /// </para>
    /// </summary>
    public partial class AssayType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName LabelXName = System.Xml.Linq.XName.Get("Label", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName IdentificationFile_refsXName = System.Xml.Linq.XName.Get("IdentificationFile_refs", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName cvParamXName = System.Xml.Linq.XName.Get("cvParam", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<CVParamType> cvParamField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName userParamXName = System.Xml.Linq.XName.Get("userParam", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<UserParamType> userParamField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName idXName = System.Xml.Linq.XName.Get("id", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName nameXName = System.Xml.Linq.XName.Get("name", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName rawFilesGroup_refXName = System.Xml.Linq.XName.Get("rawFilesGroup_ref", "");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("AssayType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator AssayType(XElement xe) { return XTypedServices.ToXTypedElement<AssayType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static AssayType() {
            BuildElementDictionary();
            contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(LabelXName), new NamedContentModelEntity(IdentificationFile_refsXName), new ChoiceContentModelEntity(new NamedContentModelEntity(cvParamXName), new NamedContentModelEntity(userParamXName)));
        }
        
        /// <summary>
        /// <para>
        /// Describes a single analysis of a sample (e.g. with the channel mapping in iTRAQ), which could constitute multiple raw files e.g. if pre-separation steps have occurred.
        /// </para>
        /// <para>
        /// Regular expression: (Label, IdentificationFile_refs?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public AssayType() {
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// <para>
        /// Regular expression: (Label, IdentificationFile_refs?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual LabelType Label {
            get {
                XElement x = this.GetElement(LabelXName);
                return ((LabelType)(x));
            }
            set {
                this.SetElement(LabelXName, value);
            }
        }
        
        /// <summary>
        /// <para>
        /// One or more identification files used within this assay.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// <para>
        /// Regular expression: (Label, IdentificationFile_refs?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<string> IdentificationFile_refs {
            get {
                XElement x = this.GetElement(IdentificationFile_refsXName);
                return XTypedServices.ParseListValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
            set {
                this.SetListElement(IdentificationFile_refsXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Setter: Appends
        /// </para>
        /// <para>
        /// Regular expression: (Label, IdentificationFile_refs?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<CVParamType> cvParam {
            get {
                if ((this.cvParamField == null)) {
                    this.cvParamField = new XTypedList<CVParamType>(this, LinqToXsdTypeManager.Instance, cvParamXName);
                }
                return this.cvParamField;
            }
            set {
                if ((value == null)) {
                    this.cvParamField = null;
                }
                else {
                    if ((this.cvParamField == null)) {
                        this.cvParamField = XTypedList<CVParamType>.Initialize(this, LinqToXsdTypeManager.Instance, value, cvParamXName);
                    }
                    else {
                        XTypedServices.SetList<CVParamType>(this.cvParamField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Setter: Appends
        /// </para>
        /// <para>
        /// Regular expression: (Label, IdentificationFile_refs?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<UserParamType> userParam {
            get {
                if ((this.userParamField == null)) {
                    this.userParamField = new XTypedList<UserParamType>(this, LinqToXsdTypeManager.Instance, userParamXName);
                }
                return this.userParamField;
            }
            set {
                if ((value == null)) {
                    this.userParamField = null;
                }
                else {
                    if ((this.userParamField == null)) {
                        this.userParamField = XTypedList<UserParamType>.Initialize(this, LinqToXsdTypeManager.Instance, value, userParamXName);
                    }
                    else {
                        XTypedServices.SetList<UserParamType>(this.userParamField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// The unique identifier for the object within the file.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual string id {
            get {
                XAttribute x = this.Attribute(idXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Id).Datatype);
            }
            set {
                this.SetAttribute(idXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Id).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// Human readable name for the assay.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string name {
            get {
                XAttribute x = this.Attribute(nameXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(nameXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// A reference to the RawFilesGroup that the Assay is linked to.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string rawFilesGroup_ref {
            get {
                XAttribute x = this.Attribute(rawFilesGroup_refXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
            set {
                this.SetAttribute(rawFilesGroup_refXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<AssayType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(LabelXName, typeof(LabelType));
            localElementDictionary.Add(IdentificationFile_refsXName, typeof(string));
            localElementDictionary.Add(cvParamXName, typeof(CVParamType));
            localElementDictionary.Add(userParamXName, typeof(UserParamType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    /// <summary>
    /// <para>
    /// The raw file or collection of raw files that together form one unit of analysis. This is mandatory unless raw files were not used for quantitation e.g. spectral counting. Multiple raw files should only be provided within a group if they have been used for sample pre-fractionation which are later summed together.
    /// </para>
    /// <para>
    /// Regular expression: (RawFile+, (cvParam | userParam)*)
    /// </para>
    /// </summary>
    public partial class RawFilesGroupType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName RawFileXName = System.Xml.Linq.XName.Get("RawFile", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<RawFileType> RawFileField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName cvParamXName = System.Xml.Linq.XName.Get("cvParam", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<CVParamType> cvParamField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName userParamXName = System.Xml.Linq.XName.Get("userParam", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<UserParamType> userParamField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName idXName = System.Xml.Linq.XName.Get("id", "");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("RawFilesGroupType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator RawFilesGroupType(XElement xe) { return XTypedServices.ToXTypedElement<RawFilesGroupType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static RawFilesGroupType() {
            BuildElementDictionary();
            contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(RawFileXName), new ChoiceContentModelEntity(new NamedContentModelEntity(cvParamXName), new NamedContentModelEntity(userParamXName)));
        }
        
        /// <summary>
        /// <para>
        /// The raw file or collection of raw files that together form one unit of analysis. This is mandatory unless raw files were not used for quantitation e.g. spectral counting. Multiple raw files should only be provided within a group if they have been used for sample pre-fractionation which are later summed together.
        /// </para>
        /// <para>
        /// Regular expression: (RawFile+, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public RawFilesGroupType() {
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, repeating
        /// </para>
        /// <para>
        /// Regular expression: (RawFile+, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<RawFileType> RawFile {
            get {
                if ((this.RawFileField == null)) {
                    this.RawFileField = new XTypedList<RawFileType>(this, LinqToXsdTypeManager.Instance, RawFileXName);
                }
                return this.RawFileField;
            }
            set {
                if ((value == null)) {
                    this.RawFileField = null;
                }
                else {
                    if ((this.RawFileField == null)) {
                        this.RawFileField = XTypedList<RawFileType>.Initialize(this, LinqToXsdTypeManager.Instance, value, RawFileXName);
                    }
                    else {
                        XTypedServices.SetList<RawFileType>(this.RawFileField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Setter: Appends
        /// </para>
        /// <para>
        /// Regular expression: (RawFile+, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<CVParamType> cvParam {
            get {
                if ((this.cvParamField == null)) {
                    this.cvParamField = new XTypedList<CVParamType>(this, LinqToXsdTypeManager.Instance, cvParamXName);
                }
                return this.cvParamField;
            }
            set {
                if ((value == null)) {
                    this.cvParamField = null;
                }
                else {
                    if ((this.cvParamField == null)) {
                        this.cvParamField = XTypedList<CVParamType>.Initialize(this, LinqToXsdTypeManager.Instance, value, cvParamXName);
                    }
                    else {
                        XTypedServices.SetList<CVParamType>(this.cvParamField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Setter: Appends
        /// </para>
        /// <para>
        /// Regular expression: (RawFile+, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<UserParamType> userParam {
            get {
                if ((this.userParamField == null)) {
                    this.userParamField = new XTypedList<UserParamType>(this, LinqToXsdTypeManager.Instance, userParamXName);
                }
                return this.userParamField;
            }
            set {
                if ((value == null)) {
                    this.userParamField = null;
                }
                else {
                    if ((this.userParamField == null)) {
                        this.userParamField = XTypedList<UserParamType>.Initialize(this, LinqToXsdTypeManager.Instance, value, userParamXName);
                    }
                    else {
                        XTypedServices.SetList<UserParamType>(this.userParamField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Unique identifier for the group of raw files that constitute one analysis unit.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual string id {
            get {
                XAttribute x = this.Attribute(idXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Id).Datatype);
            }
            set {
                this.SetAttribute(idXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Id).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<RawFilesGroupType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(RawFileXName, typeof(RawFileType));
            localElementDictionary.Add(cvParamXName, typeof(CVParamType));
            localElementDictionary.Add(userParamXName, typeof(UserParamType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    /// <summary>
    /// <para>
    /// A raw mass spectrometry output file that has been analysed e.g. in mzML format. The same raw file can be referenced in multiple assays, for example if it contains multiple samples differentially labelled or tagged. Note, the name raw file does not necessarily imply that the file has not been processed, since in some quant methods, processed peak list formats such as MGF or DTA can be used, which could be referenced here.
    /// </para>
    /// <para>
    /// Regular expression: (ExternalFormatDocumentation?, FileFormat?, (cvParam | userParam)*)
    /// </para>
    /// </summary>
    public partial class RawFileType : global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.ExternalDataType, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName cvParamXName = System.Xml.Linq.XName.Get("cvParam", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<CVParamType> cvParamField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName userParamXName = System.Xml.Linq.XName.Get("userParam", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<UserParamType> userParamField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName methodFile_refXName = System.Xml.Linq.XName.Get("methodFile_ref", "");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("RawFileType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator RawFileType(XElement xe) { return XTypedServices.ToXTypedElement<RawFileType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static RawFileType() {
            BuildElementDictionary();
            contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(ExternalFormatDocumentationXName), new NamedContentModelEntity(FileFormatXName), new ChoiceContentModelEntity(new NamedContentModelEntity(cvParamXName), new NamedContentModelEntity(userParamXName)));
        }
        
        /// <summary>
        /// <para>
        /// A raw mass spectrometry output file that has been analysed e.g. in mzML format. The same raw file can be referenced in multiple assays, for example if it contains multiple samples differentially labelled or tagged. Note, the name raw file does not necessarily imply that the file has not been processed, since in some quant methods, processed peak list formats such as MGF or DTA can be used, which could be referenced here.
        /// </para>
        /// <para>
        /// Regular expression: (ExternalFormatDocumentation?, FileFormat?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public RawFileType() {
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Setter: Appends
        /// </para>
        /// <para>
        /// Regular expression: (ExternalFormatDocumentation?, FileFormat?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<CVParamType> cvParam {
            get {
                if ((this.cvParamField == null)) {
                    this.cvParamField = new XTypedList<CVParamType>(this, LinqToXsdTypeManager.Instance, cvParamXName);
                }
                return this.cvParamField;
            }
            set {
                if ((value == null)) {
                    this.cvParamField = null;
                }
                else {
                    if ((this.cvParamField == null)) {
                        this.cvParamField = XTypedList<CVParamType>.Initialize(this, LinqToXsdTypeManager.Instance, value, cvParamXName);
                    }
                    else {
                        XTypedServices.SetList<CVParamType>(this.cvParamField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Setter: Appends
        /// </para>
        /// <para>
        /// Regular expression: (ExternalFormatDocumentation?, FileFormat?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<UserParamType> userParam {
            get {
                if ((this.userParamField == null)) {
                    this.userParamField = new XTypedList<UserParamType>(this, LinqToXsdTypeManager.Instance, userParamXName);
                }
                return this.userParamField;
            }
            set {
                if ((value == null)) {
                    this.userParamField = null;
                }
                else {
                    if ((this.userParamField == null)) {
                        this.userParamField = XTypedList<UserParamType>.Initialize(this, LinqToXsdTypeManager.Instance, value, userParamXName);
                    }
                    else {
                        XTypedServices.SetList<UserParamType>(this.userParamField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// An optional reference to a methods file used in association with a raw file, for example a TraML file used for SRM analysis.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string methodFile_ref {
            get {
                XAttribute x = this.Attribute(methodFile_refXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
            set {
                this.SetAttribute(methodFile_refXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<RawFileType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(ExternalFormatDocumentationXName, typeof(System.Uri));
            localElementDictionary.Add(FileFormatXName, typeof(FileFormatType));
            localElementDictionary.Add(cvParamXName, typeof(CVParamType));
            localElementDictionary.Add(userParamXName, typeof(UserParamType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    /// <summary>
    /// <para>
    /// All identification files associated with this quantitation analysis to be referenced elsewhere.
    /// </para>
    /// <para>
    /// Regular expression: (IdentificationFile+)
    /// </para>
    /// </summary>
    public partial class IdentificationFilesType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName IdentificationFileXName = System.Xml.Linq.XName.Get("IdentificationFile", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<IdentificationFileType> IdentificationFileField;
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("IdentificationFilesType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator IdentificationFilesType(XElement xe) { return XTypedServices.ToXTypedElement<IdentificationFilesType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static IdentificationFilesType() {
            BuildElementDictionary();
            contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(IdentificationFileXName));
        }
        
        /// <summary>
        /// <para>
        /// All identification files associated with this quantitation analysis to be referenced elsewhere.
        /// </para>
        /// <para>
        /// Regular expression: (IdentificationFile+)
        /// </para>
        /// </summary>
        public IdentificationFilesType() {
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, repeating
        /// </para>
        /// <para>
        /// Regular expression: (IdentificationFile+)
        /// </para>
        /// </summary>
        public virtual IList<IdentificationFileType> IdentificationFile {
            get {
                if ((this.IdentificationFileField == null)) {
                    this.IdentificationFileField = new XTypedList<IdentificationFileType>(this, LinqToXsdTypeManager.Instance, IdentificationFileXName);
                }
                return this.IdentificationFileField;
            }
            set {
                if ((value == null)) {
                    this.IdentificationFileField = null;
                }
                else {
                    if ((this.IdentificationFileField == null)) {
                        this.IdentificationFileField = XTypedList<IdentificationFileType>.Initialize(this, LinqToXsdTypeManager.Instance, value, IdentificationFileXName);
                    }
                    else {
                        XTypedServices.SetList<IdentificationFileType>(this.IdentificationFileField, value);
                    }
                }
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<IdentificationFilesType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(IdentificationFileXName, typeof(IdentificationFileType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    /// <summary>
    /// <para>
    /// A single identification file associated with this analysis.
    /// </para>
    /// <para>
    /// Regular expression: (ExternalFormatDocumentation?, FileFormat?, (cvParam | userParam)*)
    /// </para>
    /// </summary>
    public partial class IdentificationFileType : global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.ExternalDataType, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName cvParamXName = System.Xml.Linq.XName.Get("cvParam", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<CVParamType> cvParamField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName userParamXName = System.Xml.Linq.XName.Get("userParam", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<UserParamType> userParamField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName searchDatabase_refXName = System.Xml.Linq.XName.Get("searchDatabase_ref", "");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("IdentificationFileType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator IdentificationFileType(XElement xe) { return XTypedServices.ToXTypedElement<IdentificationFileType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static IdentificationFileType() {
            BuildElementDictionary();
            contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(ExternalFormatDocumentationXName), new NamedContentModelEntity(FileFormatXName), new ChoiceContentModelEntity(new NamedContentModelEntity(cvParamXName), new NamedContentModelEntity(userParamXName)));
        }
        
        /// <summary>
        /// <para>
        /// A single identification file associated with this analysis.
        /// </para>
        /// <para>
        /// Regular expression: (ExternalFormatDocumentation?, FileFormat?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public IdentificationFileType() {
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Setter: Appends
        /// </para>
        /// <para>
        /// Regular expression: (ExternalFormatDocumentation?, FileFormat?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<CVParamType> cvParam {
            get {
                if ((this.cvParamField == null)) {
                    this.cvParamField = new XTypedList<CVParamType>(this, LinqToXsdTypeManager.Instance, cvParamXName);
                }
                return this.cvParamField;
            }
            set {
                if ((value == null)) {
                    this.cvParamField = null;
                }
                else {
                    if ((this.cvParamField == null)) {
                        this.cvParamField = XTypedList<CVParamType>.Initialize(this, LinqToXsdTypeManager.Instance, value, cvParamXName);
                    }
                    else {
                        XTypedServices.SetList<CVParamType>(this.cvParamField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Setter: Appends
        /// </para>
        /// <para>
        /// Regular expression: (ExternalFormatDocumentation?, FileFormat?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<UserParamType> userParam {
            get {
                if ((this.userParamField == null)) {
                    this.userParamField = new XTypedList<UserParamType>(this, LinqToXsdTypeManager.Instance, userParamXName);
                }
                return this.userParamField;
            }
            set {
                if ((value == null)) {
                    this.userParamField = null;
                }
                else {
                    if ((this.userParamField == null)) {
                        this.userParamField = XTypedList<UserParamType>.Initialize(this, LinqToXsdTypeManager.Instance, value, userParamXName);
                    }
                    else {
                        XTypedServices.SetList<UserParamType>(this.userParamField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Reference to the SearchDatabase object in this file from which this identification was made.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string searchDatabase_ref {
            get {
                XAttribute x = this.Attribute(searchDatabase_refXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
            set {
                this.SetAttribute(searchDatabase_refXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<IdentificationFileType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(ExternalFormatDocumentationXName, typeof(System.Uri));
            localElementDictionary.Add(FileFormatXName, typeof(FileFormatType));
            localElementDictionary.Add(cvParamXName, typeof(CVParamType));
            localElementDictionary.Add(userParamXName, typeof(UserParamType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    /// <summary>
    /// <para>
    /// All methods files associated with this quantitation analysis to be referenced elsewhere, for example used to describe TraML files used in SRM analysis.
    /// </para>
    /// <para>
    /// Regular expression: (MethodFile+)
    /// </para>
    /// </summary>
    public partial class MethodFilesType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName MethodFileXName = System.Xml.Linq.XName.Get("MethodFile", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<MethodFileType> MethodFileField;
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("MethodFilesType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator MethodFilesType(XElement xe) { return XTypedServices.ToXTypedElement<MethodFilesType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static MethodFilesType() {
            BuildElementDictionary();
            contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(MethodFileXName));
        }
        
        /// <summary>
        /// <para>
        /// All methods files associated with this quantitation analysis to be referenced elsewhere, for example used to describe TraML files used in SRM analysis.
        /// </para>
        /// <para>
        /// Regular expression: (MethodFile+)
        /// </para>
        /// </summary>
        public MethodFilesType() {
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, repeating
        /// </para>
        /// <para>
        /// Regular expression: (MethodFile+)
        /// </para>
        /// </summary>
        public virtual IList<MethodFileType> MethodFile {
            get {
                if ((this.MethodFileField == null)) {
                    this.MethodFileField = new XTypedList<MethodFileType>(this, LinqToXsdTypeManager.Instance, MethodFileXName);
                }
                return this.MethodFileField;
            }
            set {
                if ((value == null)) {
                    this.MethodFileField = null;
                }
                else {
                    if ((this.MethodFileField == null)) {
                        this.MethodFileField = XTypedList<MethodFileType>.Initialize(this, LinqToXsdTypeManager.Instance, value, MethodFileXName);
                    }
                    else {
                        XTypedServices.SetList<MethodFileType>(this.MethodFileField, value);
                    }
                }
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<MethodFilesType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(MethodFileXName, typeof(MethodFileType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    /// <summary>
    /// <para>
    /// A single methods file associated with this analysis e.g. a TraML file used for SRM analysis.
    /// </para>
    /// <para>
    /// Regular expression: (ExternalFormatDocumentation?, FileFormat?)
    /// </para>
    /// </summary>
    public partial class MethodFileType : global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.ExternalDataType, IXMetaData {
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("MethodFileType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator MethodFileType(XElement xe) { return XTypedServices.ToXTypedElement<MethodFileType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static MethodFileType() {
            BuildElementDictionary();
            contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(ExternalFormatDocumentationXName), new NamedContentModelEntity(FileFormatXName));
        }
        
        /// <summary>
        /// <para>
        /// A single methods file associated with this analysis e.g. a TraML file used for SRM analysis.
        /// </para>
        /// <para>
        /// Regular expression: (ExternalFormatDocumentation?, FileFormat?)
        /// </para>
        /// </summary>
        public MethodFileType() {
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<MethodFileType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(ExternalFormatDocumentationXName, typeof(System.Uri));
            localElementDictionary.Add(FileFormatXName, typeof(FileFormatType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    /// <summary>
    /// <para>
    /// A specification of labels or tags used to define the assay within the raw file, such as heavy labelling or iTRAQ tag mass. The Label and Modification is mandatory so a specific term is provided under Modification for unlabeled sample for label-free and, for example, so-called light samples in a labelling experiment. 
    /// </para>
    /// <para>
    /// Regular expression: (Modification+)
    /// </para>
    /// </summary>
    public partial class LabelType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName ModificationXName = System.Xml.Linq.XName.Get("Modification", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<ModParamType> ModificationField;
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("LabelType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator LabelType(XElement xe) { return XTypedServices.ToXTypedElement<LabelType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static LabelType() {
            BuildElementDictionary();
            contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(ModificationXName));
        }
        
        /// <summary>
        /// <para>
        /// A specification of labels or tags used to define the assay within the raw file, such as heavy labelling or iTRAQ tag mass. The Label and Modification is mandatory so a specific term is provided under Modification for unlabeled sample for label-free and, for example, so-called light samples in a labelling experiment. 
        /// </para>
        /// <para>
        /// Regular expression: (Modification+)
        /// </para>
        /// </summary>
        public LabelType() {
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, repeating
        /// </para>
        /// <para>
        /// Regular expression: (Modification+)
        /// </para>
        /// </summary>
        public virtual IList<ModParamType> Modification {
            get {
                if ((this.ModificationField == null)) {
                    this.ModificationField = new XTypedList<ModParamType>(this, LinqToXsdTypeManager.Instance, ModificationXName);
                }
                return this.ModificationField;
            }
            set {
                if ((value == null)) {
                    this.ModificationField = null;
                }
                else {
                    if ((this.ModificationField == null)) {
                        this.ModificationField = XTypedList<ModParamType>.Initialize(this, LinqToXsdTypeManager.Instance, value, ModificationXName);
                    }
                    else {
                        XTypedServices.SetList<ModParamType>(this.ModificationField, value);
                    }
                }
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<LabelType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(ModificationXName, typeof(ModParamType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    /// <summary>
    /// <para>
    /// The setup of a ratio of study variables or assays that is referenced elsewhere in the file. It is expected that the numerator and denominator MUST both be Assays or MUST both be StudyVariables. However, StudyVariables MAY contain 1 to many Assays, thus allowing more complex ratios to be constructed if needed via use of StudyVariables with unbalanced numbers of Assays.
    /// </para>
    /// <para>
    /// Regular expression: (RatioCalculation?, NumeratorDataType, DenominatorDataType)
    /// </para>
    /// </summary>
    public partial class RatioType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName RatioCalculationXName = System.Xml.Linq.XName.Get("RatioCalculation", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName NumeratorDataTypeXName = System.Xml.Linq.XName.Get("NumeratorDataType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName DenominatorDataTypeXName = System.Xml.Linq.XName.Get("DenominatorDataType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName numerator_refXName = System.Xml.Linq.XName.Get("numerator_ref", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName denominator_refXName = System.Xml.Linq.XName.Get("denominator_ref", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName idXName = System.Xml.Linq.XName.Get("id", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName nameXName = System.Xml.Linq.XName.Get("name", "");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("RatioType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator RatioType(XElement xe) { return XTypedServices.ToXTypedElement<RatioType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static RatioType() {
            BuildElementDictionary();
            contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(RatioCalculationXName), new NamedContentModelEntity(NumeratorDataTypeXName), new NamedContentModelEntity(DenominatorDataTypeXName));
        }
        
        /// <summary>
        /// <para>
        /// The setup of a ratio of study variables or assays that is referenced elsewhere in the file. It is expected that the numerator and denominator MUST both be Assays or MUST both be StudyVariables. However, StudyVariables MAY contain 1 to many Assays, thus allowing more complex ratios to be constructed if needed via use of StudyVariables with unbalanced numbers of Assays.
        /// </para>
        /// <para>
        /// Regular expression: (RatioCalculation?, NumeratorDataType, DenominatorDataType)
        /// </para>
        /// </summary>
        public RatioType() {
        }
        
        /// <summary>
        /// <para>
        /// Information should be provided about how ratios are calculated if they differ from simple division of numerator by denominator 
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// <para>
        /// Regular expression: (RatioCalculation?, NumeratorDataType, DenominatorDataType)
        /// </para>
        /// </summary>
        public virtual ParamListType RatioCalculation {
            get {
                XElement x = this.GetElement(RatioCalculationXName);
                return ((ParamListType)(x));
            }
            set {
                this.SetElement(RatioCalculationXName, value);
            }
        }
        
        /// <summary>
        /// <para>
        /// Type of data used for the numerator of the ratio e.g. cvParam = "Intensity|RawAbundance|NormalisedAbundance|PeptideCount|ConfidenceScore|Anova|MaxFoldChange|...."
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// <para>
        /// Regular expression: (RatioCalculation?, NumeratorDataType, DenominatorDataType)
        /// </para>
        /// </summary>
        public virtual cvParamRefType NumeratorDataType {
            get {
                XElement x = this.GetElement(NumeratorDataTypeXName);
                return ((cvParamRefType)(x));
            }
            set {
                this.SetElement(NumeratorDataTypeXName, value);
            }
        }
        
        /// <summary>
        /// <para>
        /// Type of data used for the denominator of the ratio e.g. cvParam = "Intensity|RawAbundance|NormalisedAbundance|PeptideCount|ConfidenceScore|Anova|MaxFoldChange|...."
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// <para>
        /// Regular expression: (RatioCalculation?, NumeratorDataType, DenominatorDataType)
        /// </para>
        /// </summary>
        public virtual cvParamRefType DenominatorDataType {
            get {
                XElement x = this.GetElement(DenominatorDataTypeXName);
                return ((cvParamRefType)(x));
            }
            set {
                this.SetElement(DenominatorDataTypeXName, value);
            }
        }
        
        /// <summary>
        /// <para>
        /// Reference to a StudyVariable or an Assay.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual string numerator_ref {
            get {
                XAttribute x = this.Attribute(numerator_refXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
            set {
                this.SetAttribute(numerator_refXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// Reference to a StudyVariable or an Assay.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual string denominator_ref {
            get {
                XAttribute x = this.Attribute(denominator_refXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
            set {
                this.SetAttribute(denominator_refXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The unique identifier for the object within the file.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual string id {
            get {
                XAttribute x = this.Attribute(idXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Id).Datatype);
            }
            set {
                this.SetAttribute(idXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Id).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// Optional name for the ratio.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string name {
            get {
                XAttribute x = this.Attribute(nameXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(nameXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<RatioType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(RatioCalculationXName, typeof(ParamListType));
            localElementDictionary.Add(NumeratorDataTypeXName, typeof(cvParamRefType));
            localElementDictionary.Add(DenominatorDataTypeXName, typeof(cvParamRefType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    /// <summary>
    /// <para>
    /// All the features identified on a single raw file or raw file group.
    /// </para>
    /// <para>
    /// Regular expression: (Feature+, FeatureQuantLayer*, MS2AssayQuantLayer*, MS2StudyVariableQuantLayer*, MS2RatioQuantLayer?, (cvParam | userParam)*)
    /// </para>
    /// </summary>
    public partial class FeatureListType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName FeatureXName = System.Xml.Linq.XName.Get("Feature", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<FeatureType> FeatureField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName FeatureQuantLayerXName = System.Xml.Linq.XName.Get("FeatureQuantLayer", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<GlobalQuantLayerType> FeatureQuantLayerField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName MS2AssayQuantLayerXName = System.Xml.Linq.XName.Get("MS2AssayQuantLayer", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<QuantLayerType> MS2AssayQuantLayerField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName MS2StudyVariableQuantLayerXName = System.Xml.Linq.XName.Get("MS2StudyVariableQuantLayer", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<QuantLayerType> MS2StudyVariableQuantLayerField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName MS2RatioQuantLayerXName = System.Xml.Linq.XName.Get("MS2RatioQuantLayer", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName cvParamXName = System.Xml.Linq.XName.Get("cvParam", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<CVParamType> cvParamField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName userParamXName = System.Xml.Linq.XName.Get("userParam", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<UserParamType> userParamField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName rawFilesGroup_refXName = System.Xml.Linq.XName.Get("rawFilesGroup_ref", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName idXName = System.Xml.Linq.XName.Get("id", "");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("FeatureListType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator FeatureListType(XElement xe) { return XTypedServices.ToXTypedElement<FeatureListType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static FeatureListType() {
            BuildElementDictionary();
            contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(FeatureXName), new NamedContentModelEntity(FeatureQuantLayerXName), new NamedContentModelEntity(MS2AssayQuantLayerXName), new NamedContentModelEntity(MS2StudyVariableQuantLayerXName), new NamedContentModelEntity(MS2RatioQuantLayerXName), new ChoiceContentModelEntity(new NamedContentModelEntity(cvParamXName), new NamedContentModelEntity(userParamXName)));
        }
        
        /// <summary>
        /// <para>
        /// All the features identified on a single raw file or raw file group.
        /// </para>
        /// <para>
        /// Regular expression: (Feature+, FeatureQuantLayer*, MS2AssayQuantLayer*, MS2StudyVariableQuantLayer*, MS2RatioQuantLayer?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public FeatureListType() {
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, repeating
        /// </para>
        /// <para>
        /// Regular expression: (Feature+, FeatureQuantLayer*, MS2AssayQuantLayer*, MS2StudyVariableQuantLayer*, MS2RatioQuantLayer?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<FeatureType> Feature {
            get {
                if ((this.FeatureField == null)) {
                    this.FeatureField = new XTypedList<FeatureType>(this, LinqToXsdTypeManager.Instance, FeatureXName);
                }
                return this.FeatureField;
            }
            set {
                if ((value == null)) {
                    this.FeatureField = null;
                }
                else {
                    if ((this.FeatureField == null)) {
                        this.FeatureField = XTypedList<FeatureType>.Initialize(this, LinqToXsdTypeManager.Instance, value, FeatureXName);
                    }
                    else {
                        XTypedServices.SetList<FeatureType>(this.FeatureField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// All the data values about features in one raw file or raw file group, such as feature raw intensity, feature RT window size etc. 
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating
        /// </para>
        /// <para>
        /// Regular expression: (Feature+, FeatureQuantLayer*, MS2AssayQuantLayer*, MS2StudyVariableQuantLayer*, MS2RatioQuantLayer?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<GlobalQuantLayerType> FeatureQuantLayer {
            get {
                if ((this.FeatureQuantLayerField == null)) {
                    this.FeatureQuantLayerField = new XTypedList<GlobalQuantLayerType>(this, LinqToXsdTypeManager.Instance, FeatureQuantLayerXName);
                }
                return this.FeatureQuantLayerField;
            }
            set {
                if ((value == null)) {
                    this.FeatureQuantLayerField = null;
                }
                else {
                    if ((this.FeatureQuantLayerField == null)) {
                        this.FeatureQuantLayerField = XTypedList<GlobalQuantLayerType>.Initialize(this, LinqToXsdTypeManager.Instance, value, FeatureQuantLayerXName);
                    }
                    else {
                        XTypedServices.SetList<GlobalQuantLayerType>(this.FeatureQuantLayerField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Quant layer for reporting data values about MS2 features (e.g. iTRAQ) related to different assays i.e. the column index MUST refer to Assays defined in the file.
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating
        /// </para>
        /// <para>
        /// Regular expression: (Feature+, FeatureQuantLayer*, MS2AssayQuantLayer*, MS2StudyVariableQuantLayer*, MS2RatioQuantLayer?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<QuantLayerType> MS2AssayQuantLayer {
            get {
                if ((this.MS2AssayQuantLayerField == null)) {
                    this.MS2AssayQuantLayerField = new XTypedList<QuantLayerType>(this, LinqToXsdTypeManager.Instance, MS2AssayQuantLayerXName);
                }
                return this.MS2AssayQuantLayerField;
            }
            set {
                if ((value == null)) {
                    this.MS2AssayQuantLayerField = null;
                }
                else {
                    if ((this.MS2AssayQuantLayerField == null)) {
                        this.MS2AssayQuantLayerField = XTypedList<QuantLayerType>.Initialize(this, LinqToXsdTypeManager.Instance, value, MS2AssayQuantLayerXName);
                    }
                    else {
                        XTypedServices.SetList<QuantLayerType>(this.MS2AssayQuantLayerField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Quant layer for reporting data values about MS2 features (e.g. iTRAQ) related to different study variables i.e. the column index MUST refer to StudyVariables defined in the file.
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating
        /// </para>
        /// <para>
        /// Regular expression: (Feature+, FeatureQuantLayer*, MS2AssayQuantLayer*, MS2StudyVariableQuantLayer*, MS2RatioQuantLayer?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<QuantLayerType> MS2StudyVariableQuantLayer {
            get {
                if ((this.MS2StudyVariableQuantLayerField == null)) {
                    this.MS2StudyVariableQuantLayerField = new XTypedList<QuantLayerType>(this, LinqToXsdTypeManager.Instance, MS2StudyVariableQuantLayerXName);
                }
                return this.MS2StudyVariableQuantLayerField;
            }
            set {
                if ((value == null)) {
                    this.MS2StudyVariableQuantLayerField = null;
                }
                else {
                    if ((this.MS2StudyVariableQuantLayerField == null)) {
                        this.MS2StudyVariableQuantLayerField = XTypedList<QuantLayerType>.Initialize(this, LinqToXsdTypeManager.Instance, value, MS2StudyVariableQuantLayerXName);
                    }
                    else {
                        XTypedServices.SetList<QuantLayerType>(this.MS2StudyVariableQuantLayerField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Quant layer for reporting data values about MS2 features (e.g. iTRAQ) related to different ratios i.e. the column index MUST refer to Ratio elements defined in the file.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// <para>
        /// Regular expression: (Feature+, FeatureQuantLayer*, MS2AssayQuantLayer*, MS2StudyVariableQuantLayer*, MS2RatioQuantLayer?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual RatioQuantLayerType MS2RatioQuantLayer {
            get {
                XElement x = this.GetElement(MS2RatioQuantLayerXName);
                return ((RatioQuantLayerType)(x));
            }
            set {
                this.SetElement(MS2RatioQuantLayerXName, value);
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Setter: Appends
        /// </para>
        /// <para>
        /// Regular expression: (Feature+, FeatureQuantLayer*, MS2AssayQuantLayer*, MS2StudyVariableQuantLayer*, MS2RatioQuantLayer?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<CVParamType> cvParam {
            get {
                if ((this.cvParamField == null)) {
                    this.cvParamField = new XTypedList<CVParamType>(this, LinqToXsdTypeManager.Instance, cvParamXName);
                }
                return this.cvParamField;
            }
            set {
                if ((value == null)) {
                    this.cvParamField = null;
                }
                else {
                    if ((this.cvParamField == null)) {
                        this.cvParamField = XTypedList<CVParamType>.Initialize(this, LinqToXsdTypeManager.Instance, value, cvParamXName);
                    }
                    else {
                        XTypedServices.SetList<CVParamType>(this.cvParamField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Setter: Appends
        /// </para>
        /// <para>
        /// Regular expression: (Feature+, FeatureQuantLayer*, MS2AssayQuantLayer*, MS2StudyVariableQuantLayer*, MS2RatioQuantLayer?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<UserParamType> userParam {
            get {
                if ((this.userParamField == null)) {
                    this.userParamField = new XTypedList<UserParamType>(this, LinqToXsdTypeManager.Instance, userParamXName);
                }
                return this.userParamField;
            }
            set {
                if ((value == null)) {
                    this.userParamField = null;
                }
                else {
                    if ((this.userParamField == null)) {
                        this.userParamField = XTypedList<UserParamType>.Initialize(this, LinqToXsdTypeManager.Instance, value, userParamXName);
                    }
                    else {
                        XTypedServices.SetList<UserParamType>(this.userParamField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Reference to the raw file or group of raw files from which this feature list was generated.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual string rawFilesGroup_ref {
            get {
                XAttribute x = this.Attribute(rawFilesGroup_refXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
            set {
                this.SetAttribute(rawFilesGroup_refXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The unique identifier for the object within the file.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual string id {
            get {
                XAttribute x = this.Attribute(idXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Id).Datatype);
            }
            set {
                this.SetAttribute(idXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Id).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<FeatureListType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(FeatureXName, typeof(FeatureType));
            localElementDictionary.Add(FeatureQuantLayerXName, typeof(GlobalQuantLayerType));
            localElementDictionary.Add(MS2AssayQuantLayerXName, typeof(QuantLayerType));
            localElementDictionary.Add(MS2StudyVariableQuantLayerXName, typeof(QuantLayerType));
            localElementDictionary.Add(MS2RatioQuantLayerXName, typeof(RatioQuantLayerType));
            localElementDictionary.Add(cvParamXName, typeof(CVParamType));
            localElementDictionary.Add(userParamXName, typeof(UserParamType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    /// <summary>
    /// <para>
    /// A region on a (potentially) two-dimensional map of MS1 scans, defined by the retention time, mass over charge and optionally a mass trace. Quantitative values about features can be added in the associated QuantLayers. For techniques that analyse data from single scans e.g. MS2 tagging approaches, a Feature corresponds with the mz of the parent ions only.
    /// </para>
    /// <para>
    /// Regular expression: (MassTrace?, (cvParam | userParam)*)
    /// </para>
    /// </summary>
    public partial class FeatureType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName MassTraceXName = System.Xml.Linq.XName.Get("MassTrace", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName cvParamXName = System.Xml.Linq.XName.Get("cvParam", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<CVParamType> cvParamField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName userParamXName = System.Xml.Linq.XName.Get("userParam", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<UserParamType> userParamField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName idXName = System.Xml.Linq.XName.Get("id", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName rtXName = System.Xml.Linq.XName.Get("rt", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName mzXName = System.Xml.Linq.XName.Get("mz", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName chargeXName = System.Xml.Linq.XName.Get("charge", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName chromatogram_refsXName = System.Xml.Linq.XName.Get("chromatogram_refs", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName spectrum_refsXName = System.Xml.Linq.XName.Get("spectrum_refs", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName rawFile_refXName = System.Xml.Linq.XName.Get("rawFile_ref", "");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("FeatureType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator FeatureType(XElement xe) { return XTypedServices.ToXTypedElement<FeatureType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static FeatureType() {
            BuildElementDictionary();
            contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(MassTraceXName), new ChoiceContentModelEntity(new NamedContentModelEntity(cvParamXName), new NamedContentModelEntity(userParamXName)));
        }
        
        /// <summary>
        /// <para>
        /// A region on a (potentially) two-dimensional map of MS1 scans, defined by the retention time, mass over charge and optionally a mass trace. Quantitative values about features can be added in the associated QuantLayers. For techniques that analyse data from single scans e.g. MS2 tagging approaches, a Feature corresponds with the mz of the parent ions only.
        /// </para>
        /// <para>
        /// Regular expression: (MassTrace?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public FeatureType() {
        }
        
        /// <summary>
        /// <para>
        /// The coordinates defining the feature in RT and MZ space, given as boundary points or a series of rectangles, as encoded by the MassTraceEncoding cvParam on the FeatureList.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// <para>
        /// Regular expression: (MassTrace?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<double> MassTrace {
            get {
                XElement x = this.GetElement(MassTraceXName);
                return XTypedServices.ParseListValue<double>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Double).Datatype);
            }
            set {
                this.SetListElement(MassTraceXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Double).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Setter: Appends
        /// </para>
        /// <para>
        /// Regular expression: (MassTrace?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<CVParamType> cvParam {
            get {
                if ((this.cvParamField == null)) {
                    this.cvParamField = new XTypedList<CVParamType>(this, LinqToXsdTypeManager.Instance, cvParamXName);
                }
                return this.cvParamField;
            }
            set {
                if ((value == null)) {
                    this.cvParamField = null;
                }
                else {
                    if ((this.cvParamField == null)) {
                        this.cvParamField = XTypedList<CVParamType>.Initialize(this, LinqToXsdTypeManager.Instance, value, cvParamXName);
                    }
                    else {
                        XTypedServices.SetList<CVParamType>(this.cvParamField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Setter: Appends
        /// </para>
        /// <para>
        /// Regular expression: (MassTrace?, (cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<UserParamType> userParam {
            get {
                if ((this.userParamField == null)) {
                    this.userParamField = new XTypedList<UserParamType>(this, LinqToXsdTypeManager.Instance, userParamXName);
                }
                return this.userParamField;
            }
            set {
                if ((value == null)) {
                    this.userParamField = null;
                }
                else {
                    if ((this.userParamField == null)) {
                        this.userParamField = XTypedList<UserParamType>.Initialize(this, LinqToXsdTypeManager.Instance, value, userParamXName);
                    }
                    else {
                        XTypedServices.SetList<UserParamType>(this.userParamField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Unique identifier for the feature.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual string id {
            get {
                XAttribute x = this.Attribute(idXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Id).Datatype);
            }
            set {
                this.SetAttribute(idXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Id).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The centre point of the feature on the retention time axis in minutes. If the retention time is unknown, the value should be null.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual object rt {
            get {
                XAttribute x = this.Attribute(rtXName);
                return XTypedServices.ParseUnionValue(x, global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.doubleOrNullType.TypeDefinition);
            }
            set {
                this.SetUnionAttribute(value, "rt", this, rtXName, global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.doubleOrNullType.TypeDefinition);
            }
        }
        
        /// <summary>
        /// <para>
        /// The monoisotopic peak on the mass over charge axis in daltons over charge.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual double mz {
            get {
                XAttribute x = this.Attribute(mzXName);
                return XTypedServices.ParseValue<double>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Double).Datatype);
            }
            set {
                this.SetAttribute(mzXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Double).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The assumed charge of the feature, used to calculate the m/z value. If the charge is unknown the null type MUST be used.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual object charge {
            get {
                XAttribute x = this.Attribute(chargeXName);
                return XTypedServices.ParseUnionValue(x, global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.integerOrNullType.TypeDefinition);
            }
            set {
                this.SetUnionAttribute(value, "charge", this, chargeXName, global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.integerOrNullType.TypeDefinition);
            }
        }
        
        /// <summary>
        /// <para>
        /// The identifier(s) of the chromatogram from which this feature was detected, for example required for SRM analyses. Multiple values can be provided separated by spaces following the XSD:IDREFS style.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string chromatogram_refs {
            get {
                XAttribute x = this.Attribute(chromatogram_refsXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(chromatogram_refsXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// An optional identifier for an individual spectrum from which this feature was detected, required only for techniques where rt mapping is not appropriate. Multiple values can be provided separated by spaces following the XSD:IDREFS style.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string spectrum_refs {
            get {
                XAttribute x = this.Attribute(spectrum_refsXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(spectrum_refsXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// An optional reference to a RawFile element inside a RawFileGroup. The reference MUST be used if multiple RawFiles are provided within a RawFilesGroup, e.g. if pre-fractionation has occurred, and SHOULD not be used otherwise.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string rawFile_ref {
            get {
                XAttribute x = this.Attribute(rawFile_refXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
            set {
                this.SetAttribute(rawFile_refXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<FeatureType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(MassTraceXName, typeof(double));
            localElementDictionary.Add(cvParamXName, typeof(CVParamType));
            localElementDictionary.Add(userParamXName, typeof(UserParamType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    /// <summary>
    /// <para>
    /// The modification searched for or used to define the label or tag for quantification. It SHOULD be sourced from UniMod, PSI-MS or PSI-MOD.
    /// </para>
    /// <para>
    /// Regular expression: (cvParam)
    /// </para>
    /// </summary>
    public partial class ModParamType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName cvParamXName = System.Xml.Linq.XName.Get("cvParam", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName massDeltaXName = System.Xml.Linq.XName.Get("massDelta", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName residuesXName = System.Xml.Linq.XName.Get("residues", "");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("ModParamType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator ModParamType(XElement xe) { return XTypedServices.ToXTypedElement<ModParamType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static ModParamType() {
            BuildElementDictionary();
            contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(cvParamXName));
        }
        
        /// <summary>
        /// <para>
        /// The modification searched for or used to define the label or tag for quantification. It SHOULD be sourced from UniMod, PSI-MS or PSI-MOD.
        /// </para>
        /// <para>
        /// Regular expression: (cvParam)
        /// </para>
        /// </summary>
        public ModParamType() {
        }
        
        /// <summary>
        /// <para>
        /// The name of the modification imported from a relevant CV.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// <para>
        /// Regular expression: (cvParam)
        /// </para>
        /// </summary>
        public virtual CVParamType cvParam {
            get {
                XElement x = this.GetElement(cvParamXName);
                return ((CVParamType)(x));
            }
            set {
                this.SetElement(cvParamXName, value);
            }
        }
        
        /// <summary>
        /// <para>
        /// The mass delta of the modification in Daltons
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual System.Single? massDelta {
            get {
                XAttribute x = this.Attribute(massDeltaXName);
                if ((x == null)) {
                    return null;
                }
                return XTypedServices.ParseValue<float>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Float).Datatype);
            }
            set {
                this.SetAttribute(massDeltaXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Float).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The residue(s) to which the modification has been applied.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual IList<string> residues {
            get {
                XAttribute x = this.Attribute(residuesXName);
                return XTypedServices.ParseListValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetListAttribute(residuesXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<ModParamType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(cvParamXName, typeof(CVParamType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    /// <summary>
    /// <para>
    /// List and descriptions of data processing applied to this data.
    /// </para>
    /// <para>
    /// Regular expression: (DataProcessing+)
    /// </para>
    /// </summary>
    public partial class DataProcessingListType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName DataProcessingXName = System.Xml.Linq.XName.Get("DataProcessing", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<DataProcessingType> DataProcessingField;
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("DataProcessingListType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator DataProcessingListType(XElement xe) { return XTypedServices.ToXTypedElement<DataProcessingListType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static DataProcessingListType() {
            BuildElementDictionary();
            contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(DataProcessingXName));
        }
        
        /// <summary>
        /// <para>
        /// List and descriptions of data processing applied to this data.
        /// </para>
        /// <para>
        /// Regular expression: (DataProcessing+)
        /// </para>
        /// </summary>
        public DataProcessingListType() {
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, repeating
        /// </para>
        /// <para>
        /// Regular expression: (DataProcessing+)
        /// </para>
        /// </summary>
        public virtual IList<DataProcessingType> DataProcessing {
            get {
                if ((this.DataProcessingField == null)) {
                    this.DataProcessingField = new XTypedList<DataProcessingType>(this, LinqToXsdTypeManager.Instance, DataProcessingXName);
                }
                return this.DataProcessingField;
            }
            set {
                if ((value == null)) {
                    this.DataProcessingField = null;
                }
                else {
                    if ((this.DataProcessingField == null)) {
                        this.DataProcessingField = XTypedList<DataProcessingType>.Initialize(this, LinqToXsdTypeManager.Instance, value, DataProcessingXName);
                    }
                    else {
                        XTypedServices.SetList<DataProcessingType>(this.DataProcessingField, value);
                    }
                }
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<DataProcessingListType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(DataProcessingXName, typeof(DataProcessingType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    /// <summary>
    /// <para>
    /// Description of the way in which a particular software package was used to analyse data and for example produce different quant layers or lists in the file.
    /// </para>
    /// <para>
    /// Regular expression: (InputObject_refs?, OutputObject_refs?, ProcessingMethod+)
    /// </para>
    /// </summary>
    public partial class DataProcessingType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName InputObject_refsXName = System.Xml.Linq.XName.Get("InputObject_refs", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName OutputObject_refsXName = System.Xml.Linq.XName.Get("OutputObject_refs", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName ProcessingMethodXName = System.Xml.Linq.XName.Get("ProcessingMethod", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<ProcessingMethodType> ProcessingMethodField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName idXName = System.Xml.Linq.XName.Get("id", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName software_refXName = System.Xml.Linq.XName.Get("software_ref", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName orderXName = System.Xml.Linq.XName.Get("order", "");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("DataProcessingType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator DataProcessingType(XElement xe) { return XTypedServices.ToXTypedElement<DataProcessingType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static DataProcessingType() {
            BuildElementDictionary();
            contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(InputObject_refsXName), new NamedContentModelEntity(OutputObject_refsXName), new NamedContentModelEntity(ProcessingMethodXName));
        }
        
        /// <summary>
        /// <para>
        /// Description of the way in which a particular software package was used to analyse data and for example produce different quant layers or lists in the file.
        /// </para>
        /// <para>
        /// Regular expression: (InputObject_refs?, OutputObject_refs?, ProcessingMethod+)
        /// </para>
        /// </summary>
        public DataProcessingType() {
        }
        
        /// <summary>
        /// <para>
        /// References to raw file groups, FeatureList, PeptideConsensusList, ProteinList or ProteinGroupList or QuantLayers that were inputs to the data processing step.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// <para>
        /// Regular expression: (InputObject_refs?, OutputObject_refs?, ProcessingMethod+)
        /// </para>
        /// </summary>
        public virtual IList<string> InputObject_refs {
            get {
                XElement x = this.GetElement(InputObject_refsXName);
                return XTypedServices.ParseListValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
            set {
                this.SetListElement(InputObject_refsXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// References to raw file groups, FeatureList, PeptideConsensusList, ProteinList or ProteinGroupList or QuantLayers that were the outputs of the data processing step.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// <para>
        /// Regular expression: (InputObject_refs?, OutputObject_refs?, ProcessingMethod+)
        /// </para>
        /// </summary>
        public virtual IList<string> OutputObject_refs {
            get {
                XElement x = this.GetElement(OutputObject_refsXName);
                return XTypedServices.ParseListValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
            set {
                this.SetListElement(OutputObject_refsXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, repeating
        /// </para>
        /// <para>
        /// Regular expression: (InputObject_refs?, OutputObject_refs?, ProcessingMethod+)
        /// </para>
        /// </summary>
        public virtual IList<ProcessingMethodType> ProcessingMethod {
            get {
                if ((this.ProcessingMethodField == null)) {
                    this.ProcessingMethodField = new XTypedList<ProcessingMethodType>(this, LinqToXsdTypeManager.Instance, ProcessingMethodXName);
                }
                return this.ProcessingMethodField;
            }
            set {
                if ((value == null)) {
                    this.ProcessingMethodField = null;
                }
                else {
                    if ((this.ProcessingMethodField == null)) {
                        this.ProcessingMethodField = XTypedList<ProcessingMethodType>.Initialize(this, LinqToXsdTypeManager.Instance, value, ProcessingMethodXName);
                    }
                    else {
                        XTypedServices.SetList<ProcessingMethodType>(this.ProcessingMethodField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// The unique identifier for the object within the file.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual string id {
            get {
                XAttribute x = this.Attribute(idXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Id).Datatype);
            }
            set {
                this.SetAttribute(idXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Id).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// This attribute MUST reference the appropriate SoftwareType.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual string software_ref {
            get {
                XAttribute x = this.Attribute(software_refXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
            set {
                this.SetAttribute(software_refXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// This attributes allows a series of consecutive steps to be placed in the correct order, start counting from 1.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual decimal order {
            get {
                XAttribute x = this.Attribute(orderXName);
                return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
            }
            set {
                this.SetAttribute(orderXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<DataProcessingType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(InputObject_refsXName, typeof(string));
            localElementDictionary.Add(OutputObject_refsXName, typeof(string));
            localElementDictionary.Add(ProcessingMethodXName, typeof(ProcessingMethodType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    /// <summary>
    /// <para>
    /// Description of one step within the data processing pipeline.
    /// </para>
    /// <para>
    /// Regular expression: ((cvParam | userParam)*)
    /// </para>
    /// </summary>
    public partial class ProcessingMethodType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName cvParamXName = System.Xml.Linq.XName.Get("cvParam", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<CVParamType> cvParamField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName userParamXName = System.Xml.Linq.XName.Get("userParam", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<UserParamType> userParamField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName orderXName = System.Xml.Linq.XName.Get("order", "");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("ProcessingMethodType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator ProcessingMethodType(XElement xe) { return XTypedServices.ToXTypedElement<ProcessingMethodType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static ProcessingMethodType() {
            BuildElementDictionary();
            contentModel = new SequenceContentModelEntity(new ChoiceContentModelEntity(new NamedContentModelEntity(cvParamXName), new NamedContentModelEntity(userParamXName)));
        }
        
        /// <summary>
        /// <para>
        /// Description of one step within the data processing pipeline.
        /// </para>
        /// <para>
        /// Regular expression: ((cvParam | userParam)*)
        /// </para>
        /// </summary>
        public ProcessingMethodType() {
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Setter: Appends
        /// </para>
        /// <para>
        /// Regular expression: ((cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<CVParamType> cvParam {
            get {
                if ((this.cvParamField == null)) {
                    this.cvParamField = new XTypedList<CVParamType>(this, LinqToXsdTypeManager.Instance, cvParamXName);
                }
                return this.cvParamField;
            }
            set {
                if ((value == null)) {
                    this.cvParamField = null;
                }
                else {
                    if ((this.cvParamField == null)) {
                        this.cvParamField = XTypedList<CVParamType>.Initialize(this, LinqToXsdTypeManager.Instance, value, cvParamXName);
                    }
                    else {
                        XTypedServices.SetList<CVParamType>(this.cvParamField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Setter: Appends
        /// </para>
        /// <para>
        /// Regular expression: ((cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<UserParamType> userParam {
            get {
                if ((this.userParamField == null)) {
                    this.userParamField = new XTypedList<UserParamType>(this, LinqToXsdTypeManager.Instance, userParamXName);
                }
                return this.userParamField;
            }
            set {
                if ((value == null)) {
                    this.userParamField = null;
                }
                else {
                    if ((this.userParamField == null)) {
                        this.userParamField = XTypedList<UserParamType>.Initialize(this, LinqToXsdTypeManager.Instance, value, userParamXName);
                    }
                    else {
                        XTypedServices.SetList<UserParamType>(this.userParamField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// This attributes allows a series of consecutive steps to be placed in the correct order, start counting from 1.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual decimal order {
            get {
                XAttribute x = this.Attribute(orderXName);
                return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
            }
            set {
                this.SetAttribute(orderXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<ProcessingMethodType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(cvParamXName, typeof(CVParamType));
            localElementDictionary.Add(userParamXName, typeof(UserParamType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    /// <summary>
    /// <para>
    /// List and descriptions of software used to acquire and/or process the data in this file.
    /// </para>
    /// <para>
    /// Regular expression: (Software+)
    /// </para>
    /// </summary>
    public partial class SoftwareListType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName SoftwareXName = System.Xml.Linq.XName.Get("Software", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<SoftwareType> SoftwareField;
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("SoftwareListType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator SoftwareListType(XElement xe) { return XTypedServices.ToXTypedElement<SoftwareListType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static SoftwareListType() {
            BuildElementDictionary();
            contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(SoftwareXName));
        }
        
        /// <summary>
        /// <para>
        /// List and descriptions of software used to acquire and/or process the data in this file.
        /// </para>
        /// <para>
        /// Regular expression: (Software+)
        /// </para>
        /// </summary>
        public SoftwareListType() {
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, repeating
        /// </para>
        /// <para>
        /// Regular expression: (Software+)
        /// </para>
        /// </summary>
        public virtual IList<SoftwareType> Software {
            get {
                if ((this.SoftwareField == null)) {
                    this.SoftwareField = new XTypedList<SoftwareType>(this, LinqToXsdTypeManager.Instance, SoftwareXName);
                }
                return this.SoftwareField;
            }
            set {
                if ((value == null)) {
                    this.SoftwareField = null;
                }
                else {
                    if ((this.SoftwareField == null)) {
                        this.SoftwareField = XTypedList<SoftwareType>.Initialize(this, LinqToXsdTypeManager.Instance, value, SoftwareXName);
                    }
                    else {
                        XTypedServices.SetList<SoftwareType>(this.SoftwareField, value);
                    }
                }
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<SoftwareListType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(SoftwareXName, typeof(SoftwareType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    /// <summary>
    /// <para>
    /// A software package used in the analysis.
    /// </para>
    /// <para>
    /// Regular expression: ((cvParam | userParam)*)
    /// </para>
    /// </summary>
    public partial class SoftwareType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName cvParamXName = System.Xml.Linq.XName.Get("cvParam", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<CVParamType> cvParamField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName userParamXName = System.Xml.Linq.XName.Get("userParam", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<UserParamType> userParamField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName idXName = System.Xml.Linq.XName.Get("id", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName versionXName = System.Xml.Linq.XName.Get("version", "");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("SoftwareType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator SoftwareType(XElement xe) { return XTypedServices.ToXTypedElement<SoftwareType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static SoftwareType() {
            BuildElementDictionary();
            contentModel = new SequenceContentModelEntity(new ChoiceContentModelEntity(new NamedContentModelEntity(cvParamXName), new NamedContentModelEntity(userParamXName)));
        }
        
        /// <summary>
        /// <para>
        /// A software package used in the analysis.
        /// </para>
        /// <para>
        /// Regular expression: ((cvParam | userParam)*)
        /// </para>
        /// </summary>
        public SoftwareType() {
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Setter: Appends
        /// </para>
        /// <para>
        /// Regular expression: ((cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<CVParamType> cvParam {
            get {
                if ((this.cvParamField == null)) {
                    this.cvParamField = new XTypedList<CVParamType>(this, LinqToXsdTypeManager.Instance, cvParamXName);
                }
                return this.cvParamField;
            }
            set {
                if ((value == null)) {
                    this.cvParamField = null;
                }
                else {
                    if ((this.cvParamField == null)) {
                        this.cvParamField = XTypedList<CVParamType>.Initialize(this, LinqToXsdTypeManager.Instance, value, cvParamXName);
                    }
                    else {
                        XTypedServices.SetList<CVParamType>(this.cvParamField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Setter: Appends
        /// </para>
        /// <para>
        /// Regular expression: ((cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<UserParamType> userParam {
            get {
                if ((this.userParamField == null)) {
                    this.userParamField = new XTypedList<UserParamType>(this, LinqToXsdTypeManager.Instance, userParamXName);
                }
                return this.userParamField;
            }
            set {
                if ((value == null)) {
                    this.userParamField = null;
                }
                else {
                    if ((this.userParamField == null)) {
                        this.userParamField = XTypedList<UserParamType>.Initialize(this, LinqToXsdTypeManager.Instance, value, userParamXName);
                    }
                    else {
                        XTypedServices.SetList<UserParamType>(this.userParamField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// The unique identifier for the object within the file.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual string id {
            get {
                XAttribute x = this.Attribute(idXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Id).Datatype);
            }
            set {
                this.SetAttribute(idXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Id).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The software version.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual string version {
            get {
                XAttribute x = this.Attribute(versionXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(versionXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<SoftwareType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(cvParamXName, typeof(CVParamType));
            localElementDictionary.Add(userParamXName, typeof(UserParamType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    public sealed class listOfDoubles {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.ListSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Double), null, new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Double), null));
        
        private listOfDoubles() {
        }
    }
    
    public sealed class listOfDoublesOrNulls {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.ListSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.AnyAtomicType), null, psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.doubleOrNullType.TypeDefinition);
        
        private listOfDoublesOrNulls() {
        }
    }
    
    public sealed class doubleOrNullType {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.UnionSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.AnyAtomicType), null, new Xml.Schema.Linq.SimpleTypeValidator[] {
                    new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Double), null),
                    new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                                    "null"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Collapse))});
        
        private doubleOrNullType() {
        }
    }
    
    public sealed class integerOrNullType {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.UnionSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.AnyAtomicType), null, new Xml.Schema.Linq.SimpleTypeValidator[] {
                    new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Integer), null),
                    new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                                    "null"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Collapse))});
        
        private integerOrNullType() {
        }
    }
    
    public sealed class listOfIDs {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.ListSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Id), null, new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Id), null));
        
        private listOfIDs() {
        }
    }
    
    /// <summary>
    /// <para>
    /// Helper complexType to include one cvParam as a sub-element
    /// </para>
    /// <para>
    /// Regular expression: (cvParam)
    /// </para>
    /// </summary>
    public partial class cvParamRefType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName cvParamXName = System.Xml.Linq.XName.Get("cvParam", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("cvParamRefType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator cvParamRefType(XElement xe) { return XTypedServices.ToXTypedElement<cvParamRefType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static cvParamRefType() {
            BuildElementDictionary();
            contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(cvParamXName));
        }
        
        /// <summary>
        /// <para>
        /// Helper complexType to include one cvParam as a sub-element
        /// </para>
        /// <para>
        /// Regular expression: (cvParam)
        /// </para>
        /// </summary>
        public cvParamRefType() {
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// <para>
        /// Regular expression: (cvParam)
        /// </para>
        /// </summary>
        public virtual CVParamType cvParam {
            get {
                XElement x = this.GetElement(cvParamXName);
                return ((CVParamType)(x));
            }
            set {
                this.SetElement(cvParamXName, value);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<cvParamRefType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(cvParamXName, typeof(CVParamType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    /// <summary>
    /// <para>
    /// A single entry from an ontology or a controlled vocabulary.
    /// </para>
    /// </summary>
    public partial class CVParamType : global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.AbstractParamType, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName cvRefXName = System.Xml.Linq.XName.Get("cvRef", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName accessionXName = System.Xml.Linq.XName.Get("accession", "");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("CVParamType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
		public static explicit operator CVParamType(XElement xe) { return XTypedServices.ToXTypedElement<CVParamType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        /// <summary>
        /// <para>
        /// A single entry from an ontology or a controlled vocabulary.
        /// </para>
        /// </summary>
        public CVParamType() {
        }
        
        /// <summary>
        /// <para>
        /// A reference to the cv element from which this term originates. 
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual string cvRef {
            get {
                XAttribute x = this.Attribute(cvRefXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
            set {
                this.SetAttribute(cvRefXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The accession or ID number of this CV term in the source CV. 
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual string accession {
            get {
                XAttribute x = this.Attribute(accessionXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(accessionXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<CVParamType>(this);
        }
    }
    
    /// <summary>
    /// <para>
    /// Abstract entity allowing either cvParam or userParam to be referenced in other schemas. 
    /// </para>
    /// </summary>
    public abstract partial class AbstractParamType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName nameXName = System.Xml.Linq.XName.Get("name", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName valueXName = System.Xml.Linq.XName.Get("value", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName unitAccessionXName = System.Xml.Linq.XName.Get("unitAccession", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName unitNameXName = System.Xml.Linq.XName.Get("unitName", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName unitCvRefXName = System.Xml.Linq.XName.Get("unitCvRef", "");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("AbstractParamType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
		public static explicit operator AbstractParamType(XElement xe) {  return (AbstractParamType)XTypedServices.ToXTypedElement(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        /// <summary>
        /// <para>
        /// Abstract entity allowing either cvParam or userParam to be referenced in other schemas. 
        /// </para>
        /// </summary>
        public AbstractParamType() {
        }
        
        /// <summary>
        /// <para>
        /// The name of the parameter.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual string name {
            get {
                XAttribute x = this.Attribute(nameXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(nameXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The user-entered value of the parameter.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string value {
            get {
                XAttribute x = this.Attribute(valueXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(valueXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// An accession number identifying the unit within the OBO foundry Unit CV. 
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string unitAccession {
            get {
                XAttribute x = this.Attribute(unitAccessionXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(unitAccessionXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The name of the unit.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string unitName {
            get {
                XAttribute x = this.Attribute(unitNameXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(unitNameXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// If a unit term is referenced, this attribute MUST refer to the CV 'id' attribute defined in the cvList in this file. 
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string unitCvRef {
            get {
                XAttribute x = this.Attribute(unitCvRefXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(unitCvRefXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
    }
    
    /// <summary>
    /// <para>
    /// A single user-defined parameter.
    /// </para>
    /// </summary>
    public partial class UserParamType : global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.AbstractParamType, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName typeXName = System.Xml.Linq.XName.Get("type", "");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("UserParamType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
		public static explicit operator UserParamType(XElement xe) { return XTypedServices.ToXTypedElement<UserParamType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        /// <summary>
        /// <para>
        /// A single user-defined parameter.
        /// </para>
        /// </summary>
        public UserParamType() {
        }
        
        /// <summary>
        /// <para>
        /// The datatype of the parameter, where appropriate (e.g.: xsd:float).
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string type {
            get {
                XAttribute x = this.Attribute(typeXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(typeXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<UserParamType>(this);
        }
    }
    
    /// <summary>
    /// <para>
    /// Helper type to allow multiple cvParams or userParams to be given for an element.
    /// </para>
    /// <para>
    /// Regular expression: (cvParam | userParam)+
    /// </para>
    /// </summary>
    public partial class ParamListType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName cvParamXName = System.Xml.Linq.XName.Get("cvParam", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<CVParamType> cvParamField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName userParamXName = System.Xml.Linq.XName.Get("userParam", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<UserParamType> userParamField;
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("ParamListType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator ParamListType(XElement xe) { return XTypedServices.ToXTypedElement<ParamListType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static ParamListType() {
            BuildElementDictionary();
            contentModel = new ChoiceContentModelEntity(new NamedContentModelEntity(cvParamXName), new NamedContentModelEntity(userParamXName));
        }
        
        /// <summary>
        /// <para>
        /// Helper type to allow multiple cvParams or userParams to be given for an element.
        /// </para>
        /// <para>
        /// Regular expression: (cvParam | userParam)+
        /// </para>
        /// </summary>
        public ParamListType() {
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Regular expression: (cvParam | userParam)+
        /// </para>
        /// </summary>
        public virtual IList<CVParamType> cvParam {
            get {
                if ((this.cvParamField == null)) {
                    this.cvParamField = new XTypedList<CVParamType>(this, LinqToXsdTypeManager.Instance, cvParamXName);
                }
                return this.cvParamField;
            }
            set {
                if ((value == null)) {
                    this.cvParamField = null;
                }
                else {
                    if ((this.cvParamField == null)) {
                        this.cvParamField = XTypedList<CVParamType>.Initialize(this, LinqToXsdTypeManager.Instance, value, cvParamXName);
                    }
                    else {
                        XTypedServices.SetList<CVParamType>(this.cvParamField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Regular expression: (cvParam | userParam)+
        /// </para>
        /// </summary>
        public virtual IList<UserParamType> userParam {
            get {
                if ((this.userParamField == null)) {
                    this.userParamField = new XTypedList<UserParamType>(this, LinqToXsdTypeManager.Instance, userParamXName);
                }
                return this.userParamField;
            }
            set {
                if ((value == null)) {
                    this.userParamField = null;
                }
                else {
                    if ((this.userParamField == null)) {
                        this.userParamField = XTypedList<UserParamType>.Initialize(this, LinqToXsdTypeManager.Instance, value, userParamXName);
                    }
                    else {
                        XTypedServices.SetList<UserParamType>(this.userParamField, value);
                    }
                }
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<ParamListType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(cvParamXName, typeof(CVParamType));
            localElementDictionary.Add(userParamXName, typeof(UserParamType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    /// <summary>
    /// <para>
    /// Helper type to allow either a cvParam or a userParam to be provided for an element.
    /// </para>
    /// <para>
    /// Regular expression: (cvParam | userParam)
    /// </para>
    /// </summary>
    public partial class ParamType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName cvParamXName = System.Xml.Linq.XName.Get("cvParam", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName userParamXName = System.Xml.Linq.XName.Get("userParam", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("ParamType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator ParamType(XElement xe) { return XTypedServices.ToXTypedElement<ParamType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static ParamType() {
            BuildElementDictionary();
            contentModel = new ChoiceContentModelEntity(new NamedContentModelEntity(cvParamXName), new NamedContentModelEntity(userParamXName));
        }
        
        /// <summary>
        /// <para>
        /// Helper type to allow either a cvParam or a userParam to be provided for an element.
        /// </para>
        /// <para>
        /// Regular expression: (cvParam | userParam)
        /// </para>
        /// </summary>
        public ParamType() {
        }
        
        public ParamType(CVParamType cvParam) {
            this.cvParam = cvParam;
        }
        
        public ParamType(UserParamType userParam) {
            this.userParam = userParam;
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Regular expression: (cvParam | userParam)
        /// </para>
        /// </summary>
        public virtual CVParamType cvParam {
            get {
                XElement x = this.GetElement(cvParamXName);
                return ((CVParamType)(x));
            }
            set {
                this.SetElement(cvParamXName, value);
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Regular expression: (cvParam | userParam)
        /// </para>
        /// </summary>
        public virtual UserParamType userParam {
            get {
                XElement x = this.GetElement(userParamXName);
                return ((UserParamType)(x));
            }
            set {
                this.SetElement(userParamXName, value);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<ParamType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(cvParamXName, typeof(CVParamType));
            localElementDictionary.Add(userParamXName, typeof(UserParamType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    /// <summary>
    /// <para>
    /// Data external to the XML instance document. The location of the data file is given in the location attribute. 
    /// </para>
    /// <para>
    /// Regular expression: (ExternalFormatDocumentation?, FileFormat?)
    /// </para>
    /// </summary>
    public partial class ExternalDataType : global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.IdentifiableType, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName ExternalFormatDocumentationXName = System.Xml.Linq.XName.Get("ExternalFormatDocumentation", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName FileFormatXName = System.Xml.Linq.XName.Get("FileFormat", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName locationXName = System.Xml.Linq.XName.Get("location", "");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("ExternalDataType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator ExternalDataType(XElement xe) { return XTypedServices.ToXTypedElement<ExternalDataType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static ExternalDataType() {
            BuildElementDictionary();
            contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(ExternalFormatDocumentationXName), new NamedContentModelEntity(FileFormatXName));
        }
        
        /// <summary>
        /// <para>
        /// Data external to the XML instance document. The location of the data file is given in the location attribute. 
        /// </para>
        /// <para>
        /// Regular expression: (ExternalFormatDocumentation?, FileFormat?)
        /// </para>
        /// </summary>
        public ExternalDataType() {
        }
        
        /// <summary>
        /// <para>
        /// A URI to access documentation and tools to interpret the external format of the ExternalData instance. For example, XML Schema or static libraries (APIs) to access binary formats.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// <para>
        /// Regular expression: (ExternalFormatDocumentation?, FileFormat?)
        /// </para>
        /// </summary>
        public virtual System.Uri ExternalFormatDocumentation {
            get {
                XElement x = this.GetElement(ExternalFormatDocumentationXName);
                return XTypedServices.ParseValue<System.Uri>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.AnyUri).Datatype);
            }
            set {
                this.SetElement(ExternalFormatDocumentationXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.AnyUri).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// <para>
        /// Regular expression: (ExternalFormatDocumentation?, FileFormat?)
        /// </para>
        /// </summary>
        public virtual FileFormatType FileFormat {
            get {
                XElement x = this.GetElement(FileFormatXName);
                return ((FileFormatType)(x));
            }
            set {
                this.SetElement(FileFormatXName, value);
            }
        }
        
        /// <summary>
        /// <para>
        /// The location of the data file.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual System.Uri location {
            get {
                XAttribute x = this.Attribute(locationXName);
                return XTypedServices.ParseValue<System.Uri>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.AnyUri).Datatype);
            }
            set {
                this.SetAttribute(locationXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.AnyUri).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<ExternalDataType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(ExternalFormatDocumentationXName, typeof(System.Uri));
            localElementDictionary.Add(FileFormatXName, typeof(FileFormatType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    /// <summary>
    /// <para>
    /// The format of the ExternalData file, for example "tiff" for image files. 
    /// </para>
    /// <para>
    /// Regular expression: (cvParam)
    /// </para>
    /// </summary>
    public partial class FileFormatType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName cvParamXName = System.Xml.Linq.XName.Get("cvParam", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("FileFormatType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator FileFormatType(XElement xe) { return XTypedServices.ToXTypedElement<FileFormatType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static FileFormatType() {
            BuildElementDictionary();
            contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(cvParamXName));
        }
        
        /// <summary>
        /// <para>
        /// The format of the ExternalData file, for example "tiff" for image files. 
        /// </para>
        /// <para>
        /// Regular expression: (cvParam)
        /// </para>
        /// </summary>
        public FileFormatType() {
        }
        
        /// <summary>
        /// <para>
        /// cvParam capturing file formats
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// <para>
        /// Regular expression: (cvParam)
        /// </para>
        /// </summary>
        public virtual CVParamType cvParam {
            get {
                XElement x = this.GetElement(cvParamXName);
                return ((CVParamType)(x));
            }
            set {
                this.SetElement(cvParamXName, value);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<FileFormatType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(cvParamXName, typeof(CVParamType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    /// <summary>
    /// <para>
    /// The provider of the document in terms of the Contact and the software the produced the document instance. 
    /// </para>
    /// <para>
    /// Regular expression: (ContactRole?)
    /// </para>
    /// </summary>
    public partial class ProviderType : global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.IdentifiableType, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName ContactRoleXName = System.Xml.Linq.XName.Get("ContactRole", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName analysisSoftware_refXName = System.Xml.Linq.XName.Get("analysisSoftware_ref", "");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("ProviderType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator ProviderType(XElement xe) { return XTypedServices.ToXTypedElement<ProviderType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static ProviderType() {
            BuildElementDictionary();
            contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(ContactRoleXName));
        }
        
        /// <summary>
        /// <para>
        /// The provider of the document in terms of the Contact and the software the produced the document instance. 
        /// </para>
        /// <para>
        /// Regular expression: (ContactRole?)
        /// </para>
        /// </summary>
        public ProviderType() {
        }
        
        /// <summary>
        /// <para>
        /// The role of the Contact that provided the document instance.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// <para>
        /// Regular expression: (ContactRole?)
        /// </para>
        /// </summary>
        public virtual ContactRoleType ContactRole {
            get {
                XElement x = this.GetElement(ContactRoleXName);
                return ((ContactRoleType)(x));
            }
            set {
                this.SetElement(ContactRoleXName, value);
            }
        }
        
        /// <summary>
        /// <para>
        /// The Software that produced the document instance.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string analysisSoftware_ref {
            get {
                XAttribute x = this.Attribute(analysisSoftware_refXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
            set {
                this.SetAttribute(analysisSoftware_refXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<ProviderType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(ContactRoleXName, typeof(ContactRoleType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    /// <summary>
    /// <para>
    /// A person's name and contact details. Any additional information such as the address, contact email etc. should be supplied using CV parameters or user parameters.
    /// </para>
    /// <para>
    /// Regular expression: ((cvParam | userParam)*, Affiliation*)
    /// </para>
    /// </summary>
    public partial class PersonType : global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.AbstractContactType, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName AffiliationXName = System.Xml.Linq.XName.Get("Affiliation", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<AffiliationType> AffiliationField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName lastNameXName = System.Xml.Linq.XName.Get("lastName", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName firstNameXName = System.Xml.Linq.XName.Get("firstName", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName midInitialsXName = System.Xml.Linq.XName.Get("midInitials", "");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("PersonType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator PersonType(XElement xe) { return XTypedServices.ToXTypedElement<PersonType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static PersonType() {
            BuildElementDictionary();
            contentModel = new SequenceContentModelEntity(new ChoiceContentModelEntity(new NamedContentModelEntity(cvParamXName), new NamedContentModelEntity(userParamXName)), new NamedContentModelEntity(AffiliationXName));
        }
        
        /// <summary>
        /// <para>
        /// A person's name and contact details. Any additional information such as the address, contact email etc. should be supplied using CV parameters or user parameters.
        /// </para>
        /// <para>
        /// Regular expression: ((cvParam | userParam)*, Affiliation*)
        /// </para>
        /// </summary>
        public PersonType() {
        }
        
        /// <summary>
        /// <para>
        /// The organization a person belongs to.
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating
        /// </para>
        /// <para>
        /// Regular expression: ((cvParam | userParam)*, Affiliation*)
        /// </para>
        /// </summary>
        public virtual IList<AffiliationType> Affiliation {
            get {
                if ((this.AffiliationField == null)) {
                    this.AffiliationField = new XTypedList<AffiliationType>(this, LinqToXsdTypeManager.Instance, AffiliationXName);
                }
                return this.AffiliationField;
            }
            set {
                if ((value == null)) {
                    this.AffiliationField = null;
                }
                else {
                    if ((this.AffiliationField == null)) {
                        this.AffiliationField = XTypedList<AffiliationType>.Initialize(this, LinqToXsdTypeManager.Instance, value, AffiliationXName);
                    }
                    else {
                        XTypedServices.SetList<AffiliationType>(this.AffiliationField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// The Person's last/family name.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string lastName {
            get {
                XAttribute x = this.Attribute(lastNameXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(lastNameXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The Person's first name.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string firstName {
            get {
                XAttribute x = this.Attribute(firstNameXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(firstNameXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The Person's middle initial.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string midInitials {
            get {
                XAttribute x = this.Attribute(midInitialsXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(midInitialsXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<PersonType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(cvParamXName, typeof(CVParamType));
            localElementDictionary.Add(userParamXName, typeof(UserParamType));
            localElementDictionary.Add(AffiliationXName, typeof(AffiliationType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    public partial class AffiliationType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName organization_refXName = System.Xml.Linq.XName.Get("organization_ref", "");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("AffiliationType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
		public static explicit operator AffiliationType(XElement xe) { return XTypedServices.ToXTypedElement<AffiliationType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public AffiliationType() {
        }
        
        /// <summary>
        /// <para>
        /// A reference to the organization this contact belongs to.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual string organization_ref {
            get {
                XAttribute x = this.Attribute(organization_refXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
            set {
                this.SetAttribute(organization_refXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<AffiliationType>(this);
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
    }
    
    /// <summary>
    /// <para>
    /// Organizations are entities like companies, universities, government agencies. Any additional information such as the address, email etc. should be supplied either as CV parameters or as user parameters. 
    /// </para>
    /// <para>
    /// Regular expression: ((cvParam | userParam)*, ParentOrganization?)
    /// </para>
    /// </summary>
    public partial class OrganizationType : global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.AbstractContactType, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName ParentOrganizationXName = System.Xml.Linq.XName.Get("ParentOrganization", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("OrganizationType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator OrganizationType(XElement xe) { return XTypedServices.ToXTypedElement<OrganizationType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static OrganizationType() {
            BuildElementDictionary();
            contentModel = new SequenceContentModelEntity(new ChoiceContentModelEntity(new NamedContentModelEntity(cvParamXName), new NamedContentModelEntity(userParamXName)), new NamedContentModelEntity(ParentOrganizationXName));
        }
        
        /// <summary>
        /// <para>
        /// Organizations are entities like companies, universities, government agencies. Any additional information such as the address, email etc. should be supplied either as CV parameters or as user parameters. 
        /// </para>
        /// <para>
        /// Regular expression: ((cvParam | userParam)*, ParentOrganization?)
        /// </para>
        /// </summary>
        public OrganizationType() {
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// <para>
        /// Regular expression: ((cvParam | userParam)*, ParentOrganization?)
        /// </para>
        /// </summary>
        public virtual ParentOrganizationType ParentOrganization {
            get {
                XElement x = this.GetElement(ParentOrganizationXName);
                return ((ParentOrganizationType)(x));
            }
            set {
                this.SetElement(ParentOrganizationXName, value);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<OrganizationType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(cvParamXName, typeof(CVParamType));
            localElementDictionary.Add(userParamXName, typeof(UserParamType));
            localElementDictionary.Add(ParentOrganizationXName, typeof(ParentOrganizationType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    /// <summary>
    /// <para>
    /// The containing organization (the university or business which a lab belongs to, etc.) 
    /// </para>
    /// </summary>
    public partial class ParentOrganizationType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName organization_refXName = System.Xml.Linq.XName.Get("organization_ref", "");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("ParentOrganizationType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
		public static explicit operator ParentOrganizationType(XElement xe) { return XTypedServices.ToXTypedElement<ParentOrganizationType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        /// <summary>
        /// <para>
        /// The containing organization (the university or business which a lab belongs to, etc.) 
        /// </para>
        /// </summary>
        public ParentOrganizationType() {
        }
        
        /// <summary>
        /// <para>
        /// A reference to the organization this contact belongs to.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual string organization_ref {
            get {
                XAttribute x = this.Attribute(organization_refXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
            set {
                this.SetAttribute(organization_refXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<ParentOrganizationType>(this);
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
    }
    
    /// <summary>
    /// <para>
    /// A contact is either a person or an organization.
    /// </para>
    /// <para>
    /// Regular expression: ((cvParam | userParam)*)
    /// </para>
    /// </summary>
    public abstract partial class AbstractContactType : global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.IdentifiableType, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName cvParamXName = System.Xml.Linq.XName.Get("cvParam", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<CVParamType> cvParamField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName userParamXName = System.Xml.Linq.XName.Get("userParam", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<UserParamType> userParamField;
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("AbstractContactType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator AbstractContactType(XElement xe) {  return (AbstractContactType)XTypedServices.ToXTypedElement(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static AbstractContactType() {
            BuildElementDictionary();
            contentModel = new SequenceContentModelEntity(new ChoiceContentModelEntity(new NamedContentModelEntity(cvParamXName), new NamedContentModelEntity(userParamXName)));
        }
        
        /// <summary>
        /// <para>
        /// A contact is either a person or an organization.
        /// </para>
        /// <para>
        /// Regular expression: ((cvParam | userParam)*)
        /// </para>
        /// </summary>
        public AbstractContactType() {
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Setter: Appends
        /// </para>
        /// <para>
        /// Regular expression: ((cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<CVParamType> cvParam {
            get {
                if ((this.cvParamField == null)) {
                    this.cvParamField = new XTypedList<CVParamType>(this, LinqToXsdTypeManager.Instance, cvParamXName);
                }
                return this.cvParamField;
            }
            set {
                if ((value == null)) {
                    this.cvParamField = null;
                }
                else {
                    if ((this.cvParamField == null)) {
                        this.cvParamField = XTypedList<CVParamType>.Initialize(this, LinqToXsdTypeManager.Instance, value, cvParamXName);
                    }
                    else {
                        XTypedServices.SetList<CVParamType>(this.cvParamField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Setter: Appends
        /// </para>
        /// <para>
        /// Regular expression: ((cvParam | userParam)*)
        /// </para>
        /// </summary>
        public virtual IList<UserParamType> userParam {
            get {
                if ((this.userParamField == null)) {
                    this.userParamField = new XTypedList<UserParamType>(this, LinqToXsdTypeManager.Instance, userParamXName);
                }
                return this.userParamField;
            }
            set {
                if ((value == null)) {
                    this.userParamField = null;
                }
                else {
                    if ((this.userParamField == null)) {
                        this.userParamField = XTypedList<UserParamType>.Initialize(this, LinqToXsdTypeManager.Instance, value, userParamXName);
                    }
                    else {
                        XTypedServices.SetList<UserParamType>(this.userParamField, value);
                    }
                }
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(cvParamXName, typeof(CVParamType));
            localElementDictionary.Add(userParamXName, typeof(UserParamType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    /// <summary>
    /// <para>
    /// The role that a Contact plays in an organization or with respect to the associating class. A Contact may have several Roles within scope, and as such,
    ///				associations to ContactRole allow the use of a Contact in a certain manner. Examples
    ///				might include a provider, or a data analyst. 
    /// </para>
    /// <para>
    /// Regular expression: (Role)
    /// </para>
    /// </summary>
    public partial class ContactRoleType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName RoleXName = System.Xml.Linq.XName.Get("Role", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName contact_refXName = System.Xml.Linq.XName.Get("contact_ref", "");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("ContactRoleType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator ContactRoleType(XElement xe) { return XTypedServices.ToXTypedElement<ContactRoleType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static ContactRoleType() {
            BuildElementDictionary();
            contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(RoleXName));
        }
        
        /// <summary>
        /// <para>
        /// The role that a Contact plays in an organization or with respect to the associating class. A Contact may have several Roles within scope, and as such,
        ///				associations to ContactRole allow the use of a Contact in a certain manner. Examples
        ///				might include a provider, or a data analyst. 
        /// </para>
        /// <para>
        /// Regular expression: (Role)
        /// </para>
        /// </summary>
        public ContactRoleType() {
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// <para>
        /// Regular expression: (Role)
        /// </para>
        /// </summary>
        public virtual RoleType Role {
            get {
                XElement x = this.GetElement(RoleXName);
                return ((RoleType)(x));
            }
            set {
                this.SetElement(RoleXName, value);
            }
        }
        
        /// <summary>
        /// <para>
        /// When a ContactRole is used, it specifies which Contact the role is associated with. 
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual string contact_ref {
            get {
                XAttribute x = this.Attribute(contact_refXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
            set {
                this.SetAttribute(contact_refXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<ContactRoleType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(RoleXName, typeof(RoleType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    /// <summary>
    /// <para>
    /// The roles (lab equipment sales, contractor, etc.) the Contact fills.
    ///			
    /// </para>
    /// <para>
    /// Regular expression: (cvParam)
    /// </para>
    /// </summary>
    public partial class RoleType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName cvParamXName = System.Xml.Linq.XName.Get("cvParam", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("RoleType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator RoleType(XElement xe) { return XTypedServices.ToXTypedElement<RoleType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static RoleType() {
            BuildElementDictionary();
            contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(cvParamXName));
        }
        
        /// <summary>
        /// <para>
        /// The roles (lab equipment sales, contractor, etc.) the Contact fills.
        ///			
        /// </para>
        /// <para>
        /// Regular expression: (cvParam)
        /// </para>
        /// </summary>
        public RoleType() {
        }
        
        /// <summary>
        /// <para>
        /// CV term for contact roles, such as software provider.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// <para>
        /// Regular expression: (cvParam)
        /// </para>
        /// </summary>
        public virtual CVParamType cvParam {
            get {
                XElement x = this.GetElement(cvParamXName);
                return ((CVParamType)(x));
            }
            set {
                this.SetElement(cvParamXName, value);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<RoleType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(cvParamXName, typeof(CVParamType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    /// <summary>
    /// <para>
    /// Represents bibliographic references. 
    /// </para>
    /// </summary>
    public partial class BibliographicReferenceType : global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.IdentifiableType, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName authorsXName = System.Xml.Linq.XName.Get("authors", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName publicationXName = System.Xml.Linq.XName.Get("publication", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName publisherXName = System.Xml.Linq.XName.Get("publisher", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName editorXName = System.Xml.Linq.XName.Get("editor", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName yearXName = System.Xml.Linq.XName.Get("year", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName volumeXName = System.Xml.Linq.XName.Get("volume", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName issueXName = System.Xml.Linq.XName.Get("issue", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName pagesXName = System.Xml.Linq.XName.Get("pages", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName titleXName = System.Xml.Linq.XName.Get("title", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName doiXName = System.Xml.Linq.XName.Get("doi", "");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("BibliographicReferenceType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
		public static explicit operator BibliographicReferenceType(XElement xe) { return XTypedServices.ToXTypedElement<BibliographicReferenceType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        /// <summary>
        /// <para>
        /// Represents bibliographic references. 
        /// </para>
        /// </summary>
        public BibliographicReferenceType() {
        }
        
        /// <summary>
        /// <para>
        /// The names of the authors of the reference.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string authors {
            get {
                XAttribute x = this.Attribute(authorsXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(authorsXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The name of the journal, book etc.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string publication {
            get {
                XAttribute x = this.Attribute(publicationXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(publicationXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The publisher of the publication.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string publisher {
            get {
                XAttribute x = this.Attribute(publisherXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(publisherXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The editor(s) of the reference.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string editor {
            get {
                XAttribute x = this.Attribute(editorXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(editorXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The year of publication.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual System.Int32? year {
            get {
                XAttribute x = this.Attribute(yearXName);
                if ((x == null)) {
                    return null;
                }
                return XTypedServices.ParseValue<int>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Int).Datatype);
            }
            set {
                this.SetAttribute(yearXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Int).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The volume name or number.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string volume {
            get {
                XAttribute x = this.Attribute(volumeXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(volumeXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The issue name or number.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string issue {
            get {
                XAttribute x = this.Attribute(issueXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(issueXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The page numbers.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string pages {
            get {
                XAttribute x = this.Attribute(pagesXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(pagesXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The title of the BibliographicReference.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string title {
            get {
                XAttribute x = this.Attribute(titleXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(titleXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The DOI of the referenced publication.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string doi {
            get {
                XAttribute x = this.Attribute(doiXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(doiXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<BibliographicReferenceType>(this);
        }
    }
    
    /// <summary>
    /// <para>
    /// The complete set of Contacts (people and organisations) for this file. 
    /// </para>
    /// <para>
    /// Regular expression: (Person*, Organization*)
    /// </para>
    /// </summary>
    public partial class AuditCollectionType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName PersonXName = System.Xml.Linq.XName.Get("Person", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<PersonType> PersonField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName OrganizationXName = System.Xml.Linq.XName.Get("Organization", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<OrganizationType> OrganizationField;
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("AuditCollectionType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator AuditCollectionType(XElement xe) { return XTypedServices.ToXTypedElement<AuditCollectionType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static AuditCollectionType() {
            BuildElementDictionary();
            contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(PersonXName), new NamedContentModelEntity(OrganizationXName));
        }
        
        /// <summary>
        /// <para>
        /// The complete set of Contacts (people and organisations) for this file. 
        /// </para>
        /// <para>
        /// Regular expression: (Person*, Organization*)
        /// </para>
        /// </summary>
        public AuditCollectionType() {
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional, repeating
        /// </para>
        /// <para>
        /// Regular expression: (Person*, Organization*)
        /// </para>
        /// </summary>
        public virtual IList<PersonType> Person {
            get {
                if ((this.PersonField == null)) {
                    this.PersonField = new XTypedList<PersonType>(this, LinqToXsdTypeManager.Instance, PersonXName);
                }
                return this.PersonField;
            }
            set {
                if ((value == null)) {
                    this.PersonField = null;
                }
                else {
                    if ((this.PersonField == null)) {
                        this.PersonField = XTypedList<PersonType>.Initialize(this, LinqToXsdTypeManager.Instance, value, PersonXName);
                    }
                    else {
                        XTypedServices.SetList<PersonType>(this.PersonField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional, repeating
        /// </para>
        /// <para>
        /// Regular expression: (Person*, Organization*)
        /// </para>
        /// </summary>
        public virtual IList<OrganizationType> Organization {
            get {
                if ((this.OrganizationField == null)) {
                    this.OrganizationField = new XTypedList<OrganizationType>(this, LinqToXsdTypeManager.Instance, OrganizationXName);
                }
                return this.OrganizationField;
            }
            set {
                if ((value == null)) {
                    this.OrganizationField = null;
                }
                else {
                    if ((this.OrganizationField == null)) {
                        this.OrganizationField = XTypedList<OrganizationType>.Initialize(this, LinqToXsdTypeManager.Instance, value, OrganizationXName);
                    }
                    else {
                        XTypedServices.SetList<OrganizationType>(this.OrganizationField, value);
                    }
                }
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<AuditCollectionType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(PersonXName, typeof(PersonType));
            localElementDictionary.Add(OrganizationXName, typeof(OrganizationType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    /// <summary>
    /// <para>
    /// Other classes in the model can be specified as sub-classes, inheriting from Identifiable. Identifiable gives classes a unique identifier within the scope and a name that need not be unique. 
    /// </para>
    /// </summary>
    public abstract partial class IdentifiableType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName idXName = System.Xml.Linq.XName.Get("id", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName nameXName = System.Xml.Linq.XName.Get("name", "");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("IdentifiableType", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
		public static explicit operator IdentifiableType(XElement xe) {  return (IdentifiableType)XTypedServices.ToXTypedElement(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        /// <summary>
        /// <para>
        /// Other classes in the model can be specified as sub-classes, inheriting from Identifiable. Identifiable gives classes a unique identifier within the scope and a name that need not be unique. 
        /// </para>
        /// </summary>
        public IdentifiableType() {
        }
        
        /// <summary>
        /// <para>
        /// An identifier is an unambiguous string that is unique within the scope (i.e. a document, a set of related documents, or a repository) of its use.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual string id {
            get {
                XAttribute x = this.Attribute(idXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Id).Datatype);
            }
            set {
                this.SetAttribute(idXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Id).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The potentially ambiguous common identifier, such as a human-readable name for the instance. 
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string name {
            get {
                XAttribute x = this.Attribute(nameXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(nameXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
    }
    
    public sealed class versionRegex {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(8)), null, 0, 0, null, null, 0, null, null, 0, new string[] {
                        "(1\\.0\\.\\d+)"}, 0, XmlSchemaWhiteSpace.Preserve));
        
        private versionRegex() {
        }
    }
    
    public sealed class listOfIntegers {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.ListSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.AnyAtomicType), null, psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.integerOrNullType.TypeDefinition);
        
        private listOfIntegers() {
        }
    }
    
    public sealed class listOfFloats {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.ListSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Float), null, new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Float), null));
        
        private listOfFloats() {
        }
    }
    
    public sealed class listOfStrings {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.ListSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), null, new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), null));
        
        private listOfStrings() {
        }
    }
    
    public sealed class listOfChars {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.ListSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), null, psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.chars.TypeDefinition);
        
        private listOfChars() {
        }
    }
    
    public sealed class chars {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(8)), null, 0, 0, null, null, 0, null, null, 0, new string[] {
                        "[ABCDEFGHIJKLMNOPQRSTUVWXYZ]{1}"}, 0, XmlSchemaWhiteSpace.Preserve));
        
        private chars() {
        }
    }
    
    public sealed class sequence {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(8)), null, 0, 0, null, null, 0, null, null, 0, new string[] {
                        "[ABCDEFGHIJKLMNOPQRSTUVWXYZ]*"}, 0, XmlSchemaWhiteSpace.Preserve));
        
        private sequence() {
        }
    }
    
    /// <summary>
    /// <para>
    /// Root element of the instance document.
    /// </para>
    /// </summary>
    public partial class MzQuantML : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private MzQuantMLType ContentField;
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("MzQuantML", "http://psidev.info/psi/pi/mzQuantML/1.0.0");
        
		public static explicit operator MzQuantML(XElement xe) { return XTypedServices.ToXTypedElement<MzQuantML, MzQuantMLType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        /// <summary>
        /// <para>
        /// Root element of the instance document.
        /// </para>
        /// </summary>
        public MzQuantML() {
            SetInnerType(new MzQuantMLType());
        }
        
        /// <summary>
        /// <para>
        /// Root element of the instance document.
        /// </para>
        /// </summary>
        public MzQuantML(MzQuantMLType content) {
            SetInnerType(content);
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public virtual MzQuantMLType Content {
            get {
                return ContentField;
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// <para>
        /// Regular expression: (CvList, Provider?, AuditCollection?, AnalysisSummary, InputFiles, SoftwareList, DataProcessingList, BibliographicReference*, AssayList, StudyVariableList?, RatioList?, ProteinGroupList?, ProteinList?, PeptideConsensusList*, SmallMoleculeList?, FeatureList*)
        /// </para>
        /// </summary>
        public virtual CvListType CvList {
            get {
                return this.ContentField.CvList;
            }
            set {
                this.ContentField.CvList = value;
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// <para>
        /// Regular expression: (CvList, Provider?, AuditCollection?, AnalysisSummary, InputFiles, SoftwareList, DataProcessingList, BibliographicReference*, AssayList, StudyVariableList?, RatioList?, ProteinGroupList?, ProteinList?, PeptideConsensusList*, SmallMoleculeList?, FeatureList*)
        /// </para>
        /// </summary>
        public virtual ProviderType Provider {
            get {
                return this.ContentField.Provider;
            }
            set {
                this.ContentField.Provider = value;
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// <para>
        /// Regular expression: (CvList, Provider?, AuditCollection?, AnalysisSummary, InputFiles, SoftwareList, DataProcessingList, BibliographicReference*, AssayList, StudyVariableList?, RatioList?, ProteinGroupList?, ProteinList?, PeptideConsensusList*, SmallMoleculeList?, FeatureList*)
        /// </para>
        /// </summary>
        public virtual AuditCollectionType AuditCollection {
            get {
                return this.ContentField.AuditCollection;
            }
            set {
                this.ContentField.AuditCollection = value;
            }
        }
        
        /// <summary>
        /// <para>
        /// Summary information about the analysis in terms of the type of analysis, any global scores or metrics and global thresholds used.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// <para>
        /// Regular expression: (CvList, Provider?, AuditCollection?, AnalysisSummary, InputFiles, SoftwareList, DataProcessingList, BibliographicReference*, AssayList, StudyVariableList?, RatioList?, ProteinGroupList?, ProteinList?, PeptideConsensusList*, SmallMoleculeList?, FeatureList*)
        /// </para>
        /// </summary>
        public virtual ParamListType AnalysisSummary {
            get {
                return this.ContentField.AnalysisSummary;
            }
            set {
                this.ContentField.AnalysisSummary = value;
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// <para>
        /// Regular expression: (CvList, Provider?, AuditCollection?, AnalysisSummary, InputFiles, SoftwareList, DataProcessingList, BibliographicReference*, AssayList, StudyVariableList?, RatioList?, ProteinGroupList?, ProteinList?, PeptideConsensusList*, SmallMoleculeList?, FeatureList*)
        /// </para>
        /// </summary>
        public virtual InputFilesType InputFiles {
            get {
                return this.ContentField.InputFiles;
            }
            set {
                this.ContentField.InputFiles = value;
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// <para>
        /// Regular expression: (CvList, Provider?, AuditCollection?, AnalysisSummary, InputFiles, SoftwareList, DataProcessingList, BibliographicReference*, AssayList, StudyVariableList?, RatioList?, ProteinGroupList?, ProteinList?, PeptideConsensusList*, SmallMoleculeList?, FeatureList*)
        /// </para>
        /// </summary>
        public virtual SoftwareListType SoftwareList {
            get {
                return this.ContentField.SoftwareList;
            }
            set {
                this.ContentField.SoftwareList = value;
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// <para>
        /// Regular expression: (CvList, Provider?, AuditCollection?, AnalysisSummary, InputFiles, SoftwareList, DataProcessingList, BibliographicReference*, AssayList, StudyVariableList?, RatioList?, ProteinGroupList?, ProteinList?, PeptideConsensusList*, SmallMoleculeList?, FeatureList*)
        /// </para>
        /// </summary>
        public virtual DataProcessingListType DataProcessingList {
            get {
                return this.ContentField.DataProcessingList;
            }
            set {
                this.ContentField.DataProcessingList = value;
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional, repeating
        /// </para>
        /// <para>
        /// Regular expression: (CvList, Provider?, AuditCollection?, AnalysisSummary, InputFiles, SoftwareList, DataProcessingList, BibliographicReference*, AssayList, StudyVariableList?, RatioList?, ProteinGroupList?, ProteinList?, PeptideConsensusList*, SmallMoleculeList?, FeatureList*)
        /// </para>
        /// </summary>
        public virtual IList<BibliographicReferenceType> BibliographicReference {
            get {
                return this.ContentField.BibliographicReference;
            }
            set {
                this.ContentField.BibliographicReference = value;
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// <para>
        /// Regular expression: (CvList, Provider?, AuditCollection?, AnalysisSummary, InputFiles, SoftwareList, DataProcessingList, BibliographicReference*, AssayList, StudyVariableList?, RatioList?, ProteinGroupList?, ProteinList?, PeptideConsensusList*, SmallMoleculeList?, FeatureList*)
        /// </para>
        /// </summary>
        public virtual AssayListType AssayList {
            get {
                return this.ContentField.AssayList;
            }
            set {
                this.ContentField.AssayList = value;
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// <para>
        /// Regular expression: (CvList, Provider?, AuditCollection?, AnalysisSummary, InputFiles, SoftwareList, DataProcessingList, BibliographicReference*, AssayList, StudyVariableList?, RatioList?, ProteinGroupList?, ProteinList?, PeptideConsensusList*, SmallMoleculeList?, FeatureList*)
        /// </para>
        /// </summary>
        public virtual StudyVariableListType StudyVariableList {
            get {
                return this.ContentField.StudyVariableList;
            }
            set {
                this.ContentField.StudyVariableList = value;
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// <para>
        /// Regular expression: (CvList, Provider?, AuditCollection?, AnalysisSummary, InputFiles, SoftwareList, DataProcessingList, BibliographicReference*, AssayList, StudyVariableList?, RatioList?, ProteinGroupList?, ProteinList?, PeptideConsensusList*, SmallMoleculeList?, FeatureList*)
        /// </para>
        /// </summary>
        public virtual RatioListType RatioList {
            get {
                return this.ContentField.RatioList;
            }
            set {
                this.ContentField.RatioList = value;
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// <para>
        /// Regular expression: (CvList, Provider?, AuditCollection?, AnalysisSummary, InputFiles, SoftwareList, DataProcessingList, BibliographicReference*, AssayList, StudyVariableList?, RatioList?, ProteinGroupList?, ProteinList?, PeptideConsensusList*, SmallMoleculeList?, FeatureList*)
        /// </para>
        /// </summary>
        public virtual ProteinGroupListType ProteinGroupList {
            get {
                return this.ContentField.ProteinGroupList;
            }
            set {
                this.ContentField.ProteinGroupList = value;
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// <para>
        /// Regular expression: (CvList, Provider?, AuditCollection?, AnalysisSummary, InputFiles, SoftwareList, DataProcessingList, BibliographicReference*, AssayList, StudyVariableList?, RatioList?, ProteinGroupList?, ProteinList?, PeptideConsensusList*, SmallMoleculeList?, FeatureList*)
        /// </para>
        /// </summary>
        public virtual ProteinListType ProteinList {
            get {
                return this.ContentField.ProteinList;
            }
            set {
                this.ContentField.ProteinList = value;
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional, repeating
        /// </para>
        /// <para>
        /// Regular expression: (CvList, Provider?, AuditCollection?, AnalysisSummary, InputFiles, SoftwareList, DataProcessingList, BibliographicReference*, AssayList, StudyVariableList?, RatioList?, ProteinGroupList?, ProteinList?, PeptideConsensusList*, SmallMoleculeList?, FeatureList*)
        /// </para>
        /// </summary>
        public virtual IList<PeptideConsensusListType> PeptideConsensusList {
            get {
                return this.ContentField.PeptideConsensusList;
            }
            set {
                this.ContentField.PeptideConsensusList = value;
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// <para>
        /// Regular expression: (CvList, Provider?, AuditCollection?, AnalysisSummary, InputFiles, SoftwareList, DataProcessingList, BibliographicReference*, AssayList, StudyVariableList?, RatioList?, ProteinGroupList?, ProteinList?, PeptideConsensusList*, SmallMoleculeList?, FeatureList*)
        /// </para>
        /// </summary>
        public virtual SmallMoleculeListType SmallMoleculeList {
            get {
                return this.ContentField.SmallMoleculeList;
            }
            set {
                this.ContentField.SmallMoleculeList = value;
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional, repeating
        /// </para>
        /// <para>
        /// Regular expression: (CvList, Provider?, AuditCollection?, AnalysisSummary, InputFiles, SoftwareList, DataProcessingList, BibliographicReference*, AssayList, StudyVariableList?, RatioList?, ProteinGroupList?, ProteinList?, PeptideConsensusList*, SmallMoleculeList?, FeatureList*)
        /// </para>
        /// </summary>
        public virtual IList<FeatureListType> FeatureList {
            get {
                return this.ContentField.FeatureList;
            }
            set {
                this.ContentField.FeatureList = value;
            }
        }
        
        /// <summary>
        /// <para>
        /// The date on which the file was produced.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual System.DateTime? creationDate {
            get {
                return this.ContentField.creationDate;
            }
            set {
                this.ContentField.creationDate = value;
            }
        }
        
        /// <summary>
        /// <para>
        /// The version of the schema this instance document refers to, in the format x.y.z. Changes to z should not affect prevent instance documents from validating. 
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual string version {
            get {
                return this.ContentField.version;
            }
            set {
                this.ContentField.version = value;
            }
        }
        
        /// <summary>
        /// <para>
        /// The unique identifier for the mzQuantML file or experiment.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual string id {
            get {
                return this.ContentField.id;
            }
            set {
                this.ContentField.id = value;
            }
        }
        
        /// <summary>
        /// <para>
        /// Optional name for the file or experiment.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string name {
            get {
                return this.ContentField.name;
            }
            set {
                this.ContentField.name = value;
            }
        }
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public void Save(string xmlFile) {
            XTypedServices.Save(xmlFile, Untyped);
        }
        
        public void Save(System.IO.TextWriter tw) {
            XTypedServices.Save(tw, Untyped);
        }
        
        public void Save(System.Xml.XmlWriter xmlWriter) {
            XTypedServices.Save(xmlWriter, Untyped);
        }
        
        public static MzQuantML Load(string xmlFile) {
            return XTypedServices.Load<MzQuantML, MzQuantMLType>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static MzQuantML Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<MzQuantML, MzQuantMLType>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static MzQuantML Parse(string xml) {
            return XTypedServices.Parse<MzQuantML, MzQuantMLType>(xml, LinqToXsdTypeManager.Instance);
        }
        
        public override XTypedElement Clone() {
            return new MzQuantML(((MzQuantMLType)(this.Content.Clone())));
        }
        
        private void SetInnerType(MzQuantMLType ContentField) {
            this.ContentField = ((MzQuantMLType)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
    }
    
    public class LinqToXsdTypeManager : ILinqToXsdTypeManager {
        
        private static Dictionary<System.Xml.Linq.XName, System.Type> typeDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        private static Dictionary<System.Xml.Linq.XName, System.Type> elementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        private static Dictionary<System.Type, System.Type> wrapperDictionary = new Dictionary<System.Type, System.Type>();
        
        private static XmlSchemaSet schemaSet;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static LinqToXsdTypeManager typeManagerSingleton = new LinqToXsdTypeManager();
        
        static LinqToXsdTypeManager() {
            BuildTypeDictionary();
            BuildElementDictionary();
            BuildWrapperDictionary();
        }
        
        private LinqToXsdTypeManager() {
        }
        
        XmlSchemaSet ILinqToXsdTypeManager.Schemas {
            get {
                if ((schemaSet == null)) {
                    XmlSchemaSet tempSet = new XmlSchemaSet();
                    System.Threading.Interlocked.CompareExchange(ref schemaSet, tempSet, null);
                }
                return schemaSet;
            }
            set {
                schemaSet = value;
            }
        }
        
        Dictionary<System.Xml.Linq.XName, System.Type> ILinqToXsdTypeManager.GlobalTypeDictionary {
            get {
                return typeDictionary;
            }
        }
        
        Dictionary<System.Xml.Linq.XName, System.Type> ILinqToXsdTypeManager.GlobalElementDictionary {
            get {
                return elementDictionary;
            }
        }
        
        Dictionary<System.Type, System.Type> ILinqToXsdTypeManager.RootContentTypeMapping {
            get {
                return wrapperDictionary;
            }
        }
        
        public static LinqToXsdTypeManager Instance {
            get {
                return typeManagerSingleton;
            }
        }
        
        private static void BuildTypeDictionary() {
            typeDictionary.Add(System.Xml.Linq.XName.Get("MzQuantMLType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.MzQuantMLType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("CvListType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.CvListType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("InputFilesType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.InputFilesType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("SearchDatabaseType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.SearchDatabaseType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("SourceFileType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.SourceFileType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("StudyVariableListType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.StudyVariableListType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("CvType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.CvType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("RatioListType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.RatioListType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("ProteinGroupListType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.ProteinGroupListType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("ProteinListType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.ProteinListType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("ProteinGroupType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.ProteinGroupType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("ProteinRefType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.ProteinRefType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("ProteinType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.ProteinType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("IdentificationRefType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.IdentificationRefType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("EvidenceRefType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.EvidenceRefType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("DBIdentificationRefType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.DBIdentificationRefType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("PeptideConsensusListType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.PeptideConsensusListType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("SmallMoleculeListType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.SmallMoleculeListType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("PeptideConsensusType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.PeptideConsensusType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("SmallMoleculeType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.SmallMoleculeType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("ModificationType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.ModificationType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("SmallMolModificationType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.SmallMolModificationType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("QuantLayerType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.QuantLayerType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("RatioQuantLayerType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.RatioQuantLayerType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("GlobalQuantLayerType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.GlobalQuantLayerType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("ColumnDefinitionType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.ColumnDefinitionType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("ColumnType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.ColumnType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("DataMatrixType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.DataMatrixType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("RowType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.RowType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("StudyVariableType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.StudyVariableType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("AssayListType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.AssayListType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("AssayType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.AssayType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("RawFilesGroupType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.RawFilesGroupType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("RawFileType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.RawFileType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("IdentificationFilesType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.IdentificationFilesType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("IdentificationFileType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.IdentificationFileType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("MethodFilesType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.MethodFilesType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("MethodFileType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.MethodFileType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("LabelType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.LabelType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("RatioType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.RatioType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("FeatureListType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.FeatureListType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("FeatureType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.FeatureType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("ModParamType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.ModParamType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("DataProcessingListType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.DataProcessingListType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("DataProcessingType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.DataProcessingType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("ProcessingMethodType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.ProcessingMethodType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("SoftwareListType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.SoftwareListType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("SoftwareType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.SoftwareType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("cvParamRefType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.cvParamRefType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("CVParamType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.CVParamType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("AbstractParamType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.AbstractParamType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("UserParamType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.UserParamType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("ParamListType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.ParamListType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("ParamType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.ParamType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("ExternalDataType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.ExternalDataType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("FileFormatType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.FileFormatType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("ProviderType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.ProviderType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("PersonType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.PersonType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("AffiliationType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.AffiliationType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("OrganizationType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.OrganizationType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("ParentOrganizationType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.ParentOrganizationType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("AbstractContactType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.AbstractContactType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("ContactRoleType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.ContactRoleType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("RoleType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.RoleType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("BibliographicReferenceType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.BibliographicReferenceType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("AuditCollectionType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.AuditCollectionType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("IdentifiableType", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.IdentifiableType));
        }
        
        private static void BuildElementDictionary() {
            elementDictionary.Add(System.Xml.Linq.XName.Get("MzQuantML", "http://psidev.info/psi/pi/mzQuantML/1.0.0"), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.MzQuantML));
        }
        
        private static void BuildWrapperDictionary() {
            wrapperDictionary.Add(typeof(psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.MzQuantML), typeof(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.MzQuantMLType));
        }
        
        protected internal static void AddSchemas(XmlSchemaSet schemas) {
            schemas.Add(schemaSet);
        }
        
        public static System.Type GetRootType() {
            return elementDictionary[System.Xml.Linq.XName.Get("MzQuantML", "http://psidev.info/psi/pi/mzQuantML/1.0.0")];
        }
    }
    
    public partial class XRootNamespace {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XDocument doc;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedElement rootObject;
        

		public MzQuantML MzQuantML {  get {return rootObject as MzQuantML; } }
        
        private XRootNamespace() {
        }
        
        public XRootNamespace(MzQuantML root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        
        public virtual XDocument XDocument {
            get {
                return doc;
            }
        }
        
        public virtual XTypedElement Root {
            get {
                return rootObject;
            }
        }
        
        public static XRootNamespace Load(string xmlFile) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Load(xmlFile);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRootNamespace Load(string xmlFile, LoadOptions options) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Load(xmlFile, options);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRootNamespace Load(TextReader textReader) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Load(textReader);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRootNamespace Load(TextReader textReader, LoadOptions options) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Load(textReader, options);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRootNamespace Load(XmlReader xmlReader) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Load(xmlReader);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRootNamespace Parse(string text) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Parse(text);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRootNamespace Parse(string text, LoadOptions options) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Parse(text, options);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public virtual void Save(string fileName) {
            doc.Save(fileName);
        }
        
        public virtual void Save(TextWriter textWriter) {
            doc.Save(textWriter);
        }
        
        public virtual void Save(XmlWriter writer) {
            doc.Save(writer);
        }
        
        public virtual void Save(TextWriter textWriter, SaveOptions options) {
            doc.Save(textWriter, options);
        }
        
        public virtual void Save(string fileName, SaveOptions options) {
            doc.Save(fileName, options);
        }
    }
    
    public partial class XRoot {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XDocument doc;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedElement rootObject;
        

		public global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.MzQuantML MzQuantML {  get {return rootObject as global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.MzQuantML; } }
        
        private XRoot() {
        }
        
        public XRoot(global::psidev.info.psi.pi.mzQuantML.Item1.Item0.Item0.MzQuantML root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        
        public virtual XDocument XDocument {
            get {
                return doc;
            }
        }
        
        public virtual XTypedElement Root {
            get {
                return rootObject;
            }
        }
        
        public static XRoot Load(string xmlFile) {
            XRoot root = new XRoot();
            root.doc = XDocument.Load(xmlFile);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRoot Load(string xmlFile, LoadOptions options) {
            XRoot root = new XRoot();
            root.doc = XDocument.Load(xmlFile, options);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRoot Load(TextReader textReader) {
            XRoot root = new XRoot();
            root.doc = XDocument.Load(textReader);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRoot Load(TextReader textReader, LoadOptions options) {
            XRoot root = new XRoot();
            root.doc = XDocument.Load(textReader, options);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRoot Load(XmlReader xmlReader) {
            XRoot root = new XRoot();
            root.doc = XDocument.Load(xmlReader);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRoot Parse(string text) {
            XRoot root = new XRoot();
            root.doc = XDocument.Parse(text);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRoot Parse(string text, LoadOptions options) {
            XRoot root = new XRoot();
            root.doc = XDocument.Parse(text, options);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public virtual void Save(string fileName) {
            doc.Save(fileName);
        }
        
        public virtual void Save(TextWriter textWriter) {
            doc.Save(textWriter);
        }
        
        public virtual void Save(XmlWriter writer) {
            doc.Save(writer);
        }
        
        public virtual void Save(TextWriter textWriter, SaveOptions options) {
            doc.Save(textWriter, options);
        }
        
        public virtual void Save(string fileName, SaveOptions options) {
            doc.Save(fileName, options);
        }
    }
}
