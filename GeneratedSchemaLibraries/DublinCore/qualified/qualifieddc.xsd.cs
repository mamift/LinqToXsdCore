//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace W3C.XmlNs3 {
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.IO;
    using System.Linq;
    using System.Diagnostics;
    using System.Xml;
    using System.Xml.Schema;
    using System.Xml.Linq;
    using Xml.Schema.Linq;
    using purl.org.dc.qualifiedContainer;
    
    
    public sealed class lang {
        
        private lang() {
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.UnionSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.AnyAtomicType), null, new Xml.Schema.Linq.SimpleTypeValidator[] {
                    new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Language), null),
                    new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                                    ""}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve))});
    }
}
namespace purl.org.dc.termsQualified {
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.IO;
    using System.Linq;
    using System.Diagnostics;
    using System.Xml;
    using System.Xml.Schema;
    using System.Xml.Linq;
    using Xml.Schema.Linq;
    using purl.org.dc.qualifiedContainer;
    
    
    public partial class LCSH : global::purl.org.dc.elementsQualified.SimpleLiteral, IXMetaData {
        
		public static explicit operator LCSH(XElement xe) { return XTypedServices.ToXTypedElement<LCSH>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<LCSH>(this);
        }
        
        public LCSH() {
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName TypedValueXName = System.Xml.Linq.XName.Get("TypedValue", "");
        
        public virtual string TypedValue {
            get {
                XElement x = this.Untyped;
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetValueWithValidation(value, "TypedValue", LCSHLocalType.TypeDefinition);
            }
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("LCSH", "http://purl.org/dc/terms/");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        private class LCSHLocalType {
            
            private LCSHLocalType() {
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), null);
        }
    }
    
    public partial class MESH : global::purl.org.dc.elementsQualified.SimpleLiteral, IXMetaData {
        
		public static explicit operator MESH(XElement xe) { return XTypedServices.ToXTypedElement<MESH>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<MESH>(this);
        }
        
        public MESH() {
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName TypedValueXName = System.Xml.Linq.XName.Get("TypedValue", "");
        
        public virtual string TypedValue {
            get {
                XElement x = this.Untyped;
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetValueWithValidation(value, "TypedValue", MESHLocalType.TypeDefinition);
            }
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("MESH", "http://purl.org/dc/terms/");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        private class MESHLocalType {
            
            private MESHLocalType() {
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), null);
        }
    }
    
    public partial class DDC : global::purl.org.dc.elementsQualified.SimpleLiteral, IXMetaData {
        
		public static explicit operator DDC(XElement xe) { return XTypedServices.ToXTypedElement<DDC>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<DDC>(this);
        }
        
        public DDC() {
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName TypedValueXName = System.Xml.Linq.XName.Get("TypedValue", "");
        
        public virtual string TypedValue {
            get {
                XElement x = this.Untyped;
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetValueWithValidation(value, "TypedValue", DDCLocalType.TypeDefinition);
            }
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("DDC", "http://purl.org/dc/terms/");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        private class DDCLocalType {
            
            private DDCLocalType() {
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), null);
        }
    }
    
    public partial class LCC : global::purl.org.dc.elementsQualified.SimpleLiteral, IXMetaData {
        
		public static explicit operator LCC(XElement xe) { return XTypedServices.ToXTypedElement<LCC>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<LCC>(this);
        }
        
        public LCC() {
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName TypedValueXName = System.Xml.Linq.XName.Get("TypedValue", "");
        
        public virtual string TypedValue {
            get {
                XElement x = this.Untyped;
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetValueWithValidation(value, "TypedValue", LCCLocalType.TypeDefinition);
            }
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("LCC", "http://purl.org/dc/terms/");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        private class LCCLocalType {
            
            private LCCLocalType() {
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), null);
        }
    }
    
    public partial class UDC : global::purl.org.dc.elementsQualified.SimpleLiteral, IXMetaData {
        
		public static explicit operator UDC(XElement xe) { return XTypedServices.ToXTypedElement<UDC>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<UDC>(this);
        }
        
        public UDC() {
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName TypedValueXName = System.Xml.Linq.XName.Get("TypedValue", "");
        
        public virtual string TypedValue {
            get {
                XElement x = this.Untyped;
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetValueWithValidation(value, "TypedValue", UDCLocalType.TypeDefinition);
            }
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("UDC", "http://purl.org/dc/terms/");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        private class UDCLocalType {
            
            private UDCLocalType() {
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), null);
        }
    }
    
    public partial class Period : global::purl.org.dc.elementsQualified.SimpleLiteral, IXMetaData {
        
		public static explicit operator Period(XElement xe) { return XTypedServices.ToXTypedElement<Period>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<Period>(this);
        }
        
        public Period() {
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName TypedValueXName = System.Xml.Linq.XName.Get("TypedValue", "");
        
        public virtual string TypedValue {
            get {
                XElement x = this.Untyped;
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetValueWithValidation(value, "TypedValue", PeriodLocalType.TypeDefinition);
            }
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("Period", "http://purl.org/dc/terms/");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        private class PeriodLocalType {
            
            private PeriodLocalType() {
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), null);
        }
    }
    
    public partial class W3CDTF : global::purl.org.dc.elementsQualified.SimpleLiteral, IXMetaData {
        
		public static explicit operator W3CDTF(XElement xe) { return XTypedServices.ToXTypedElement<W3CDTF>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<W3CDTF>(this);
        }
        
        public W3CDTF() {
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName TypedValueXName = System.Xml.Linq.XName.Get("TypedValue", "");
        
        public virtual string TypedValue {
            get {
                XElement x = this.Untyped;
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.AnyAtomicType).Datatype);
            }
            set {
                this.SetValueWithValidation(value, "TypedValue", W3CDTFLocalType.TypeDefinition);
            }
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("W3CDTF", "http://purl.org/dc/terms/");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        private class W3CDTFLocalType {
            
            private W3CDTFLocalType() {
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.UnionSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.AnyAtomicType), null, new Xml.Schema.Linq.SimpleTypeValidator[0]);
        }
    }
    
    public partial class DCMIType : global::purl.org.dc.elementsQualified.SimpleLiteral, IXMetaData {
        
		public static explicit operator DCMIType(XElement xe) { return XTypedServices.ToXTypedElement<DCMIType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<DCMIType>(this);
        }
        
        public DCMIType() {
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName TypedValueXName = System.Xml.Linq.XName.Get("TypedValue", "");
        
        public virtual string TypedValue {
            get {
                XElement x = this.Untyped;
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.AnyAtomicType).Datatype);
            }
            set {
                this.SetValueWithValidation(value, "TypedValue", DCMITypeLocalType.TypeDefinition);
            }
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("DCMIType", "http://purl.org/dc/terms/");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        private class DCMITypeLocalType {
            
            private DCMITypeLocalType() {
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.UnionSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.AnyAtomicType), null, new Xml.Schema.Linq.SimpleTypeValidator[0]);
        }
    }
    
    public partial class IMT : global::purl.org.dc.elementsQualified.SimpleLiteral, IXMetaData {
        
		public static explicit operator IMT(XElement xe) { return XTypedServices.ToXTypedElement<IMT>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<IMT>(this);
        }
        
        public IMT() {
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName TypedValueXName = System.Xml.Linq.XName.Get("TypedValue", "");
        
        public virtual string TypedValue {
            get {
                XElement x = this.Untyped;
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetValueWithValidation(value, "TypedValue", IMTLocalType.TypeDefinition);
            }
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("IMT", "http://purl.org/dc/terms/");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        private class IMTLocalType {
            
            private IMTLocalType() {
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), null);
        }
    }
    
    public partial class URI : global::purl.org.dc.elementsQualified.SimpleLiteral, IXMetaData {
        
		public static explicit operator URI(XElement xe) { return XTypedServices.ToXTypedElement<URI>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<URI>(this);
        }
        
        public URI() {
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName TypedValueXName = System.Xml.Linq.XName.Get("TypedValue", "");
        
        public virtual System.Uri TypedValue {
            get {
                XElement x = this.Untyped;
                return XTypedServices.ParseValue<System.Uri>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.AnyUri).Datatype);
            }
            set {
                this.SetValueWithValidation(value, "TypedValue", URILocalType.TypeDefinition);
            }
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("URI", "http://purl.org/dc/terms/");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        private class URILocalType {
            
            private URILocalType() {
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.AnyUri), null);
        }
    }
    
    public partial class ISO6392 : global::purl.org.dc.elementsQualified.SimpleLiteral, IXMetaData {
        
		public static explicit operator ISO6392(XElement xe) { return XTypedServices.ToXTypedElement<ISO6392>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<ISO6392>(this);
        }
        
        public ISO6392() {
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName TypedValueXName = System.Xml.Linq.XName.Get("TypedValue", "");
        
        public virtual string TypedValue {
            get {
                XElement x = this.Untyped;
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetValueWithValidation(value, "TypedValue", ISO6392LocalType.TypeDefinition);
            }
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("ISO639-2", "http://purl.org/dc/terms/");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        private class ISO6392LocalType {
            
            private ISO6392LocalType() {
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), null);
        }
    }
    
    public partial class ISO6393 : global::purl.org.dc.elementsQualified.SimpleLiteral, IXMetaData {
        
		public static explicit operator ISO6393(XElement xe) { return XTypedServices.ToXTypedElement<ISO6393>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<ISO6393>(this);
        }
        
        public ISO6393() {
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName TypedValueXName = System.Xml.Linq.XName.Get("TypedValue", "");
        
        public virtual string TypedValue {
            get {
                XElement x = this.Untyped;
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetValueWithValidation(value, "TypedValue", ISO6393LocalType.TypeDefinition);
            }
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("ISO639-3", "http://purl.org/dc/terms/");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        private class ISO6393LocalType {
            
            private ISO6393LocalType() {
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), null);
        }
    }
    
    public partial class RFC1766 : global::purl.org.dc.elementsQualified.SimpleLiteral, IXMetaData {
        
		public static explicit operator RFC1766(XElement xe) { return XTypedServices.ToXTypedElement<RFC1766>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<RFC1766>(this);
        }
        
        public RFC1766() {
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName TypedValueXName = System.Xml.Linq.XName.Get("TypedValue", "");
        
        public virtual string TypedValue {
            get {
                XElement x = this.Untyped;
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Language).Datatype);
            }
            set {
                this.SetValueWithValidation(value, "TypedValue", RFC1766LocalType.TypeDefinition);
            }
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("RFC1766", "http://purl.org/dc/terms/");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        private class RFC1766LocalType {
            
            private RFC1766LocalType() {
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Language), null);
        }
    }
    
    public partial class RFC3066 : global::purl.org.dc.elementsQualified.SimpleLiteral, IXMetaData {
        
		public static explicit operator RFC3066(XElement xe) { return XTypedServices.ToXTypedElement<RFC3066>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<RFC3066>(this);
        }
        
        public RFC3066() {
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName TypedValueXName = System.Xml.Linq.XName.Get("TypedValue", "");
        
        public virtual string TypedValue {
            get {
                XElement x = this.Untyped;
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Language).Datatype);
            }
            set {
                this.SetValueWithValidation(value, "TypedValue", RFC3066LocalType.TypeDefinition);
            }
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("RFC3066", "http://purl.org/dc/terms/");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        private class RFC3066LocalType {
            
            private RFC3066LocalType() {
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Language), null);
        }
    }
    
    public partial class RFC4646 : global::purl.org.dc.elementsQualified.SimpleLiteral, IXMetaData {
        
		public static explicit operator RFC4646(XElement xe) { return XTypedServices.ToXTypedElement<RFC4646>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<RFC4646>(this);
        }
        
        public RFC4646() {
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName TypedValueXName = System.Xml.Linq.XName.Get("TypedValue", "");
        
        public virtual string TypedValue {
            get {
                XElement x = this.Untyped;
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Language).Datatype);
            }
            set {
                this.SetValueWithValidation(value, "TypedValue", RFC4646LocalType.TypeDefinition);
            }
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("RFC4646", "http://purl.org/dc/terms/");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        private class RFC4646LocalType {
            
            private RFC4646LocalType() {
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Language), null);
        }
    }
    
    public partial class Point : global::purl.org.dc.elementsQualified.SimpleLiteral, IXMetaData {
        
		public static explicit operator Point(XElement xe) { return XTypedServices.ToXTypedElement<Point>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<Point>(this);
        }
        
        public Point() {
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName TypedValueXName = System.Xml.Linq.XName.Get("TypedValue", "");
        
        public virtual string TypedValue {
            get {
                XElement x = this.Untyped;
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetValueWithValidation(value, "TypedValue", PointLocalType.TypeDefinition);
            }
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("Point", "http://purl.org/dc/terms/");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        private class PointLocalType {
            
            private PointLocalType() {
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), null);
        }
    }
    
    public partial class ISO3166 : global::purl.org.dc.elementsQualified.SimpleLiteral, IXMetaData {
        
		public static explicit operator ISO3166(XElement xe) { return XTypedServices.ToXTypedElement<ISO3166>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<ISO3166>(this);
        }
        
        public ISO3166() {
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName TypedValueXName = System.Xml.Linq.XName.Get("TypedValue", "");
        
        public virtual string TypedValue {
            get {
                XElement x = this.Untyped;
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetValueWithValidation(value, "TypedValue", ISO3166LocalType.TypeDefinition);
            }
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("ISO3166", "http://purl.org/dc/terms/");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        private class ISO3166LocalType {
            
            private ISO3166LocalType() {
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), null);
        }
    }
    
    public partial class Box : global::purl.org.dc.elementsQualified.SimpleLiteral, IXMetaData {
        
		public static explicit operator Box(XElement xe) { return XTypedServices.ToXTypedElement<Box>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<Box>(this);
        }
        
        public Box() {
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName TypedValueXName = System.Xml.Linq.XName.Get("TypedValue", "");
        
        public virtual string TypedValue {
            get {
                XElement x = this.Untyped;
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetValueWithValidation(value, "TypedValue", BoxLocalType.TypeDefinition);
            }
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("Box", "http://purl.org/dc/terms/");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        private class BoxLocalType {
            
            private BoxLocalType() {
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), null);
        }
    }
    
    public partial class TGN : global::purl.org.dc.elementsQualified.SimpleLiteral, IXMetaData {
        
		public static explicit operator TGN(XElement xe) { return XTypedServices.ToXTypedElement<TGN>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<TGN>(this);
        }
        
        public TGN() {
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName TypedValueXName = System.Xml.Linq.XName.Get("TypedValue", "");
        
        public virtual string TypedValue {
            get {
                XElement x = this.Untyped;
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetValueWithValidation(value, "TypedValue", TGNLocalType.TypeDefinition);
            }
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("TGN", "http://purl.org/dc/terms/");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        private class TGNLocalType {
            
            private TGNLocalType() {
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), null);
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///    		This is included as a convenience for schema authors who need to define a root
    ///    		or container element for all of the DC elements and element refinements.
    ///    	
    /// </para>
    /// <para>
    /// Regular expression: (((any)*))
    /// </para>
    /// </summary>
    public partial class elementOrRefinementContainer : XTypedElement, IXMetaData {
        
		public static explicit operator elementOrRefinementContainer(XElement xe) { return XTypedServices.ToXTypedElement<elementOrRefinementContainer>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<elementOrRefinementContainer>(this);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///    		This is included as a convenience for schema authors who need to define a root
        ///    		or container element for all of the DC elements and element refinements.
        ///    	
        /// </para>
        /// <para>
        /// Regular expression: (((any)*))
        /// </para>
        /// </summary>
        public elementOrRefinementContainer() {
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName anyXName = System.Xml.Linq.XName.Get("any", "http://purl.org/dc/elements/1.1/");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedSubstitutedList<purl.org.dc.elementsQualified.any> anyField;
        
        /// <summary>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Setter: Appends
        /// </para>
        /// <para>
        /// Substitution members: any, title, creator, subject, description, publisher, contributor, date, type, format, identifier, source, language, relation, coverage, rights, alternative, tableOfContents, abstract, created, valid, available, issued, modified, dateAccepted, dateCopyrighted, dateSubmitted, extent, medium, isVersionOf, hasVersion, isReplacedBy, replaces, isRequiredBy, requires, isPartOf, hasPart, isReferencedBy, references, isFormatOf, hasFormat, conformsTo, spatial, temporal, audience, accrualMethod, accrualPeriodicity, accrualPolicy, instructionalMethod, provenance, rightsHolder, mediator, educationLevel, accessRights, license, bibliographicCitation, title, creator, subject, description, publisher, contributor, date, type, format, identifier, source, language, relation, coverage, rights
        /// </para>
        /// <para>
        /// Regular expression: (((any)*))
        /// </para>
        /// </summary>
        public virtual IList<purl.org.dc.elementsQualified.any> any {
            get {
                if ((this.anyField == null)) {
                    this.anyField = new XTypedSubstitutedList<purl.org.dc.elementsQualified.any>(this, LinqToXsdTypeManager.Instance, System.Xml.Linq.XName.Get("any", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("title", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("creator", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("subject", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("description", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("publisher", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("contributor", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("date", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("type", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("format", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("identifier", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("source", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("language", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("relation", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("coverage", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("rights", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("alternative", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("tableOfContents", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("abstract", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("created", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("valid", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("available", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("issued", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("modified", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("dateAccepted", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("dateCopyrighted", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("dateSubmitted", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("extent", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("medium", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("isVersionOf", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("hasVersion", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("isReplacedBy", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("replaces", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("isRequiredBy", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("requires", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("isPartOf", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("hasPart", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("isReferencedBy", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("references", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("isFormatOf", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("hasFormat", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("conformsTo", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("spatial", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("temporal", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("audience", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("accrualMethod", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("accrualPeriodicity", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("accrualPolicy", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("instructionalMethod", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("provenance", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("rightsHolder", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("mediator", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("educationLevel", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("accessRights", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("license", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("bibliographicCitation", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("title", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("creator", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("subject", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("description", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("publisher", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("contributor", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("date", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("type", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("format", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("identifier", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("source", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("language", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("relation", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("coverage", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("rights", "http://purl.org/dc/elements/1.1/"));
                }
                return this.anyField;
            }
            set {
                if ((value == null)) {
                    this.anyField = null;
                }
                else {
                    if ((this.anyField == null)) {
                        this.anyField = XTypedSubstitutedList<purl.org.dc.elementsQualified.any>.Initialize(this, LinqToXsdTypeManager.Instance, value, System.Xml.Linq.XName.Get("any", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("title", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("creator", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("subject", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("description", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("publisher", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("contributor", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("date", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("type", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("format", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("identifier", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("source", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("language", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("relation", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("coverage", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("rights", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("alternative", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("tableOfContents", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("abstract", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("created", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("valid", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("available", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("issued", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("modified", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("dateAccepted", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("dateCopyrighted", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("dateSubmitted", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("extent", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("medium", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("isVersionOf", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("hasVersion", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("isReplacedBy", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("replaces", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("isRequiredBy", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("requires", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("isPartOf", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("hasPart", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("isReferencedBy", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("references", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("isFormatOf", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("hasFormat", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("conformsTo", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("spatial", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("temporal", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("audience", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("accrualMethod", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("accrualPeriodicity", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("accrualPolicy", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("instructionalMethod", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("provenance", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("rightsHolder", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("mediator", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("educationLevel", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("accessRights", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("license", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("bibliographicCitation", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("title", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("creator", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("subject", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("description", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("publisher", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("contributor", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("date", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("type", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("format", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("identifier", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("source", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("language", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("relation", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("coverage", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("rights", "http://purl.org/dc/elements/1.1/"));
                    }
                    else {
                        XTypedServices.SetList<purl.org.dc.elementsQualified.any>(this.anyField, value);
                    }
                }
            }
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("elementOrRefinementContainer", "http://purl.org/dc/terms/");
        
        static elementOrRefinementContainer() {
            BuildElementDictionary();
            contentModel = new ChoiceContentModelEntity(new SequenceContentModelEntity(new ChoiceContentModelEntity(new SubstitutedContentModelEntity(System.Xml.Linq.XName.Get("any", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("title", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("creator", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("subject", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("description", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("publisher", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("contributor", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("date", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("type", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("format", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("identifier", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("source", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("language", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("relation", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("coverage", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("rights", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("alternative", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("tableOfContents", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("abstract", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("created", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("valid", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("available", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("issued", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("modified", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("dateAccepted", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("dateCopyrighted", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("dateSubmitted", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("extent", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("medium", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("isVersionOf", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("hasVersion", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("isReplacedBy", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("replaces", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("isRequiredBy", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("requires", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("isPartOf", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("hasPart", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("isReferencedBy", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("references", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("isFormatOf", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("hasFormat", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("conformsTo", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("spatial", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("temporal", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("audience", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("accrualMethod", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("accrualPeriodicity", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("accrualPolicy", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("instructionalMethod", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("provenance", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("rightsHolder", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("mediator", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("educationLevel", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("accessRights", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("license", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("bibliographicCitation", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("title", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("creator", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("subject", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("description", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("publisher", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("contributor", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("date", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("type", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("format", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("identifier", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("source", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("language", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("relation", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("coverage", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("rights", "http://purl.org/dc/elements/1.1/")))));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(anyXName, typeof(purl.org.dc.elementsQualified.any));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class title : global::purl.org.dc.elementsQualified.title, IXMetaData {
        
        public new static title Load(string xmlFile) {
            return ((title)(XTypedServices.ToXTypedElement(XElement.Load(xmlFile), LinqToXsdTypeManager.Instance)));
        }
        
        public static title Load(System.IO.TextReader xmlFile) {
            return ((title)(XTypedServices.ToXTypedElement(XElement.Load(xmlFile), LinqToXsdTypeManager.Instance)));
        }
        
        public new static title Parse(string xml) {
            return ((title)(XTypedServices.ToXTypedElement(XElement.Parse(xml), LinqToXsdTypeManager.Instance)));
        }
        
		public static explicit operator title(XElement xe) {  return (title)XTypedServices.ToXTypedElement(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new title(((purl.org.dc.elementsQualified.SimpleLiteral)(this.Content.Clone())));
        }
        
        protected title(bool setNull) : 
                base(true) {
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private purl.org.dc.elementsQualified.SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public title() : 
                base(true) {
            SetInnerType(new purl.org.dc.elementsQualified.SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                if ((this.ContentField != null)) {
                    this.ContentField.Untyped = value;
                }
            }
        }
        
        public new virtual purl.org.dc.elementsQualified.SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ((purl.org.dc.elementsQualified.SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        protected virtual void SetSubstitutionMember(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ContentField;
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public title(purl.org.dc.elementsQualified.SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("title", "http://purl.org/dc/terms/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class creator : global::purl.org.dc.elementsQualified.creator, IXMetaData {
        
        public new static creator Load(string xmlFile) {
            return XTypedServices.Load<creator, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static creator Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<creator, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static creator Parse(string xml) {
            return XTypedServices.Parse<creator, purl.org.dc.elementsQualified.SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator creator(XElement xe) { return XTypedServices.ToXTypedElement<creator, purl.org.dc.elementsQualified.SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new creator(((purl.org.dc.elementsQualified.SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private purl.org.dc.elementsQualified.SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public creator() : 
                base(true) {
            SetInnerType(new purl.org.dc.elementsQualified.SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual purl.org.dc.elementsQualified.SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ((purl.org.dc.elementsQualified.SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public creator(purl.org.dc.elementsQualified.SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("creator", "http://purl.org/dc/terms/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class subject : global::purl.org.dc.elementsQualified.subject, IXMetaData {
        
        public new static subject Load(string xmlFile) {
            return XTypedServices.Load<subject, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static subject Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<subject, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static subject Parse(string xml) {
            return XTypedServices.Parse<subject, purl.org.dc.elementsQualified.SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator subject(XElement xe) { return XTypedServices.ToXTypedElement<subject, purl.org.dc.elementsQualified.SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new subject(((purl.org.dc.elementsQualified.SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private purl.org.dc.elementsQualified.SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public subject() : 
                base(true) {
            SetInnerType(new purl.org.dc.elementsQualified.SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual purl.org.dc.elementsQualified.SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ((purl.org.dc.elementsQualified.SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public subject(purl.org.dc.elementsQualified.SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("subject", "http://purl.org/dc/terms/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class description : global::purl.org.dc.elementsQualified.description, IXMetaData {
        
        public new static description Load(string xmlFile) {
            return ((description)(XTypedServices.ToXTypedElement(XElement.Load(xmlFile), LinqToXsdTypeManager.Instance)));
        }
        
        public static description Load(System.IO.TextReader xmlFile) {
            return ((description)(XTypedServices.ToXTypedElement(XElement.Load(xmlFile), LinqToXsdTypeManager.Instance)));
        }
        
        public new static description Parse(string xml) {
            return ((description)(XTypedServices.ToXTypedElement(XElement.Parse(xml), LinqToXsdTypeManager.Instance)));
        }
        
		public static explicit operator description(XElement xe) {  return (description)XTypedServices.ToXTypedElement(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new description(((purl.org.dc.elementsQualified.SimpleLiteral)(this.Content.Clone())));
        }
        
        protected description(bool setNull) : 
                base(true) {
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private purl.org.dc.elementsQualified.SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public description() : 
                base(true) {
            SetInnerType(new purl.org.dc.elementsQualified.SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                if ((this.ContentField != null)) {
                    this.ContentField.Untyped = value;
                }
            }
        }
        
        public new virtual purl.org.dc.elementsQualified.SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ((purl.org.dc.elementsQualified.SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        protected virtual void SetSubstitutionMember(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ContentField;
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public description(purl.org.dc.elementsQualified.SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("description", "http://purl.org/dc/terms/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class publisher : global::purl.org.dc.elementsQualified.publisher, IXMetaData {
        
        public new static publisher Load(string xmlFile) {
            return XTypedServices.Load<publisher, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static publisher Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<publisher, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static publisher Parse(string xml) {
            return XTypedServices.Parse<publisher, purl.org.dc.elementsQualified.SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator publisher(XElement xe) { return XTypedServices.ToXTypedElement<publisher, purl.org.dc.elementsQualified.SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new publisher(((purl.org.dc.elementsQualified.SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private purl.org.dc.elementsQualified.SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public publisher() : 
                base(true) {
            SetInnerType(new purl.org.dc.elementsQualified.SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual purl.org.dc.elementsQualified.SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ((purl.org.dc.elementsQualified.SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public publisher(purl.org.dc.elementsQualified.SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("publisher", "http://purl.org/dc/terms/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class contributor : global::purl.org.dc.elementsQualified.contributor, IXMetaData {
        
        public new static contributor Load(string xmlFile) {
            return XTypedServices.Load<contributor, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static contributor Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<contributor, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static contributor Parse(string xml) {
            return XTypedServices.Parse<contributor, purl.org.dc.elementsQualified.SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator contributor(XElement xe) { return XTypedServices.ToXTypedElement<contributor, purl.org.dc.elementsQualified.SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new contributor(((purl.org.dc.elementsQualified.SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private purl.org.dc.elementsQualified.SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public contributor() : 
                base(true) {
            SetInnerType(new purl.org.dc.elementsQualified.SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual purl.org.dc.elementsQualified.SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ((purl.org.dc.elementsQualified.SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public contributor(purl.org.dc.elementsQualified.SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("contributor", "http://purl.org/dc/terms/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class date : global::purl.org.dc.elementsQualified.date, IXMetaData {
        
        public new static date Load(string xmlFile) {
            return ((date)(XTypedServices.ToXTypedElement(XElement.Load(xmlFile), LinqToXsdTypeManager.Instance)));
        }
        
        public static date Load(System.IO.TextReader xmlFile) {
            return ((date)(XTypedServices.ToXTypedElement(XElement.Load(xmlFile), LinqToXsdTypeManager.Instance)));
        }
        
        public new static date Parse(string xml) {
            return ((date)(XTypedServices.ToXTypedElement(XElement.Parse(xml), LinqToXsdTypeManager.Instance)));
        }
        
		public static explicit operator date(XElement xe) {  return (date)XTypedServices.ToXTypedElement(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new date(((purl.org.dc.elementsQualified.SimpleLiteral)(this.Content.Clone())));
        }
        
        protected date(bool setNull) : 
                base(true) {
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private purl.org.dc.elementsQualified.SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public date() : 
                base(true) {
            SetInnerType(new purl.org.dc.elementsQualified.SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                if ((this.ContentField != null)) {
                    this.ContentField.Untyped = value;
                }
            }
        }
        
        public new virtual purl.org.dc.elementsQualified.SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ((purl.org.dc.elementsQualified.SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        protected virtual void SetSubstitutionMember(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ContentField;
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public date(purl.org.dc.elementsQualified.SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("date", "http://purl.org/dc/terms/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class type : global::purl.org.dc.elementsQualified.type, IXMetaData {
        
        public new static type Load(string xmlFile) {
            return XTypedServices.Load<type, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static type Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<type, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static type Parse(string xml) {
            return XTypedServices.Parse<type, purl.org.dc.elementsQualified.SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator type(XElement xe) { return XTypedServices.ToXTypedElement<type, purl.org.dc.elementsQualified.SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new type(((purl.org.dc.elementsQualified.SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private purl.org.dc.elementsQualified.SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public type() : 
                base(true) {
            SetInnerType(new purl.org.dc.elementsQualified.SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual purl.org.dc.elementsQualified.SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ((purl.org.dc.elementsQualified.SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public type(purl.org.dc.elementsQualified.SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("type", "http://purl.org/dc/terms/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class format : global::purl.org.dc.elementsQualified.format, IXMetaData {
        
        public new static format Load(string xmlFile) {
            return ((format)(XTypedServices.ToXTypedElement(XElement.Load(xmlFile), LinqToXsdTypeManager.Instance)));
        }
        
        public static format Load(System.IO.TextReader xmlFile) {
            return ((format)(XTypedServices.ToXTypedElement(XElement.Load(xmlFile), LinqToXsdTypeManager.Instance)));
        }
        
        public new static format Parse(string xml) {
            return ((format)(XTypedServices.ToXTypedElement(XElement.Parse(xml), LinqToXsdTypeManager.Instance)));
        }
        
		public static explicit operator format(XElement xe) {  return (format)XTypedServices.ToXTypedElement(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new format(((purl.org.dc.elementsQualified.SimpleLiteral)(this.Content.Clone())));
        }
        
        protected format(bool setNull) : 
                base(true) {
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private purl.org.dc.elementsQualified.SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public format() : 
                base(true) {
            SetInnerType(new purl.org.dc.elementsQualified.SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                if ((this.ContentField != null)) {
                    this.ContentField.Untyped = value;
                }
            }
        }
        
        public new virtual purl.org.dc.elementsQualified.SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ((purl.org.dc.elementsQualified.SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        protected virtual void SetSubstitutionMember(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ContentField;
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public format(purl.org.dc.elementsQualified.SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("format", "http://purl.org/dc/terms/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class identifier : global::purl.org.dc.elementsQualified.identifier, IXMetaData {
        
        public new static identifier Load(string xmlFile) {
            return ((identifier)(XTypedServices.ToXTypedElement(XElement.Load(xmlFile), LinqToXsdTypeManager.Instance)));
        }
        
        public static identifier Load(System.IO.TextReader xmlFile) {
            return ((identifier)(XTypedServices.ToXTypedElement(XElement.Load(xmlFile), LinqToXsdTypeManager.Instance)));
        }
        
        public new static identifier Parse(string xml) {
            return ((identifier)(XTypedServices.ToXTypedElement(XElement.Parse(xml), LinqToXsdTypeManager.Instance)));
        }
        
		public static explicit operator identifier(XElement xe) {  return (identifier)XTypedServices.ToXTypedElement(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new identifier(((purl.org.dc.elementsQualified.SimpleLiteral)(this.Content.Clone())));
        }
        
        protected identifier(bool setNull) : 
                base(true) {
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private purl.org.dc.elementsQualified.SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public identifier() : 
                base(true) {
            SetInnerType(new purl.org.dc.elementsQualified.SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                if ((this.ContentField != null)) {
                    this.ContentField.Untyped = value;
                }
            }
        }
        
        public new virtual purl.org.dc.elementsQualified.SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ((purl.org.dc.elementsQualified.SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        protected virtual void SetSubstitutionMember(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ContentField;
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public identifier(purl.org.dc.elementsQualified.SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("identifier", "http://purl.org/dc/terms/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class source : global::purl.org.dc.elementsQualified.source, IXMetaData {
        
        public new static source Load(string xmlFile) {
            return XTypedServices.Load<source, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static source Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<source, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static source Parse(string xml) {
            return XTypedServices.Parse<source, purl.org.dc.elementsQualified.SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator source(XElement xe) { return XTypedServices.ToXTypedElement<source, purl.org.dc.elementsQualified.SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new source(((purl.org.dc.elementsQualified.SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private purl.org.dc.elementsQualified.SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public source() : 
                base(true) {
            SetInnerType(new purl.org.dc.elementsQualified.SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual purl.org.dc.elementsQualified.SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ((purl.org.dc.elementsQualified.SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public source(purl.org.dc.elementsQualified.SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("source", "http://purl.org/dc/terms/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class language : global::purl.org.dc.elementsQualified.language, IXMetaData {
        
        public new static language Load(string xmlFile) {
            return XTypedServices.Load<language, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static language Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<language, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static language Parse(string xml) {
            return XTypedServices.Parse<language, purl.org.dc.elementsQualified.SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator language(XElement xe) { return XTypedServices.ToXTypedElement<language, purl.org.dc.elementsQualified.SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new language(((purl.org.dc.elementsQualified.SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private purl.org.dc.elementsQualified.SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public language() : 
                base(true) {
            SetInnerType(new purl.org.dc.elementsQualified.SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual purl.org.dc.elementsQualified.SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ((purl.org.dc.elementsQualified.SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public language(purl.org.dc.elementsQualified.SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("language", "http://purl.org/dc/terms/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class relation : global::purl.org.dc.elementsQualified.relation, IXMetaData {
        
        public new static relation Load(string xmlFile) {
            return ((relation)(XTypedServices.ToXTypedElement(XElement.Load(xmlFile), LinqToXsdTypeManager.Instance)));
        }
        
        public static relation Load(System.IO.TextReader xmlFile) {
            return ((relation)(XTypedServices.ToXTypedElement(XElement.Load(xmlFile), LinqToXsdTypeManager.Instance)));
        }
        
        public new static relation Parse(string xml) {
            return ((relation)(XTypedServices.ToXTypedElement(XElement.Parse(xml), LinqToXsdTypeManager.Instance)));
        }
        
		public static explicit operator relation(XElement xe) {  return (relation)XTypedServices.ToXTypedElement(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new relation(((purl.org.dc.elementsQualified.SimpleLiteral)(this.Content.Clone())));
        }
        
        protected relation(bool setNull) : 
                base(true) {
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private purl.org.dc.elementsQualified.SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public relation() : 
                base(true) {
            SetInnerType(new purl.org.dc.elementsQualified.SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                if ((this.ContentField != null)) {
                    this.ContentField.Untyped = value;
                }
            }
        }
        
        public new virtual purl.org.dc.elementsQualified.SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ((purl.org.dc.elementsQualified.SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        protected virtual void SetSubstitutionMember(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ContentField;
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public relation(purl.org.dc.elementsQualified.SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("relation", "http://purl.org/dc/terms/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class coverage : global::purl.org.dc.elementsQualified.coverage, IXMetaData {
        
        public new static coverage Load(string xmlFile) {
            return ((coverage)(XTypedServices.ToXTypedElement(XElement.Load(xmlFile), LinqToXsdTypeManager.Instance)));
        }
        
        public static coverage Load(System.IO.TextReader xmlFile) {
            return ((coverage)(XTypedServices.ToXTypedElement(XElement.Load(xmlFile), LinqToXsdTypeManager.Instance)));
        }
        
        public new static coverage Parse(string xml) {
            return ((coverage)(XTypedServices.ToXTypedElement(XElement.Parse(xml), LinqToXsdTypeManager.Instance)));
        }
        
		public static explicit operator coverage(XElement xe) {  return (coverage)XTypedServices.ToXTypedElement(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new coverage(((purl.org.dc.elementsQualified.SimpleLiteral)(this.Content.Clone())));
        }
        
        protected coverage(bool setNull) : 
                base(true) {
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private purl.org.dc.elementsQualified.SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public coverage() : 
                base(true) {
            SetInnerType(new purl.org.dc.elementsQualified.SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                if ((this.ContentField != null)) {
                    this.ContentField.Untyped = value;
                }
            }
        }
        
        public new virtual purl.org.dc.elementsQualified.SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ((purl.org.dc.elementsQualified.SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        protected virtual void SetSubstitutionMember(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ContentField;
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public coverage(purl.org.dc.elementsQualified.SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("coverage", "http://purl.org/dc/terms/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class rights : global::purl.org.dc.elementsQualified.rights, IXMetaData {
        
        public new static rights Load(string xmlFile) {
            return ((rights)(XTypedServices.ToXTypedElement(XElement.Load(xmlFile), LinqToXsdTypeManager.Instance)));
        }
        
        public static rights Load(System.IO.TextReader xmlFile) {
            return ((rights)(XTypedServices.ToXTypedElement(XElement.Load(xmlFile), LinqToXsdTypeManager.Instance)));
        }
        
        public new static rights Parse(string xml) {
            return ((rights)(XTypedServices.ToXTypedElement(XElement.Parse(xml), LinqToXsdTypeManager.Instance)));
        }
        
		public static explicit operator rights(XElement xe) {  return (rights)XTypedServices.ToXTypedElement(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new rights(((purl.org.dc.elementsQualified.SimpleLiteral)(this.Content.Clone())));
        }
        
        protected rights(bool setNull) : 
                base(true) {
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private purl.org.dc.elementsQualified.SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public rights() : 
                base(true) {
            SetInnerType(new purl.org.dc.elementsQualified.SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                if ((this.ContentField != null)) {
                    this.ContentField.Untyped = value;
                }
            }
        }
        
        public new virtual purl.org.dc.elementsQualified.SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ((purl.org.dc.elementsQualified.SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        protected virtual void SetSubstitutionMember(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ContentField;
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public rights(purl.org.dc.elementsQualified.SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("rights", "http://purl.org/dc/terms/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class alternative : global::purl.org.dc.termsQualified.title, IXMetaData {
        
        public new static alternative Load(string xmlFile) {
            return XTypedServices.Load<alternative, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static alternative Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<alternative, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static alternative Parse(string xml) {
            return XTypedServices.Parse<alternative, purl.org.dc.elementsQualified.SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator alternative(XElement xe) { return XTypedServices.ToXTypedElement<alternative, purl.org.dc.elementsQualified.SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new alternative(((purl.org.dc.elementsQualified.SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private purl.org.dc.elementsQualified.SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public alternative() : 
                base(true) {
            SetInnerType(new purl.org.dc.elementsQualified.SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual purl.org.dc.elementsQualified.SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ((purl.org.dc.elementsQualified.SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public alternative(purl.org.dc.elementsQualified.SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("alternative", "http://purl.org/dc/terms/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class tableOfContents : global::purl.org.dc.termsQualified.description, IXMetaData {
        
        public new static tableOfContents Load(string xmlFile) {
            return XTypedServices.Load<tableOfContents, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static tableOfContents Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<tableOfContents, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static tableOfContents Parse(string xml) {
            return XTypedServices.Parse<tableOfContents, purl.org.dc.elementsQualified.SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator tableOfContents(XElement xe) { return XTypedServices.ToXTypedElement<tableOfContents, purl.org.dc.elementsQualified.SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new tableOfContents(((purl.org.dc.elementsQualified.SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private purl.org.dc.elementsQualified.SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public tableOfContents() : 
                base(true) {
            SetInnerType(new purl.org.dc.elementsQualified.SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual purl.org.dc.elementsQualified.SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ((purl.org.dc.elementsQualified.SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public tableOfContents(purl.org.dc.elementsQualified.SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("tableOfContents", "http://purl.org/dc/terms/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class @abstract : global::purl.org.dc.termsQualified.description, IXMetaData {
        
        public new static @abstract Load(string xmlFile) {
            return XTypedServices.Load<@abstract, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static @abstract Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<@abstract, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static @abstract Parse(string xml) {
            return XTypedServices.Parse<@abstract, purl.org.dc.elementsQualified.SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator @abstract(XElement xe) { return XTypedServices.ToXTypedElement<@abstract, purl.org.dc.elementsQualified.SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new @abstract(((purl.org.dc.elementsQualified.SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private purl.org.dc.elementsQualified.SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public @abstract() : 
                base(true) {
            SetInnerType(new purl.org.dc.elementsQualified.SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual purl.org.dc.elementsQualified.SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ((purl.org.dc.elementsQualified.SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public @abstract(purl.org.dc.elementsQualified.SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("abstract", "http://purl.org/dc/terms/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class created : global::purl.org.dc.termsQualified.date, IXMetaData {
        
        public new static created Load(string xmlFile) {
            return XTypedServices.Load<created, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static created Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<created, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static created Parse(string xml) {
            return XTypedServices.Parse<created, purl.org.dc.elementsQualified.SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator created(XElement xe) { return XTypedServices.ToXTypedElement<created, purl.org.dc.elementsQualified.SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new created(((purl.org.dc.elementsQualified.SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private purl.org.dc.elementsQualified.SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public created() : 
                base(true) {
            SetInnerType(new purl.org.dc.elementsQualified.SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual purl.org.dc.elementsQualified.SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ((purl.org.dc.elementsQualified.SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public created(purl.org.dc.elementsQualified.SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("created", "http://purl.org/dc/terms/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class valid : global::purl.org.dc.termsQualified.date, IXMetaData {
        
        public new static valid Load(string xmlFile) {
            return XTypedServices.Load<valid, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static valid Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<valid, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static valid Parse(string xml) {
            return XTypedServices.Parse<valid, purl.org.dc.elementsQualified.SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator valid(XElement xe) { return XTypedServices.ToXTypedElement<valid, purl.org.dc.elementsQualified.SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new valid(((purl.org.dc.elementsQualified.SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private purl.org.dc.elementsQualified.SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public valid() : 
                base(true) {
            SetInnerType(new purl.org.dc.elementsQualified.SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual purl.org.dc.elementsQualified.SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ((purl.org.dc.elementsQualified.SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public valid(purl.org.dc.elementsQualified.SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("valid", "http://purl.org/dc/terms/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class available : global::purl.org.dc.termsQualified.date, IXMetaData {
        
        public new static available Load(string xmlFile) {
            return XTypedServices.Load<available, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static available Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<available, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static available Parse(string xml) {
            return XTypedServices.Parse<available, purl.org.dc.elementsQualified.SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator available(XElement xe) { return XTypedServices.ToXTypedElement<available, purl.org.dc.elementsQualified.SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new available(((purl.org.dc.elementsQualified.SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private purl.org.dc.elementsQualified.SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public available() : 
                base(true) {
            SetInnerType(new purl.org.dc.elementsQualified.SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual purl.org.dc.elementsQualified.SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ((purl.org.dc.elementsQualified.SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public available(purl.org.dc.elementsQualified.SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("available", "http://purl.org/dc/terms/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class issued : global::purl.org.dc.termsQualified.date, IXMetaData {
        
        public new static issued Load(string xmlFile) {
            return XTypedServices.Load<issued, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static issued Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<issued, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static issued Parse(string xml) {
            return XTypedServices.Parse<issued, purl.org.dc.elementsQualified.SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator issued(XElement xe) { return XTypedServices.ToXTypedElement<issued, purl.org.dc.elementsQualified.SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new issued(((purl.org.dc.elementsQualified.SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private purl.org.dc.elementsQualified.SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public issued() : 
                base(true) {
            SetInnerType(new purl.org.dc.elementsQualified.SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual purl.org.dc.elementsQualified.SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ((purl.org.dc.elementsQualified.SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public issued(purl.org.dc.elementsQualified.SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("issued", "http://purl.org/dc/terms/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class modified : global::purl.org.dc.termsQualified.date, IXMetaData {
        
        public new static modified Load(string xmlFile) {
            return XTypedServices.Load<modified, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static modified Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<modified, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static modified Parse(string xml) {
            return XTypedServices.Parse<modified, purl.org.dc.elementsQualified.SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator modified(XElement xe) { return XTypedServices.ToXTypedElement<modified, purl.org.dc.elementsQualified.SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new modified(((purl.org.dc.elementsQualified.SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private purl.org.dc.elementsQualified.SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public modified() : 
                base(true) {
            SetInnerType(new purl.org.dc.elementsQualified.SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual purl.org.dc.elementsQualified.SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ((purl.org.dc.elementsQualified.SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public modified(purl.org.dc.elementsQualified.SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("modified", "http://purl.org/dc/terms/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class dateAccepted : global::purl.org.dc.termsQualified.date, IXMetaData {
        
        public new static dateAccepted Load(string xmlFile) {
            return XTypedServices.Load<dateAccepted, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static dateAccepted Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<dateAccepted, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static dateAccepted Parse(string xml) {
            return XTypedServices.Parse<dateAccepted, purl.org.dc.elementsQualified.SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator dateAccepted(XElement xe) { return XTypedServices.ToXTypedElement<dateAccepted, purl.org.dc.elementsQualified.SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new dateAccepted(((purl.org.dc.elementsQualified.SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private purl.org.dc.elementsQualified.SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public dateAccepted() : 
                base(true) {
            SetInnerType(new purl.org.dc.elementsQualified.SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual purl.org.dc.elementsQualified.SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ((purl.org.dc.elementsQualified.SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public dateAccepted(purl.org.dc.elementsQualified.SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("dateAccepted", "http://purl.org/dc/terms/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class dateCopyrighted : global::purl.org.dc.termsQualified.date, IXMetaData {
        
        public new static dateCopyrighted Load(string xmlFile) {
            return XTypedServices.Load<dateCopyrighted, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static dateCopyrighted Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<dateCopyrighted, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static dateCopyrighted Parse(string xml) {
            return XTypedServices.Parse<dateCopyrighted, purl.org.dc.elementsQualified.SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator dateCopyrighted(XElement xe) { return XTypedServices.ToXTypedElement<dateCopyrighted, purl.org.dc.elementsQualified.SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new dateCopyrighted(((purl.org.dc.elementsQualified.SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private purl.org.dc.elementsQualified.SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public dateCopyrighted() : 
                base(true) {
            SetInnerType(new purl.org.dc.elementsQualified.SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual purl.org.dc.elementsQualified.SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ((purl.org.dc.elementsQualified.SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public dateCopyrighted(purl.org.dc.elementsQualified.SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("dateCopyrighted", "http://purl.org/dc/terms/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class dateSubmitted : global::purl.org.dc.termsQualified.date, IXMetaData {
        
        public new static dateSubmitted Load(string xmlFile) {
            return XTypedServices.Load<dateSubmitted, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static dateSubmitted Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<dateSubmitted, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static dateSubmitted Parse(string xml) {
            return XTypedServices.Parse<dateSubmitted, purl.org.dc.elementsQualified.SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator dateSubmitted(XElement xe) { return XTypedServices.ToXTypedElement<dateSubmitted, purl.org.dc.elementsQualified.SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new dateSubmitted(((purl.org.dc.elementsQualified.SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private purl.org.dc.elementsQualified.SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public dateSubmitted() : 
                base(true) {
            SetInnerType(new purl.org.dc.elementsQualified.SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual purl.org.dc.elementsQualified.SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ((purl.org.dc.elementsQualified.SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public dateSubmitted(purl.org.dc.elementsQualified.SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("dateSubmitted", "http://purl.org/dc/terms/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class extent : global::purl.org.dc.termsQualified.format, IXMetaData {
        
        public new static extent Load(string xmlFile) {
            return XTypedServices.Load<extent, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static extent Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<extent, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static extent Parse(string xml) {
            return XTypedServices.Parse<extent, purl.org.dc.elementsQualified.SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator extent(XElement xe) { return XTypedServices.ToXTypedElement<extent, purl.org.dc.elementsQualified.SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new extent(((purl.org.dc.elementsQualified.SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private purl.org.dc.elementsQualified.SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public extent() : 
                base(true) {
            SetInnerType(new purl.org.dc.elementsQualified.SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual purl.org.dc.elementsQualified.SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ((purl.org.dc.elementsQualified.SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public extent(purl.org.dc.elementsQualified.SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("extent", "http://purl.org/dc/terms/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class medium : global::purl.org.dc.termsQualified.format, IXMetaData {
        
        public new static medium Load(string xmlFile) {
            return XTypedServices.Load<medium, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static medium Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<medium, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static medium Parse(string xml) {
            return XTypedServices.Parse<medium, purl.org.dc.elementsQualified.SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator medium(XElement xe) { return XTypedServices.ToXTypedElement<medium, purl.org.dc.elementsQualified.SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new medium(((purl.org.dc.elementsQualified.SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private purl.org.dc.elementsQualified.SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public medium() : 
                base(true) {
            SetInnerType(new purl.org.dc.elementsQualified.SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual purl.org.dc.elementsQualified.SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ((purl.org.dc.elementsQualified.SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public medium(purl.org.dc.elementsQualified.SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("medium", "http://purl.org/dc/terms/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class isVersionOf : global::purl.org.dc.termsQualified.relation, IXMetaData {
        
        public new static isVersionOf Load(string xmlFile) {
            return XTypedServices.Load<isVersionOf, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static isVersionOf Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<isVersionOf, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static isVersionOf Parse(string xml) {
            return XTypedServices.Parse<isVersionOf, purl.org.dc.elementsQualified.SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator isVersionOf(XElement xe) { return XTypedServices.ToXTypedElement<isVersionOf, purl.org.dc.elementsQualified.SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new isVersionOf(((purl.org.dc.elementsQualified.SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private purl.org.dc.elementsQualified.SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public isVersionOf() : 
                base(true) {
            SetInnerType(new purl.org.dc.elementsQualified.SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual purl.org.dc.elementsQualified.SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ((purl.org.dc.elementsQualified.SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public isVersionOf(purl.org.dc.elementsQualified.SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("isVersionOf", "http://purl.org/dc/terms/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class hasVersion : global::purl.org.dc.termsQualified.relation, IXMetaData {
        
        public new static hasVersion Load(string xmlFile) {
            return XTypedServices.Load<hasVersion, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static hasVersion Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<hasVersion, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static hasVersion Parse(string xml) {
            return XTypedServices.Parse<hasVersion, purl.org.dc.elementsQualified.SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator hasVersion(XElement xe) { return XTypedServices.ToXTypedElement<hasVersion, purl.org.dc.elementsQualified.SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new hasVersion(((purl.org.dc.elementsQualified.SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private purl.org.dc.elementsQualified.SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public hasVersion() : 
                base(true) {
            SetInnerType(new purl.org.dc.elementsQualified.SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual purl.org.dc.elementsQualified.SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ((purl.org.dc.elementsQualified.SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public hasVersion(purl.org.dc.elementsQualified.SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("hasVersion", "http://purl.org/dc/terms/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class isReplacedBy : global::purl.org.dc.termsQualified.relation, IXMetaData {
        
        public new static isReplacedBy Load(string xmlFile) {
            return XTypedServices.Load<isReplacedBy, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static isReplacedBy Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<isReplacedBy, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static isReplacedBy Parse(string xml) {
            return XTypedServices.Parse<isReplacedBy, purl.org.dc.elementsQualified.SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator isReplacedBy(XElement xe) { return XTypedServices.ToXTypedElement<isReplacedBy, purl.org.dc.elementsQualified.SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new isReplacedBy(((purl.org.dc.elementsQualified.SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private purl.org.dc.elementsQualified.SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public isReplacedBy() : 
                base(true) {
            SetInnerType(new purl.org.dc.elementsQualified.SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual purl.org.dc.elementsQualified.SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ((purl.org.dc.elementsQualified.SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public isReplacedBy(purl.org.dc.elementsQualified.SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("isReplacedBy", "http://purl.org/dc/terms/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class replaces : global::purl.org.dc.termsQualified.relation, IXMetaData {
        
        public new static replaces Load(string xmlFile) {
            return XTypedServices.Load<replaces, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static replaces Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<replaces, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static replaces Parse(string xml) {
            return XTypedServices.Parse<replaces, purl.org.dc.elementsQualified.SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator replaces(XElement xe) { return XTypedServices.ToXTypedElement<replaces, purl.org.dc.elementsQualified.SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new replaces(((purl.org.dc.elementsQualified.SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private purl.org.dc.elementsQualified.SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public replaces() : 
                base(true) {
            SetInnerType(new purl.org.dc.elementsQualified.SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual purl.org.dc.elementsQualified.SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ((purl.org.dc.elementsQualified.SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public replaces(purl.org.dc.elementsQualified.SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("replaces", "http://purl.org/dc/terms/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class isRequiredBy : global::purl.org.dc.termsQualified.relation, IXMetaData {
        
        public new static isRequiredBy Load(string xmlFile) {
            return XTypedServices.Load<isRequiredBy, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static isRequiredBy Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<isRequiredBy, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static isRequiredBy Parse(string xml) {
            return XTypedServices.Parse<isRequiredBy, purl.org.dc.elementsQualified.SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator isRequiredBy(XElement xe) { return XTypedServices.ToXTypedElement<isRequiredBy, purl.org.dc.elementsQualified.SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new isRequiredBy(((purl.org.dc.elementsQualified.SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private purl.org.dc.elementsQualified.SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public isRequiredBy() : 
                base(true) {
            SetInnerType(new purl.org.dc.elementsQualified.SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual purl.org.dc.elementsQualified.SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ((purl.org.dc.elementsQualified.SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public isRequiredBy(purl.org.dc.elementsQualified.SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("isRequiredBy", "http://purl.org/dc/terms/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class requires : global::purl.org.dc.termsQualified.relation, IXMetaData {
        
        public new static requires Load(string xmlFile) {
            return XTypedServices.Load<requires, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static requires Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<requires, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static requires Parse(string xml) {
            return XTypedServices.Parse<requires, purl.org.dc.elementsQualified.SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator requires(XElement xe) { return XTypedServices.ToXTypedElement<requires, purl.org.dc.elementsQualified.SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new requires(((purl.org.dc.elementsQualified.SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private purl.org.dc.elementsQualified.SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public requires() : 
                base(true) {
            SetInnerType(new purl.org.dc.elementsQualified.SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual purl.org.dc.elementsQualified.SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ((purl.org.dc.elementsQualified.SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public requires(purl.org.dc.elementsQualified.SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("requires", "http://purl.org/dc/terms/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class isPartOf : global::purl.org.dc.termsQualified.relation, IXMetaData {
        
        public new static isPartOf Load(string xmlFile) {
            return XTypedServices.Load<isPartOf, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static isPartOf Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<isPartOf, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static isPartOf Parse(string xml) {
            return XTypedServices.Parse<isPartOf, purl.org.dc.elementsQualified.SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator isPartOf(XElement xe) { return XTypedServices.ToXTypedElement<isPartOf, purl.org.dc.elementsQualified.SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new isPartOf(((purl.org.dc.elementsQualified.SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private purl.org.dc.elementsQualified.SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public isPartOf() : 
                base(true) {
            SetInnerType(new purl.org.dc.elementsQualified.SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual purl.org.dc.elementsQualified.SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ((purl.org.dc.elementsQualified.SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public isPartOf(purl.org.dc.elementsQualified.SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("isPartOf", "http://purl.org/dc/terms/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class hasPart : global::purl.org.dc.termsQualified.relation, IXMetaData {
        
        public new static hasPart Load(string xmlFile) {
            return XTypedServices.Load<hasPart, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static hasPart Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<hasPart, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static hasPart Parse(string xml) {
            return XTypedServices.Parse<hasPart, purl.org.dc.elementsQualified.SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator hasPart(XElement xe) { return XTypedServices.ToXTypedElement<hasPart, purl.org.dc.elementsQualified.SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new hasPart(((purl.org.dc.elementsQualified.SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private purl.org.dc.elementsQualified.SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public hasPart() : 
                base(true) {
            SetInnerType(new purl.org.dc.elementsQualified.SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual purl.org.dc.elementsQualified.SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ((purl.org.dc.elementsQualified.SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public hasPart(purl.org.dc.elementsQualified.SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("hasPart", "http://purl.org/dc/terms/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class isReferencedBy : global::purl.org.dc.termsQualified.relation, IXMetaData {
        
        public new static isReferencedBy Load(string xmlFile) {
            return XTypedServices.Load<isReferencedBy, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static isReferencedBy Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<isReferencedBy, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static isReferencedBy Parse(string xml) {
            return XTypedServices.Parse<isReferencedBy, purl.org.dc.elementsQualified.SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator isReferencedBy(XElement xe) { return XTypedServices.ToXTypedElement<isReferencedBy, purl.org.dc.elementsQualified.SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new isReferencedBy(((purl.org.dc.elementsQualified.SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private purl.org.dc.elementsQualified.SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public isReferencedBy() : 
                base(true) {
            SetInnerType(new purl.org.dc.elementsQualified.SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual purl.org.dc.elementsQualified.SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ((purl.org.dc.elementsQualified.SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public isReferencedBy(purl.org.dc.elementsQualified.SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("isReferencedBy", "http://purl.org/dc/terms/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class references : global::purl.org.dc.termsQualified.relation, IXMetaData {
        
        public new static references Load(string xmlFile) {
            return XTypedServices.Load<references, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static references Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<references, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static references Parse(string xml) {
            return XTypedServices.Parse<references, purl.org.dc.elementsQualified.SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator references(XElement xe) { return XTypedServices.ToXTypedElement<references, purl.org.dc.elementsQualified.SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new references(((purl.org.dc.elementsQualified.SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private purl.org.dc.elementsQualified.SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public references() : 
                base(true) {
            SetInnerType(new purl.org.dc.elementsQualified.SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual purl.org.dc.elementsQualified.SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ((purl.org.dc.elementsQualified.SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public references(purl.org.dc.elementsQualified.SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("references", "http://purl.org/dc/terms/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class isFormatOf : global::purl.org.dc.termsQualified.relation, IXMetaData {
        
        public new static isFormatOf Load(string xmlFile) {
            return XTypedServices.Load<isFormatOf, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static isFormatOf Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<isFormatOf, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static isFormatOf Parse(string xml) {
            return XTypedServices.Parse<isFormatOf, purl.org.dc.elementsQualified.SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator isFormatOf(XElement xe) { return XTypedServices.ToXTypedElement<isFormatOf, purl.org.dc.elementsQualified.SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new isFormatOf(((purl.org.dc.elementsQualified.SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private purl.org.dc.elementsQualified.SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public isFormatOf() : 
                base(true) {
            SetInnerType(new purl.org.dc.elementsQualified.SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual purl.org.dc.elementsQualified.SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ((purl.org.dc.elementsQualified.SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public isFormatOf(purl.org.dc.elementsQualified.SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("isFormatOf", "http://purl.org/dc/terms/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class hasFormat : global::purl.org.dc.termsQualified.relation, IXMetaData {
        
        public new static hasFormat Load(string xmlFile) {
            return XTypedServices.Load<hasFormat, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static hasFormat Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<hasFormat, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static hasFormat Parse(string xml) {
            return XTypedServices.Parse<hasFormat, purl.org.dc.elementsQualified.SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator hasFormat(XElement xe) { return XTypedServices.ToXTypedElement<hasFormat, purl.org.dc.elementsQualified.SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new hasFormat(((purl.org.dc.elementsQualified.SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private purl.org.dc.elementsQualified.SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public hasFormat() : 
                base(true) {
            SetInnerType(new purl.org.dc.elementsQualified.SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual purl.org.dc.elementsQualified.SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ((purl.org.dc.elementsQualified.SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public hasFormat(purl.org.dc.elementsQualified.SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("hasFormat", "http://purl.org/dc/terms/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class conformsTo : global::purl.org.dc.termsQualified.relation, IXMetaData {
        
        public new static conformsTo Load(string xmlFile) {
            return XTypedServices.Load<conformsTo, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static conformsTo Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<conformsTo, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static conformsTo Parse(string xml) {
            return XTypedServices.Parse<conformsTo, purl.org.dc.elementsQualified.SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator conformsTo(XElement xe) { return XTypedServices.ToXTypedElement<conformsTo, purl.org.dc.elementsQualified.SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new conformsTo(((purl.org.dc.elementsQualified.SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private purl.org.dc.elementsQualified.SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public conformsTo() : 
                base(true) {
            SetInnerType(new purl.org.dc.elementsQualified.SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual purl.org.dc.elementsQualified.SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ((purl.org.dc.elementsQualified.SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public conformsTo(purl.org.dc.elementsQualified.SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("conformsTo", "http://purl.org/dc/terms/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class spatial : global::purl.org.dc.termsQualified.coverage, IXMetaData {
        
        public new static spatial Load(string xmlFile) {
            return XTypedServices.Load<spatial, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static spatial Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<spatial, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static spatial Parse(string xml) {
            return XTypedServices.Parse<spatial, purl.org.dc.elementsQualified.SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator spatial(XElement xe) { return XTypedServices.ToXTypedElement<spatial, purl.org.dc.elementsQualified.SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new spatial(((purl.org.dc.elementsQualified.SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private purl.org.dc.elementsQualified.SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public spatial() : 
                base(true) {
            SetInnerType(new purl.org.dc.elementsQualified.SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual purl.org.dc.elementsQualified.SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ((purl.org.dc.elementsQualified.SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public spatial(purl.org.dc.elementsQualified.SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("spatial", "http://purl.org/dc/terms/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class temporal : global::purl.org.dc.termsQualified.coverage, IXMetaData {
        
        public new static temporal Load(string xmlFile) {
            return XTypedServices.Load<temporal, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static temporal Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<temporal, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static temporal Parse(string xml) {
            return XTypedServices.Parse<temporal, purl.org.dc.elementsQualified.SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator temporal(XElement xe) { return XTypedServices.ToXTypedElement<temporal, purl.org.dc.elementsQualified.SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new temporal(((purl.org.dc.elementsQualified.SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private purl.org.dc.elementsQualified.SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public temporal() : 
                base(true) {
            SetInnerType(new purl.org.dc.elementsQualified.SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual purl.org.dc.elementsQualified.SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ((purl.org.dc.elementsQualified.SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public temporal(purl.org.dc.elementsQualified.SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("temporal", "http://purl.org/dc/terms/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class audience : global::purl.org.dc.elementsQualified.any, IXMetaData {
        
        public new static audience Load(string xmlFile) {
            return ((audience)(XTypedServices.ToXTypedElement(XElement.Load(xmlFile), LinqToXsdTypeManager.Instance)));
        }
        
        public static audience Load(System.IO.TextReader xmlFile) {
            return ((audience)(XTypedServices.ToXTypedElement(XElement.Load(xmlFile), LinqToXsdTypeManager.Instance)));
        }
        
        public new static audience Parse(string xml) {
            return ((audience)(XTypedServices.ToXTypedElement(XElement.Parse(xml), LinqToXsdTypeManager.Instance)));
        }
        
		public static explicit operator audience(XElement xe) {  return (audience)XTypedServices.ToXTypedElement(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new audience(((purl.org.dc.elementsQualified.SimpleLiteral)(this.Content.Clone())));
        }
        
        protected audience(bool setNull) : 
                base(true) {
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private purl.org.dc.elementsQualified.SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public audience() : 
                base(true) {
            SetInnerType(new purl.org.dc.elementsQualified.SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                if ((this.ContentField != null)) {
                    this.ContentField.Untyped = value;
                }
            }
        }
        
        public new virtual purl.org.dc.elementsQualified.SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ((purl.org.dc.elementsQualified.SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        protected virtual void SetSubstitutionMember(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ContentField;
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public audience(purl.org.dc.elementsQualified.SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("audience", "http://purl.org/dc/terms/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class accrualMethod : global::purl.org.dc.elementsQualified.any, IXMetaData {
        
        public new static accrualMethod Load(string xmlFile) {
            return XTypedServices.Load<accrualMethod, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static accrualMethod Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<accrualMethod, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static accrualMethod Parse(string xml) {
            return XTypedServices.Parse<accrualMethod, purl.org.dc.elementsQualified.SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator accrualMethod(XElement xe) { return XTypedServices.ToXTypedElement<accrualMethod, purl.org.dc.elementsQualified.SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new accrualMethod(((purl.org.dc.elementsQualified.SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private purl.org.dc.elementsQualified.SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public accrualMethod() : 
                base(true) {
            SetInnerType(new purl.org.dc.elementsQualified.SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual purl.org.dc.elementsQualified.SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ((purl.org.dc.elementsQualified.SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public accrualMethod(purl.org.dc.elementsQualified.SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("accrualMethod", "http://purl.org/dc/terms/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class accrualPeriodicity : global::purl.org.dc.elementsQualified.any, IXMetaData {
        
        public new static accrualPeriodicity Load(string xmlFile) {
            return XTypedServices.Load<accrualPeriodicity, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static accrualPeriodicity Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<accrualPeriodicity, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static accrualPeriodicity Parse(string xml) {
            return XTypedServices.Parse<accrualPeriodicity, purl.org.dc.elementsQualified.SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator accrualPeriodicity(XElement xe) { return XTypedServices.ToXTypedElement<accrualPeriodicity, purl.org.dc.elementsQualified.SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new accrualPeriodicity(((purl.org.dc.elementsQualified.SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private purl.org.dc.elementsQualified.SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public accrualPeriodicity() : 
                base(true) {
            SetInnerType(new purl.org.dc.elementsQualified.SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual purl.org.dc.elementsQualified.SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ((purl.org.dc.elementsQualified.SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public accrualPeriodicity(purl.org.dc.elementsQualified.SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("accrualPeriodicity", "http://purl.org/dc/terms/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class accrualPolicy : global::purl.org.dc.elementsQualified.any, IXMetaData {
        
        public new static accrualPolicy Load(string xmlFile) {
            return XTypedServices.Load<accrualPolicy, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static accrualPolicy Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<accrualPolicy, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static accrualPolicy Parse(string xml) {
            return XTypedServices.Parse<accrualPolicy, purl.org.dc.elementsQualified.SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator accrualPolicy(XElement xe) { return XTypedServices.ToXTypedElement<accrualPolicy, purl.org.dc.elementsQualified.SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new accrualPolicy(((purl.org.dc.elementsQualified.SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private purl.org.dc.elementsQualified.SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public accrualPolicy() : 
                base(true) {
            SetInnerType(new purl.org.dc.elementsQualified.SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual purl.org.dc.elementsQualified.SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ((purl.org.dc.elementsQualified.SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public accrualPolicy(purl.org.dc.elementsQualified.SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("accrualPolicy", "http://purl.org/dc/terms/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class instructionalMethod : global::purl.org.dc.elementsQualified.any, IXMetaData {
        
        public new static instructionalMethod Load(string xmlFile) {
            return XTypedServices.Load<instructionalMethod, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static instructionalMethod Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<instructionalMethod, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static instructionalMethod Parse(string xml) {
            return XTypedServices.Parse<instructionalMethod, purl.org.dc.elementsQualified.SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator instructionalMethod(XElement xe) { return XTypedServices.ToXTypedElement<instructionalMethod, purl.org.dc.elementsQualified.SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new instructionalMethod(((purl.org.dc.elementsQualified.SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private purl.org.dc.elementsQualified.SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public instructionalMethod() : 
                base(true) {
            SetInnerType(new purl.org.dc.elementsQualified.SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual purl.org.dc.elementsQualified.SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ((purl.org.dc.elementsQualified.SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public instructionalMethod(purl.org.dc.elementsQualified.SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("instructionalMethod", "http://purl.org/dc/terms/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class provenance : global::purl.org.dc.elementsQualified.any, IXMetaData {
        
        public new static provenance Load(string xmlFile) {
            return XTypedServices.Load<provenance, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static provenance Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<provenance, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static provenance Parse(string xml) {
            return XTypedServices.Parse<provenance, purl.org.dc.elementsQualified.SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator provenance(XElement xe) { return XTypedServices.ToXTypedElement<provenance, purl.org.dc.elementsQualified.SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new provenance(((purl.org.dc.elementsQualified.SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private purl.org.dc.elementsQualified.SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public provenance() : 
                base(true) {
            SetInnerType(new purl.org.dc.elementsQualified.SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual purl.org.dc.elementsQualified.SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ((purl.org.dc.elementsQualified.SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public provenance(purl.org.dc.elementsQualified.SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("provenance", "http://purl.org/dc/terms/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class rightsHolder : global::purl.org.dc.elementsQualified.any, IXMetaData {
        
        public new static rightsHolder Load(string xmlFile) {
            return XTypedServices.Load<rightsHolder, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static rightsHolder Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<rightsHolder, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static rightsHolder Parse(string xml) {
            return XTypedServices.Parse<rightsHolder, purl.org.dc.elementsQualified.SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator rightsHolder(XElement xe) { return XTypedServices.ToXTypedElement<rightsHolder, purl.org.dc.elementsQualified.SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new rightsHolder(((purl.org.dc.elementsQualified.SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private purl.org.dc.elementsQualified.SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public rightsHolder() : 
                base(true) {
            SetInnerType(new purl.org.dc.elementsQualified.SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual purl.org.dc.elementsQualified.SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ((purl.org.dc.elementsQualified.SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public rightsHolder(purl.org.dc.elementsQualified.SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("rightsHolder", "http://purl.org/dc/terms/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class mediator : global::purl.org.dc.termsQualified.audience, IXMetaData {
        
        public new static mediator Load(string xmlFile) {
            return XTypedServices.Load<mediator, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static mediator Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<mediator, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static mediator Parse(string xml) {
            return XTypedServices.Parse<mediator, purl.org.dc.elementsQualified.SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator mediator(XElement xe) { return XTypedServices.ToXTypedElement<mediator, purl.org.dc.elementsQualified.SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new mediator(((purl.org.dc.elementsQualified.SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private purl.org.dc.elementsQualified.SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public mediator() : 
                base(true) {
            SetInnerType(new purl.org.dc.elementsQualified.SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual purl.org.dc.elementsQualified.SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ((purl.org.dc.elementsQualified.SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public mediator(purl.org.dc.elementsQualified.SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("mediator", "http://purl.org/dc/terms/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class educationLevel : global::purl.org.dc.termsQualified.audience, IXMetaData {
        
        public new static educationLevel Load(string xmlFile) {
            return XTypedServices.Load<educationLevel, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static educationLevel Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<educationLevel, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static educationLevel Parse(string xml) {
            return XTypedServices.Parse<educationLevel, purl.org.dc.elementsQualified.SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator educationLevel(XElement xe) { return XTypedServices.ToXTypedElement<educationLevel, purl.org.dc.elementsQualified.SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new educationLevel(((purl.org.dc.elementsQualified.SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private purl.org.dc.elementsQualified.SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public educationLevel() : 
                base(true) {
            SetInnerType(new purl.org.dc.elementsQualified.SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual purl.org.dc.elementsQualified.SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ((purl.org.dc.elementsQualified.SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public educationLevel(purl.org.dc.elementsQualified.SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("educationLevel", "http://purl.org/dc/terms/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class accessRights : global::purl.org.dc.termsQualified.rights, IXMetaData {
        
        public new static accessRights Load(string xmlFile) {
            return XTypedServices.Load<accessRights, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static accessRights Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<accessRights, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static accessRights Parse(string xml) {
            return XTypedServices.Parse<accessRights, purl.org.dc.elementsQualified.SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator accessRights(XElement xe) { return XTypedServices.ToXTypedElement<accessRights, purl.org.dc.elementsQualified.SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new accessRights(((purl.org.dc.elementsQualified.SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private purl.org.dc.elementsQualified.SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public accessRights() : 
                base(true) {
            SetInnerType(new purl.org.dc.elementsQualified.SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual purl.org.dc.elementsQualified.SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ((purl.org.dc.elementsQualified.SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public accessRights(purl.org.dc.elementsQualified.SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("accessRights", "http://purl.org/dc/terms/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class license : global::purl.org.dc.termsQualified.rights, IXMetaData {
        
        public new static license Load(string xmlFile) {
            return XTypedServices.Load<license, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static license Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<license, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static license Parse(string xml) {
            return XTypedServices.Parse<license, purl.org.dc.elementsQualified.SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator license(XElement xe) { return XTypedServices.ToXTypedElement<license, purl.org.dc.elementsQualified.SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new license(((purl.org.dc.elementsQualified.SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private purl.org.dc.elementsQualified.SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public license() : 
                base(true) {
            SetInnerType(new purl.org.dc.elementsQualified.SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual purl.org.dc.elementsQualified.SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ((purl.org.dc.elementsQualified.SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public license(purl.org.dc.elementsQualified.SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("license", "http://purl.org/dc/terms/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class bibliographicCitation : global::purl.org.dc.termsQualified.identifier, IXMetaData {
        
        public new static bibliographicCitation Load(string xmlFile) {
            return XTypedServices.Load<bibliographicCitation, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static bibliographicCitation Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<bibliographicCitation, purl.org.dc.elementsQualified.SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static bibliographicCitation Parse(string xml) {
            return XTypedServices.Parse<bibliographicCitation, purl.org.dc.elementsQualified.SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator bibliographicCitation(XElement xe) { return XTypedServices.ToXTypedElement<bibliographicCitation, purl.org.dc.elementsQualified.SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new bibliographicCitation(((purl.org.dc.elementsQualified.SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private purl.org.dc.elementsQualified.SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public bibliographicCitation() : 
                base(true) {
            SetInnerType(new purl.org.dc.elementsQualified.SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual purl.org.dc.elementsQualified.SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(purl.org.dc.elementsQualified.SimpleLiteral ContentField) {
            this.ContentField = ((purl.org.dc.elementsQualified.SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public bibliographicCitation(purl.org.dc.elementsQualified.SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("bibliographicCitation", "http://purl.org/dc/terms/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    public partial class XRootNamespace {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XDocument doc;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedElement rootObject;
        
        private XRootNamespace() {
        }
        
        public static XRootNamespace Load(string xmlFile) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Load(xmlFile);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRootNamespace Load(string xmlFile, LoadOptions options) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Load(xmlFile, options);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRootNamespace Load(TextReader textReader) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Load(textReader);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRootNamespace Load(TextReader textReader, LoadOptions options) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Load(textReader, options);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRootNamespace Load(XmlReader xmlReader) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Load(xmlReader);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRootNamespace Parse(string text) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Parse(text);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRootNamespace Parse(string text, LoadOptions options) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Parse(text, options);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public virtual void Save(string fileName) {
            doc.Save(fileName);
        }
        
        public virtual void Save(TextWriter textWriter) {
            doc.Save(textWriter);
        }
        
        public virtual void Save(XmlWriter writer) {
            doc.Save(writer);
        }
        
        public virtual void Save(TextWriter textWriter, SaveOptions options) {
            doc.Save(textWriter, options);
        }
        
        public virtual void Save(string fileName, SaveOptions options) {
            doc.Save(fileName, options);
        }
        
        public virtual XDocument XDocument {
            get {
                return doc;
            }
        }
        
        public virtual XTypedElement Root {
            get {
                return rootObject;
            }
        }
        
        public XRootNamespace(title root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public title title {  get {return rootObject as title; } }
        
        public XRootNamespace(creator root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public creator creator {  get {return rootObject as creator; } }
        
        public XRootNamespace(subject root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public subject subject {  get {return rootObject as subject; } }
        
        public XRootNamespace(description root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public description description {  get {return rootObject as description; } }
        
        public XRootNamespace(publisher root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public publisher publisher {  get {return rootObject as publisher; } }
        
        public XRootNamespace(contributor root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public contributor contributor {  get {return rootObject as contributor; } }
        
        public XRootNamespace(date root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public date date {  get {return rootObject as date; } }
        
        public XRootNamespace(type root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public type type {  get {return rootObject as type; } }
        
        public XRootNamespace(format root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public format format {  get {return rootObject as format; } }
        
        public XRootNamespace(identifier root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public identifier identifier {  get {return rootObject as identifier; } }
        
        public XRootNamespace(source root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public source source {  get {return rootObject as source; } }
        
        public XRootNamespace(language root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public language language {  get {return rootObject as language; } }
        
        public XRootNamespace(relation root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public relation relation {  get {return rootObject as relation; } }
        
        public XRootNamespace(coverage root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public coverage coverage {  get {return rootObject as coverage; } }
        
        public XRootNamespace(rights root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public rights rights {  get {return rootObject as rights; } }
        
        public XRootNamespace(alternative root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public alternative alternative {  get {return rootObject as alternative; } }
        
        public XRootNamespace(tableOfContents root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public tableOfContents tableOfContents {  get {return rootObject as tableOfContents; } }
        
        public XRootNamespace(@abstract root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public @abstract @abstract {  get {return rootObject as @abstract; } }
        
        public XRootNamespace(created root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public created created {  get {return rootObject as created; } }
        
        public XRootNamespace(valid root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public valid valid {  get {return rootObject as valid; } }
        
        public XRootNamespace(available root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public available available {  get {return rootObject as available; } }
        
        public XRootNamespace(issued root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public issued issued {  get {return rootObject as issued; } }
        
        public XRootNamespace(modified root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public modified modified {  get {return rootObject as modified; } }
        
        public XRootNamespace(dateAccepted root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public dateAccepted dateAccepted {  get {return rootObject as dateAccepted; } }
        
        public XRootNamespace(dateCopyrighted root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public dateCopyrighted dateCopyrighted {  get {return rootObject as dateCopyrighted; } }
        
        public XRootNamespace(dateSubmitted root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public dateSubmitted dateSubmitted {  get {return rootObject as dateSubmitted; } }
        
        public XRootNamespace(extent root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public extent extent {  get {return rootObject as extent; } }
        
        public XRootNamespace(medium root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public medium medium {  get {return rootObject as medium; } }
        
        public XRootNamespace(isVersionOf root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public isVersionOf isVersionOf {  get {return rootObject as isVersionOf; } }
        
        public XRootNamespace(hasVersion root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public hasVersion hasVersion {  get {return rootObject as hasVersion; } }
        
        public XRootNamespace(isReplacedBy root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public isReplacedBy isReplacedBy {  get {return rootObject as isReplacedBy; } }
        
        public XRootNamespace(replaces root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public replaces replaces {  get {return rootObject as replaces; } }
        
        public XRootNamespace(isRequiredBy root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public isRequiredBy isRequiredBy {  get {return rootObject as isRequiredBy; } }
        
        public XRootNamespace(requires root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public requires requires {  get {return rootObject as requires; } }
        
        public XRootNamespace(isPartOf root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public isPartOf isPartOf {  get {return rootObject as isPartOf; } }
        
        public XRootNamespace(hasPart root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public hasPart hasPart {  get {return rootObject as hasPart; } }
        
        public XRootNamespace(isReferencedBy root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public isReferencedBy isReferencedBy {  get {return rootObject as isReferencedBy; } }
        
        public XRootNamespace(references root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public references references {  get {return rootObject as references; } }
        
        public XRootNamespace(isFormatOf root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public isFormatOf isFormatOf {  get {return rootObject as isFormatOf; } }
        
        public XRootNamespace(hasFormat root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public hasFormat hasFormat {  get {return rootObject as hasFormat; } }
        
        public XRootNamespace(conformsTo root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public conformsTo conformsTo {  get {return rootObject as conformsTo; } }
        
        public XRootNamespace(spatial root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public spatial spatial {  get {return rootObject as spatial; } }
        
        public XRootNamespace(temporal root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public temporal temporal {  get {return rootObject as temporal; } }
        
        public XRootNamespace(audience root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public audience audience {  get {return rootObject as audience; } }
        
        public XRootNamespace(accrualMethod root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public accrualMethod accrualMethod {  get {return rootObject as accrualMethod; } }
        
        public XRootNamespace(accrualPeriodicity root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public accrualPeriodicity accrualPeriodicity {  get {return rootObject as accrualPeriodicity; } }
        
        public XRootNamespace(accrualPolicy root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public accrualPolicy accrualPolicy {  get {return rootObject as accrualPolicy; } }
        
        public XRootNamespace(instructionalMethod root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public instructionalMethod instructionalMethod {  get {return rootObject as instructionalMethod; } }
        
        public XRootNamespace(provenance root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public provenance provenance {  get {return rootObject as provenance; } }
        
        public XRootNamespace(rightsHolder root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public rightsHolder rightsHolder {  get {return rootObject as rightsHolder; } }
        
        public XRootNamespace(mediator root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public mediator mediator {  get {return rootObject as mediator; } }
        
        public XRootNamespace(educationLevel root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public educationLevel educationLevel {  get {return rootObject as educationLevel; } }
        
        public XRootNamespace(accessRights root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public accessRights accessRights {  get {return rootObject as accessRights; } }
        
        public XRootNamespace(license root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public license license {  get {return rootObject as license; } }
        
        public XRootNamespace(bibliographicCitation root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public bibliographicCitation bibliographicCitation {  get {return rootObject as bibliographicCitation; } }
    }
}
namespace purl.org.dc.elementsQualified {
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.IO;
    using System.Linq;
    using System.Diagnostics;
    using System.Xml;
    using System.Xml.Schema;
    using System.Xml.Linq;
    using Xml.Schema.Linq;
    using purl.org.dc.qualifiedContainer;
    
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class SimpleLiteral : XTypedElement, IXMetaData {
        
		public static explicit operator SimpleLiteral(XElement xe) { return XTypedServices.ToXTypedElement<SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<SimpleLiteral>(this);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public SimpleLiteral() {
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName langXName = System.Xml.Linq.XName.Get("lang", "http://www.w3.org/XML/1998/namespace");
        
        /// <summary>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual object lang {
            get {
                XAttribute x = this.Attribute(langXName);
                return XTypedServices.ParseUnionValue(x, global::W3C.XmlNs3.lang.TypeDefinition);
            }
            set {
                this.SetUnionAttribute(value, "lang", this, langXName, global::W3C.XmlNs3.lang.TypeDefinition);
            }
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("SimpleLiteral", "http://purl.org/dc/elements/1.1/");
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///    		This complexType is included as a convenience for schema authors who need to define a root
    ///    		or container element for all of the DC elements.
    ///    	
    /// </para>
    /// <para>
    /// Regular expression: (((any)*))
    /// </para>
    /// </summary>
    public partial class elementContainer : XTypedElement, IXMetaData {
        
		public static explicit operator elementContainer(XElement xe) { return XTypedServices.ToXTypedElement<elementContainer>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<elementContainer>(this);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///    		This complexType is included as a convenience for schema authors who need to define a root
        ///    		or container element for all of the DC elements.
        ///    	
        /// </para>
        /// <para>
        /// Regular expression: (((any)*))
        /// </para>
        /// </summary>
        public elementContainer() {
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName anyXName = System.Xml.Linq.XName.Get("any", "http://purl.org/dc/elements/1.1/");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedSubstitutedList<any> anyField;
        
        /// <summary>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Setter: Appends
        /// </para>
        /// <para>
        /// Substitution members: any, title, creator, subject, description, publisher, contributor, date, type, format, identifier, source, language, relation, coverage, rights, alternative, tableOfContents, abstract, created, valid, available, issued, modified, dateAccepted, dateCopyrighted, dateSubmitted, extent, medium, isVersionOf, hasVersion, isReplacedBy, replaces, isRequiredBy, requires, isPartOf, hasPart, isReferencedBy, references, isFormatOf, hasFormat, conformsTo, spatial, temporal, audience, accrualMethod, accrualPeriodicity, accrualPolicy, instructionalMethod, provenance, rightsHolder, mediator, educationLevel, accessRights, license, bibliographicCitation, title, creator, subject, description, publisher, contributor, date, type, format, identifier, source, language, relation, coverage, rights
        /// </para>
        /// <para>
        /// Regular expression: (((any)*))
        /// </para>
        /// </summary>
        public virtual IList<any> any {
            get {
                if ((this.anyField == null)) {
                    this.anyField = new XTypedSubstitutedList<any>(this, LinqToXsdTypeManager.Instance, System.Xml.Linq.XName.Get("any", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("title", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("creator", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("subject", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("description", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("publisher", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("contributor", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("date", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("type", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("format", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("identifier", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("source", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("language", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("relation", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("coverage", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("rights", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("alternative", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("tableOfContents", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("abstract", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("created", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("valid", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("available", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("issued", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("modified", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("dateAccepted", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("dateCopyrighted", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("dateSubmitted", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("extent", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("medium", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("isVersionOf", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("hasVersion", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("isReplacedBy", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("replaces", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("isRequiredBy", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("requires", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("isPartOf", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("hasPart", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("isReferencedBy", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("references", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("isFormatOf", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("hasFormat", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("conformsTo", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("spatial", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("temporal", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("audience", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("accrualMethod", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("accrualPeriodicity", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("accrualPolicy", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("instructionalMethod", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("provenance", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("rightsHolder", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("mediator", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("educationLevel", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("accessRights", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("license", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("bibliographicCitation", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("title", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("creator", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("subject", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("description", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("publisher", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("contributor", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("date", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("type", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("format", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("identifier", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("source", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("language", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("relation", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("coverage", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("rights", "http://purl.org/dc/elements/1.1/"));
                }
                return this.anyField;
            }
            set {
                if ((value == null)) {
                    this.anyField = null;
                }
                else {
                    if ((this.anyField == null)) {
                        this.anyField = XTypedSubstitutedList<any>.Initialize(this, LinqToXsdTypeManager.Instance, value, System.Xml.Linq.XName.Get("any", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("title", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("creator", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("subject", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("description", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("publisher", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("contributor", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("date", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("type", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("format", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("identifier", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("source", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("language", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("relation", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("coverage", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("rights", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("alternative", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("tableOfContents", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("abstract", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("created", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("valid", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("available", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("issued", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("modified", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("dateAccepted", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("dateCopyrighted", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("dateSubmitted", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("extent", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("medium", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("isVersionOf", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("hasVersion", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("isReplacedBy", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("replaces", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("isRequiredBy", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("requires", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("isPartOf", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("hasPart", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("isReferencedBy", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("references", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("isFormatOf", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("hasFormat", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("conformsTo", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("spatial", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("temporal", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("audience", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("accrualMethod", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("accrualPeriodicity", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("accrualPolicy", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("instructionalMethod", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("provenance", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("rightsHolder", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("mediator", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("educationLevel", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("accessRights", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("license", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("bibliographicCitation", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("title", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("creator", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("subject", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("description", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("publisher", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("contributor", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("date", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("type", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("format", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("identifier", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("source", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("language", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("relation", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("coverage", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("rights", "http://purl.org/dc/elements/1.1/"));
                    }
                    else {
                        XTypedServices.SetList<any>(this.anyField, value);
                    }
                }
            }
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("elementContainer", "http://purl.org/dc/elements/1.1/");
        
        static elementContainer() {
            BuildElementDictionary();
            contentModel = new ChoiceContentModelEntity(new SequenceContentModelEntity(new ChoiceContentModelEntity(new SubstitutedContentModelEntity(System.Xml.Linq.XName.Get("any", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("title", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("creator", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("subject", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("description", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("publisher", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("contributor", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("date", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("type", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("format", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("identifier", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("source", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("language", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("relation", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("coverage", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("rights", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("alternative", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("tableOfContents", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("abstract", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("created", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("valid", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("available", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("issued", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("modified", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("dateAccepted", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("dateCopyrighted", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("dateSubmitted", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("extent", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("medium", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("isVersionOf", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("hasVersion", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("isReplacedBy", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("replaces", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("isRequiredBy", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("requires", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("isPartOf", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("hasPart", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("isReferencedBy", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("references", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("isFormatOf", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("hasFormat", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("conformsTo", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("spatial", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("temporal", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("audience", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("accrualMethod", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("accrualPeriodicity", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("accrualPolicy", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("instructionalMethod", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("provenance", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("rightsHolder", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("mediator", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("educationLevel", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("accessRights", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("license", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("bibliographicCitation", "http://purl.org/dc/terms/"), System.Xml.Linq.XName.Get("title", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("creator", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("subject", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("description", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("publisher", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("contributor", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("date", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("type", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("format", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("identifier", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("source", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("language", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("relation", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("coverage", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("rights", "http://purl.org/dc/elements/1.1/")))));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(anyXName, typeof(any));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public abstract partial class any : XTypedElement, IXMetaData {
        
        public void Save(string xmlFile) {
            XTypedServices.Save(xmlFile, Untyped);
        }
        
        public void Save(System.IO.TextWriter tw) {
            XTypedServices.Save(tw, Untyped);
        }
        
        public void Save(System.Xml.XmlWriter xmlWriter) {
            XTypedServices.Save(xmlWriter, Untyped);
        }
        
        public static any Load(string xmlFile) {
            return ((any)(XTypedServices.ToXTypedElement(XElement.Load(xmlFile), LinqToXsdTypeManager.Instance)));
        }
        
        public static any Load(System.IO.TextReader xmlFile) {
            return ((any)(XTypedServices.ToXTypedElement(XElement.Load(xmlFile), LinqToXsdTypeManager.Instance)));
        }
        
        public static any Parse(string xml) {
            return ((any)(XTypedServices.ToXTypedElement(XElement.Parse(xml), LinqToXsdTypeManager.Instance)));
        }
        
		public static explicit operator any(XElement xe) {  return (any)XTypedServices.ToXTypedElement(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        protected any(bool setNull) {
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public any() {
            SetInnerType(new SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                if ((this.ContentField != null)) {
                    this.ContentField.Untyped = value;
                }
            }
        }
        
        public virtual SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(SimpleLiteral ContentField) {
            this.ContentField = ((SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
        }
        
        protected virtual void SetSubstitutionMember(SimpleLiteral ContentField) {
            this.ContentField = ContentField;
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public any(SimpleLiteral content) {
            SetInnerType(content);
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual object lang {
            get {
                return this.ContentField.lang;
            }
            set {
                this.ContentField.lang = value;
            }
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("any", "http://purl.org/dc/elements/1.1/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class title : global::purl.org.dc.elementsQualified.any, IXMetaData {
        
        public new static title Load(string xmlFile) {
            return ((title)(XTypedServices.ToXTypedElement(XElement.Load(xmlFile), LinqToXsdTypeManager.Instance)));
        }
        
        public static title Load(System.IO.TextReader xmlFile) {
            return ((title)(XTypedServices.ToXTypedElement(XElement.Load(xmlFile), LinqToXsdTypeManager.Instance)));
        }
        
        public new static title Parse(string xml) {
            return ((title)(XTypedServices.ToXTypedElement(XElement.Parse(xml), LinqToXsdTypeManager.Instance)));
        }
        
		public static explicit operator title(XElement xe) {  return (title)XTypedServices.ToXTypedElement(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new title(((SimpleLiteral)(this.Content.Clone())));
        }
        
        protected title(bool setNull) : 
                base(true) {
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public title() : 
                base(true) {
            SetInnerType(new SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                if ((this.ContentField != null)) {
                    this.ContentField.Untyped = value;
                }
            }
        }
        
        public new virtual SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(SimpleLiteral ContentField) {
            this.ContentField = ((SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        protected virtual void SetSubstitutionMember(SimpleLiteral ContentField) {
            this.ContentField = ContentField;
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public title(SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("title", "http://purl.org/dc/elements/1.1/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class creator : global::purl.org.dc.elementsQualified.any, IXMetaData {
        
        public new static creator Load(string xmlFile) {
            return ((creator)(XTypedServices.ToXTypedElement(XElement.Load(xmlFile), LinqToXsdTypeManager.Instance)));
        }
        
        public static creator Load(System.IO.TextReader xmlFile) {
            return ((creator)(XTypedServices.ToXTypedElement(XElement.Load(xmlFile), LinqToXsdTypeManager.Instance)));
        }
        
        public new static creator Parse(string xml) {
            return ((creator)(XTypedServices.ToXTypedElement(XElement.Parse(xml), LinqToXsdTypeManager.Instance)));
        }
        
		public static explicit operator creator(XElement xe) {  return (creator)XTypedServices.ToXTypedElement(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new creator(((SimpleLiteral)(this.Content.Clone())));
        }
        
        protected creator(bool setNull) : 
                base(true) {
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public creator() : 
                base(true) {
            SetInnerType(new SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                if ((this.ContentField != null)) {
                    this.ContentField.Untyped = value;
                }
            }
        }
        
        public new virtual SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(SimpleLiteral ContentField) {
            this.ContentField = ((SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        protected virtual void SetSubstitutionMember(SimpleLiteral ContentField) {
            this.ContentField = ContentField;
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public creator(SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("creator", "http://purl.org/dc/elements/1.1/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class subject : global::purl.org.dc.elementsQualified.any, IXMetaData {
        
        public new static subject Load(string xmlFile) {
            return ((subject)(XTypedServices.ToXTypedElement(XElement.Load(xmlFile), LinqToXsdTypeManager.Instance)));
        }
        
        public static subject Load(System.IO.TextReader xmlFile) {
            return ((subject)(XTypedServices.ToXTypedElement(XElement.Load(xmlFile), LinqToXsdTypeManager.Instance)));
        }
        
        public new static subject Parse(string xml) {
            return ((subject)(XTypedServices.ToXTypedElement(XElement.Parse(xml), LinqToXsdTypeManager.Instance)));
        }
        
		public static explicit operator subject(XElement xe) {  return (subject)XTypedServices.ToXTypedElement(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new subject(((SimpleLiteral)(this.Content.Clone())));
        }
        
        protected subject(bool setNull) : 
                base(true) {
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public subject() : 
                base(true) {
            SetInnerType(new SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                if ((this.ContentField != null)) {
                    this.ContentField.Untyped = value;
                }
            }
        }
        
        public new virtual SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(SimpleLiteral ContentField) {
            this.ContentField = ((SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        protected virtual void SetSubstitutionMember(SimpleLiteral ContentField) {
            this.ContentField = ContentField;
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public subject(SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("subject", "http://purl.org/dc/elements/1.1/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class description : global::purl.org.dc.elementsQualified.any, IXMetaData {
        
        public new static description Load(string xmlFile) {
            return ((description)(XTypedServices.ToXTypedElement(XElement.Load(xmlFile), LinqToXsdTypeManager.Instance)));
        }
        
        public static description Load(System.IO.TextReader xmlFile) {
            return ((description)(XTypedServices.ToXTypedElement(XElement.Load(xmlFile), LinqToXsdTypeManager.Instance)));
        }
        
        public new static description Parse(string xml) {
            return ((description)(XTypedServices.ToXTypedElement(XElement.Parse(xml), LinqToXsdTypeManager.Instance)));
        }
        
		public static explicit operator description(XElement xe) {  return (description)XTypedServices.ToXTypedElement(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new description(((SimpleLiteral)(this.Content.Clone())));
        }
        
        protected description(bool setNull) : 
                base(true) {
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public description() : 
                base(true) {
            SetInnerType(new SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                if ((this.ContentField != null)) {
                    this.ContentField.Untyped = value;
                }
            }
        }
        
        public new virtual SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(SimpleLiteral ContentField) {
            this.ContentField = ((SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        protected virtual void SetSubstitutionMember(SimpleLiteral ContentField) {
            this.ContentField = ContentField;
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public description(SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("description", "http://purl.org/dc/elements/1.1/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class publisher : global::purl.org.dc.elementsQualified.any, IXMetaData {
        
        public new static publisher Load(string xmlFile) {
            return ((publisher)(XTypedServices.ToXTypedElement(XElement.Load(xmlFile), LinqToXsdTypeManager.Instance)));
        }
        
        public static publisher Load(System.IO.TextReader xmlFile) {
            return ((publisher)(XTypedServices.ToXTypedElement(XElement.Load(xmlFile), LinqToXsdTypeManager.Instance)));
        }
        
        public new static publisher Parse(string xml) {
            return ((publisher)(XTypedServices.ToXTypedElement(XElement.Parse(xml), LinqToXsdTypeManager.Instance)));
        }
        
		public static explicit operator publisher(XElement xe) {  return (publisher)XTypedServices.ToXTypedElement(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new publisher(((SimpleLiteral)(this.Content.Clone())));
        }
        
        protected publisher(bool setNull) : 
                base(true) {
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public publisher() : 
                base(true) {
            SetInnerType(new SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                if ((this.ContentField != null)) {
                    this.ContentField.Untyped = value;
                }
            }
        }
        
        public new virtual SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(SimpleLiteral ContentField) {
            this.ContentField = ((SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        protected virtual void SetSubstitutionMember(SimpleLiteral ContentField) {
            this.ContentField = ContentField;
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public publisher(SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("publisher", "http://purl.org/dc/elements/1.1/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class contributor : global::purl.org.dc.elementsQualified.any, IXMetaData {
        
        public new static contributor Load(string xmlFile) {
            return ((contributor)(XTypedServices.ToXTypedElement(XElement.Load(xmlFile), LinqToXsdTypeManager.Instance)));
        }
        
        public static contributor Load(System.IO.TextReader xmlFile) {
            return ((contributor)(XTypedServices.ToXTypedElement(XElement.Load(xmlFile), LinqToXsdTypeManager.Instance)));
        }
        
        public new static contributor Parse(string xml) {
            return ((contributor)(XTypedServices.ToXTypedElement(XElement.Parse(xml), LinqToXsdTypeManager.Instance)));
        }
        
		public static explicit operator contributor(XElement xe) {  return (contributor)XTypedServices.ToXTypedElement(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new contributor(((SimpleLiteral)(this.Content.Clone())));
        }
        
        protected contributor(bool setNull) : 
                base(true) {
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public contributor() : 
                base(true) {
            SetInnerType(new SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                if ((this.ContentField != null)) {
                    this.ContentField.Untyped = value;
                }
            }
        }
        
        public new virtual SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(SimpleLiteral ContentField) {
            this.ContentField = ((SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        protected virtual void SetSubstitutionMember(SimpleLiteral ContentField) {
            this.ContentField = ContentField;
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public contributor(SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("contributor", "http://purl.org/dc/elements/1.1/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class date : global::purl.org.dc.elementsQualified.any, IXMetaData {
        
        public new static date Load(string xmlFile) {
            return ((date)(XTypedServices.ToXTypedElement(XElement.Load(xmlFile), LinqToXsdTypeManager.Instance)));
        }
        
        public static date Load(System.IO.TextReader xmlFile) {
            return ((date)(XTypedServices.ToXTypedElement(XElement.Load(xmlFile), LinqToXsdTypeManager.Instance)));
        }
        
        public new static date Parse(string xml) {
            return ((date)(XTypedServices.ToXTypedElement(XElement.Parse(xml), LinqToXsdTypeManager.Instance)));
        }
        
		public static explicit operator date(XElement xe) {  return (date)XTypedServices.ToXTypedElement(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new date(((SimpleLiteral)(this.Content.Clone())));
        }
        
        protected date(bool setNull) : 
                base(true) {
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public date() : 
                base(true) {
            SetInnerType(new SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                if ((this.ContentField != null)) {
                    this.ContentField.Untyped = value;
                }
            }
        }
        
        public new virtual SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(SimpleLiteral ContentField) {
            this.ContentField = ((SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        protected virtual void SetSubstitutionMember(SimpleLiteral ContentField) {
            this.ContentField = ContentField;
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public date(SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("date", "http://purl.org/dc/elements/1.1/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class type : global::purl.org.dc.elementsQualified.any, IXMetaData {
        
        public new static type Load(string xmlFile) {
            return ((type)(XTypedServices.ToXTypedElement(XElement.Load(xmlFile), LinqToXsdTypeManager.Instance)));
        }
        
        public static type Load(System.IO.TextReader xmlFile) {
            return ((type)(XTypedServices.ToXTypedElement(XElement.Load(xmlFile), LinqToXsdTypeManager.Instance)));
        }
        
        public new static type Parse(string xml) {
            return ((type)(XTypedServices.ToXTypedElement(XElement.Parse(xml), LinqToXsdTypeManager.Instance)));
        }
        
		public static explicit operator type(XElement xe) {  return (type)XTypedServices.ToXTypedElement(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new type(((SimpleLiteral)(this.Content.Clone())));
        }
        
        protected type(bool setNull) : 
                base(true) {
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public type() : 
                base(true) {
            SetInnerType(new SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                if ((this.ContentField != null)) {
                    this.ContentField.Untyped = value;
                }
            }
        }
        
        public new virtual SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(SimpleLiteral ContentField) {
            this.ContentField = ((SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        protected virtual void SetSubstitutionMember(SimpleLiteral ContentField) {
            this.ContentField = ContentField;
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public type(SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("type", "http://purl.org/dc/elements/1.1/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class format : global::purl.org.dc.elementsQualified.any, IXMetaData {
        
        public new static format Load(string xmlFile) {
            return ((format)(XTypedServices.ToXTypedElement(XElement.Load(xmlFile), LinqToXsdTypeManager.Instance)));
        }
        
        public static format Load(System.IO.TextReader xmlFile) {
            return ((format)(XTypedServices.ToXTypedElement(XElement.Load(xmlFile), LinqToXsdTypeManager.Instance)));
        }
        
        public new static format Parse(string xml) {
            return ((format)(XTypedServices.ToXTypedElement(XElement.Parse(xml), LinqToXsdTypeManager.Instance)));
        }
        
		public static explicit operator format(XElement xe) {  return (format)XTypedServices.ToXTypedElement(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new format(((SimpleLiteral)(this.Content.Clone())));
        }
        
        protected format(bool setNull) : 
                base(true) {
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public format() : 
                base(true) {
            SetInnerType(new SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                if ((this.ContentField != null)) {
                    this.ContentField.Untyped = value;
                }
            }
        }
        
        public new virtual SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(SimpleLiteral ContentField) {
            this.ContentField = ((SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        protected virtual void SetSubstitutionMember(SimpleLiteral ContentField) {
            this.ContentField = ContentField;
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public format(SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("format", "http://purl.org/dc/elements/1.1/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class identifier : global::purl.org.dc.elementsQualified.any, IXMetaData {
        
        public new static identifier Load(string xmlFile) {
            return ((identifier)(XTypedServices.ToXTypedElement(XElement.Load(xmlFile), LinqToXsdTypeManager.Instance)));
        }
        
        public static identifier Load(System.IO.TextReader xmlFile) {
            return ((identifier)(XTypedServices.ToXTypedElement(XElement.Load(xmlFile), LinqToXsdTypeManager.Instance)));
        }
        
        public new static identifier Parse(string xml) {
            return ((identifier)(XTypedServices.ToXTypedElement(XElement.Parse(xml), LinqToXsdTypeManager.Instance)));
        }
        
		public static explicit operator identifier(XElement xe) {  return (identifier)XTypedServices.ToXTypedElement(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new identifier(((SimpleLiteral)(this.Content.Clone())));
        }
        
        protected identifier(bool setNull) : 
                base(true) {
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public identifier() : 
                base(true) {
            SetInnerType(new SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                if ((this.ContentField != null)) {
                    this.ContentField.Untyped = value;
                }
            }
        }
        
        public new virtual SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(SimpleLiteral ContentField) {
            this.ContentField = ((SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        protected virtual void SetSubstitutionMember(SimpleLiteral ContentField) {
            this.ContentField = ContentField;
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public identifier(SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("identifier", "http://purl.org/dc/elements/1.1/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class source : global::purl.org.dc.elementsQualified.any, IXMetaData {
        
        public new static source Load(string xmlFile) {
            return ((source)(XTypedServices.ToXTypedElement(XElement.Load(xmlFile), LinqToXsdTypeManager.Instance)));
        }
        
        public static source Load(System.IO.TextReader xmlFile) {
            return ((source)(XTypedServices.ToXTypedElement(XElement.Load(xmlFile), LinqToXsdTypeManager.Instance)));
        }
        
        public new static source Parse(string xml) {
            return ((source)(XTypedServices.ToXTypedElement(XElement.Parse(xml), LinqToXsdTypeManager.Instance)));
        }
        
		public static explicit operator source(XElement xe) {  return (source)XTypedServices.ToXTypedElement(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new source(((SimpleLiteral)(this.Content.Clone())));
        }
        
        protected source(bool setNull) : 
                base(true) {
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public source() : 
                base(true) {
            SetInnerType(new SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                if ((this.ContentField != null)) {
                    this.ContentField.Untyped = value;
                }
            }
        }
        
        public new virtual SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(SimpleLiteral ContentField) {
            this.ContentField = ((SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        protected virtual void SetSubstitutionMember(SimpleLiteral ContentField) {
            this.ContentField = ContentField;
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public source(SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("source", "http://purl.org/dc/elements/1.1/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class language : global::purl.org.dc.elementsQualified.any, IXMetaData {
        
        public new static language Load(string xmlFile) {
            return ((language)(XTypedServices.ToXTypedElement(XElement.Load(xmlFile), LinqToXsdTypeManager.Instance)));
        }
        
        public static language Load(System.IO.TextReader xmlFile) {
            return ((language)(XTypedServices.ToXTypedElement(XElement.Load(xmlFile), LinqToXsdTypeManager.Instance)));
        }
        
        public new static language Parse(string xml) {
            return ((language)(XTypedServices.ToXTypedElement(XElement.Parse(xml), LinqToXsdTypeManager.Instance)));
        }
        
		public static explicit operator language(XElement xe) {  return (language)XTypedServices.ToXTypedElement(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new language(((SimpleLiteral)(this.Content.Clone())));
        }
        
        protected language(bool setNull) : 
                base(true) {
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public language() : 
                base(true) {
            SetInnerType(new SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                if ((this.ContentField != null)) {
                    this.ContentField.Untyped = value;
                }
            }
        }
        
        public new virtual SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(SimpleLiteral ContentField) {
            this.ContentField = ((SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        protected virtual void SetSubstitutionMember(SimpleLiteral ContentField) {
            this.ContentField = ContentField;
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public language(SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("language", "http://purl.org/dc/elements/1.1/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class relation : global::purl.org.dc.elementsQualified.any, IXMetaData {
        
        public new static relation Load(string xmlFile) {
            return ((relation)(XTypedServices.ToXTypedElement(XElement.Load(xmlFile), LinqToXsdTypeManager.Instance)));
        }
        
        public static relation Load(System.IO.TextReader xmlFile) {
            return ((relation)(XTypedServices.ToXTypedElement(XElement.Load(xmlFile), LinqToXsdTypeManager.Instance)));
        }
        
        public new static relation Parse(string xml) {
            return ((relation)(XTypedServices.ToXTypedElement(XElement.Parse(xml), LinqToXsdTypeManager.Instance)));
        }
        
		public static explicit operator relation(XElement xe) {  return (relation)XTypedServices.ToXTypedElement(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new relation(((SimpleLiteral)(this.Content.Clone())));
        }
        
        protected relation(bool setNull) : 
                base(true) {
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public relation() : 
                base(true) {
            SetInnerType(new SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                if ((this.ContentField != null)) {
                    this.ContentField.Untyped = value;
                }
            }
        }
        
        public new virtual SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(SimpleLiteral ContentField) {
            this.ContentField = ((SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        protected virtual void SetSubstitutionMember(SimpleLiteral ContentField) {
            this.ContentField = ContentField;
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public relation(SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("relation", "http://purl.org/dc/elements/1.1/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class coverage : global::purl.org.dc.elementsQualified.any, IXMetaData {
        
        public new static coverage Load(string xmlFile) {
            return ((coverage)(XTypedServices.ToXTypedElement(XElement.Load(xmlFile), LinqToXsdTypeManager.Instance)));
        }
        
        public static coverage Load(System.IO.TextReader xmlFile) {
            return ((coverage)(XTypedServices.ToXTypedElement(XElement.Load(xmlFile), LinqToXsdTypeManager.Instance)));
        }
        
        public new static coverage Parse(string xml) {
            return ((coverage)(XTypedServices.ToXTypedElement(XElement.Parse(xml), LinqToXsdTypeManager.Instance)));
        }
        
		public static explicit operator coverage(XElement xe) {  return (coverage)XTypedServices.ToXTypedElement(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new coverage(((SimpleLiteral)(this.Content.Clone())));
        }
        
        protected coverage(bool setNull) : 
                base(true) {
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public coverage() : 
                base(true) {
            SetInnerType(new SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                if ((this.ContentField != null)) {
                    this.ContentField.Untyped = value;
                }
            }
        }
        
        public new virtual SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(SimpleLiteral ContentField) {
            this.ContentField = ((SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        protected virtual void SetSubstitutionMember(SimpleLiteral ContentField) {
            this.ContentField = ContentField;
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public coverage(SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("coverage", "http://purl.org/dc/elements/1.1/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class rights : global::purl.org.dc.elementsQualified.any, IXMetaData {
        
        public new static rights Load(string xmlFile) {
            return ((rights)(XTypedServices.ToXTypedElement(XElement.Load(xmlFile), LinqToXsdTypeManager.Instance)));
        }
        
        public static rights Load(System.IO.TextReader xmlFile) {
            return ((rights)(XTypedServices.ToXTypedElement(XElement.Load(xmlFile), LinqToXsdTypeManager.Instance)));
        }
        
        public new static rights Parse(string xml) {
            return ((rights)(XTypedServices.ToXTypedElement(XElement.Parse(xml), LinqToXsdTypeManager.Instance)));
        }
        
		public static explicit operator rights(XElement xe) {  return (rights)XTypedServices.ToXTypedElement(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new rights(((SimpleLiteral)(this.Content.Clone())));
        }
        
        protected rights(bool setNull) : 
                base(true) {
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public rights() : 
                base(true) {
            SetInnerType(new SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                if ((this.ContentField != null)) {
                    this.ContentField.Untyped = value;
                }
            }
        }
        
        public new virtual SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(SimpleLiteral ContentField) {
            this.ContentField = ((SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        protected virtual void SetSubstitutionMember(SimpleLiteral ContentField) {
            this.ContentField = ContentField;
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public rights(SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("rights", "http://purl.org/dc/elements/1.1/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    public partial class XRootNamespace {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XDocument doc;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedElement rootObject;
        
        private XRootNamespace() {
        }
        
        public static XRootNamespace Load(string xmlFile) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Load(xmlFile);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRootNamespace Load(string xmlFile, LoadOptions options) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Load(xmlFile, options);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRootNamespace Load(TextReader textReader) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Load(textReader);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRootNamespace Load(TextReader textReader, LoadOptions options) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Load(textReader, options);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRootNamespace Load(XmlReader xmlReader) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Load(xmlReader);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRootNamespace Parse(string text) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Parse(text);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRootNamespace Parse(string text, LoadOptions options) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Parse(text, options);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public virtual void Save(string fileName) {
            doc.Save(fileName);
        }
        
        public virtual void Save(TextWriter textWriter) {
            doc.Save(textWriter);
        }
        
        public virtual void Save(XmlWriter writer) {
            doc.Save(writer);
        }
        
        public virtual void Save(TextWriter textWriter, SaveOptions options) {
            doc.Save(textWriter, options);
        }
        
        public virtual void Save(string fileName, SaveOptions options) {
            doc.Save(fileName, options);
        }
        
        public virtual XDocument XDocument {
            get {
                return doc;
            }
        }
        
        public virtual XTypedElement Root {
            get {
                return rootObject;
            }
        }
        
        public XRootNamespace(any root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public any any {  get {return rootObject as any; } }
        
        public XRootNamespace(title root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public title title {  get {return rootObject as title; } }
        
        public XRootNamespace(creator root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public creator creator {  get {return rootObject as creator; } }
        
        public XRootNamespace(subject root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public subject subject {  get {return rootObject as subject; } }
        
        public XRootNamespace(description root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public description description {  get {return rootObject as description; } }
        
        public XRootNamespace(publisher root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public publisher publisher {  get {return rootObject as publisher; } }
        
        public XRootNamespace(contributor root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public contributor contributor {  get {return rootObject as contributor; } }
        
        public XRootNamespace(date root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public date date {  get {return rootObject as date; } }
        
        public XRootNamespace(type root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public type type {  get {return rootObject as type; } }
        
        public XRootNamespace(format root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public format format {  get {return rootObject as format; } }
        
        public XRootNamespace(identifier root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public identifier identifier {  get {return rootObject as identifier; } }
        
        public XRootNamespace(source root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public source source {  get {return rootObject as source; } }
        
        public XRootNamespace(language root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public language language {  get {return rootObject as language; } }
        
        public XRootNamespace(relation root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public relation relation {  get {return rootObject as relation; } }
        
        public XRootNamespace(coverage root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public coverage coverage {  get {return rootObject as coverage; } }
        
        public XRootNamespace(rights root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public rights rights {  get {return rootObject as rights; } }
    }
}
namespace purl.org.dc.dcmitype {
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.IO;
    using System.Linq;
    using System.Diagnostics;
    using System.Xml;
    using System.Xml.Schema;
    using System.Xml.Linq;
    using Xml.Schema.Linq;
    using purl.org.dc.qualifiedContainer;
    
    
    public sealed class DCMIType {
        
        private DCMIType() {
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.UnionSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.AnyAtomicType), null, new Xml.Schema.Linq.SimpleTypeValidator[] {
                    new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Name), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                                    "Collection",
                                    "Dataset",
                                    "Event",
                                    "Image",
                                    "MovingImage",
                                    "StillImage",
                                    "InteractiveResource",
                                    "Service",
                                    "Software",
                                    "Sound",
                                    "Text",
                                    "PhysicalObject"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Collapse))});
    }
}
namespace purl.org.dc.qualifiedContainer {
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.IO;
    using System.Linq;
    using System.Diagnostics;
    using System.Xml;
    using System.Xml.Schema;
    using System.Xml.Linq;
    using Xml.Schema.Linq;
    using W3C.XmlNs3;
    using purl.org.dc.termsQualified;
    using purl.org.dc.elementsQualified;
    using purl.org.dc.dcmitype;
    
    
    /// <summary>
    /// <para>
    /// 
    ///    		This is included as a convenience for schema authors who need to define a root
    ///    		or container element for all of the DC elements and element refinements.
    ///    	
    /// </para>
    /// </summary>
    public partial class qualifieddc : XTypedElement, IXMetaData {
        
        public void Save(string xmlFile) {
            XTypedServices.Save(xmlFile, Untyped);
        }
        
        public void Save(System.IO.TextWriter tw) {
            XTypedServices.Save(tw, Untyped);
        }
        
        public void Save(System.Xml.XmlWriter xmlWriter) {
            XTypedServices.Save(xmlWriter, Untyped);
        }
        
        public static qualifieddc Load(string xmlFile) {
            return XTypedServices.Load<qualifieddc, purl.org.dc.termsQualified.elementOrRefinementContainer>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static qualifieddc Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<qualifieddc, purl.org.dc.termsQualified.elementOrRefinementContainer>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static qualifieddc Parse(string xml) {
            return XTypedServices.Parse<qualifieddc, purl.org.dc.termsQualified.elementOrRefinementContainer>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator qualifieddc(XElement xe) { return XTypedServices.ToXTypedElement<qualifieddc, purl.org.dc.termsQualified.elementOrRefinementContainer>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new qualifieddc(((purl.org.dc.termsQualified.elementOrRefinementContainer)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private purl.org.dc.termsQualified.elementOrRefinementContainer ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///    		This is included as a convenience for schema authors who need to define a root
        ///    		or container element for all of the DC elements and element refinements.
        ///    	
        /// </para>
        /// </summary>
        public qualifieddc() {
            SetInnerType(new purl.org.dc.termsQualified.elementOrRefinementContainer());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public virtual purl.org.dc.termsQualified.elementOrRefinementContainer Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(purl.org.dc.termsQualified.elementOrRefinementContainer ContentField) {
            this.ContentField = ((purl.org.dc.termsQualified.elementOrRefinementContainer)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///    		This is included as a convenience for schema authors who need to define a root
        ///    		or container element for all of the DC elements and element refinements.
        ///    	
        /// </para>
        /// </summary>
        public qualifieddc(purl.org.dc.termsQualified.elementOrRefinementContainer content) {
            SetInnerType(content);
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Setter: Appends
        /// </para>
        /// <para>
        /// Substitution members: any, title, creator, subject, description, publisher, contributor, date, type, format, identifier, source, language, relation, coverage, rights, alternative, tableOfContents, abstract, created, valid, available, issued, modified, dateAccepted, dateCopyrighted, dateSubmitted, extent, medium, isVersionOf, hasVersion, isReplacedBy, replaces, isRequiredBy, requires, isPartOf, hasPart, isReferencedBy, references, isFormatOf, hasFormat, conformsTo, spatial, temporal, audience, accrualMethod, accrualPeriodicity, accrualPolicy, instructionalMethod, provenance, rightsHolder, mediator, educationLevel, accessRights, license, bibliographicCitation, title, creator, subject, description, publisher, contributor, date, type, format, identifier, source, language, relation, coverage, rights
        /// </para>
        /// <para>
        /// Regular expression: (((any)*))
        /// </para>
        /// </summary>
        public virtual IList<purl.org.dc.elementsQualified.any> any {
            get {
                return this.ContentField.any;
            }
            set {
                this.ContentField.any = value;
            }
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("qualifieddc", "");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    public class LinqToXsdTypeManager : ILinqToXsdTypeManager {
        
        private LinqToXsdTypeManager() {
        }
        
        private static Dictionary<System.Xml.Linq.XName, System.Type> typeDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        private static void BuildTypeDictionary() {
            typeDictionary.Add(System.Xml.Linq.XName.Get("LCSH", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.LCSH));
            typeDictionary.Add(System.Xml.Linq.XName.Get("MESH", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.MESH));
            typeDictionary.Add(System.Xml.Linq.XName.Get("DDC", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.DDC));
            typeDictionary.Add(System.Xml.Linq.XName.Get("LCC", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.LCC));
            typeDictionary.Add(System.Xml.Linq.XName.Get("UDC", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.UDC));
            typeDictionary.Add(System.Xml.Linq.XName.Get("Period", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.Period));
            typeDictionary.Add(System.Xml.Linq.XName.Get("W3CDTF", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.W3CDTF));
            typeDictionary.Add(System.Xml.Linq.XName.Get("DCMIType", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.DCMIType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("IMT", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.IMT));
            typeDictionary.Add(System.Xml.Linq.XName.Get("URI", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.URI));
            typeDictionary.Add(System.Xml.Linq.XName.Get("ISO639-2", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.ISO6392));
            typeDictionary.Add(System.Xml.Linq.XName.Get("ISO639-3", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.ISO6393));
            typeDictionary.Add(System.Xml.Linq.XName.Get("RFC1766", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.RFC1766));
            typeDictionary.Add(System.Xml.Linq.XName.Get("RFC3066", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.RFC3066));
            typeDictionary.Add(System.Xml.Linq.XName.Get("RFC4646", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.RFC4646));
            typeDictionary.Add(System.Xml.Linq.XName.Get("Point", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.Point));
            typeDictionary.Add(System.Xml.Linq.XName.Get("ISO3166", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.ISO3166));
            typeDictionary.Add(System.Xml.Linq.XName.Get("Box", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.Box));
            typeDictionary.Add(System.Xml.Linq.XName.Get("TGN", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.TGN));
            typeDictionary.Add(System.Xml.Linq.XName.Get("elementOrRefinementContainer", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.elementOrRefinementContainer));
            typeDictionary.Add(System.Xml.Linq.XName.Get("SimpleLiteral", "http://purl.org/dc/elements/1.1/"), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            typeDictionary.Add(System.Xml.Linq.XName.Get("elementContainer", "http://purl.org/dc/elements/1.1/"), typeof(global::purl.org.dc.elementsQualified.elementContainer));
        }
        
        private static Dictionary<System.Xml.Linq.XName, System.Type> elementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        private static void BuildElementDictionary() {
            elementDictionary.Add(System.Xml.Linq.XName.Get("qualifieddc", ""), typeof(global::purl.org.dc.qualifiedContainer.qualifieddc));
            elementDictionary.Add(System.Xml.Linq.XName.Get("title", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.title));
            elementDictionary.Add(System.Xml.Linq.XName.Get("creator", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.creator));
            elementDictionary.Add(System.Xml.Linq.XName.Get("subject", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.subject));
            elementDictionary.Add(System.Xml.Linq.XName.Get("description", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.description));
            elementDictionary.Add(System.Xml.Linq.XName.Get("publisher", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.publisher));
            elementDictionary.Add(System.Xml.Linq.XName.Get("contributor", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.contributor));
            elementDictionary.Add(System.Xml.Linq.XName.Get("date", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.date));
            elementDictionary.Add(System.Xml.Linq.XName.Get("type", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.type));
            elementDictionary.Add(System.Xml.Linq.XName.Get("format", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.format));
            elementDictionary.Add(System.Xml.Linq.XName.Get("identifier", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.identifier));
            elementDictionary.Add(System.Xml.Linq.XName.Get("source", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.source));
            elementDictionary.Add(System.Xml.Linq.XName.Get("language", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.language));
            elementDictionary.Add(System.Xml.Linq.XName.Get("relation", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.relation));
            elementDictionary.Add(System.Xml.Linq.XName.Get("coverage", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.coverage));
            elementDictionary.Add(System.Xml.Linq.XName.Get("rights", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.rights));
            elementDictionary.Add(System.Xml.Linq.XName.Get("alternative", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.alternative));
            elementDictionary.Add(System.Xml.Linq.XName.Get("tableOfContents", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.tableOfContents));
            elementDictionary.Add(System.Xml.Linq.XName.Get("abstract", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.@abstract));
            elementDictionary.Add(System.Xml.Linq.XName.Get("created", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.created));
            elementDictionary.Add(System.Xml.Linq.XName.Get("valid", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.valid));
            elementDictionary.Add(System.Xml.Linq.XName.Get("available", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.available));
            elementDictionary.Add(System.Xml.Linq.XName.Get("issued", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.issued));
            elementDictionary.Add(System.Xml.Linq.XName.Get("modified", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.modified));
            elementDictionary.Add(System.Xml.Linq.XName.Get("dateAccepted", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.dateAccepted));
            elementDictionary.Add(System.Xml.Linq.XName.Get("dateCopyrighted", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.dateCopyrighted));
            elementDictionary.Add(System.Xml.Linq.XName.Get("dateSubmitted", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.dateSubmitted));
            elementDictionary.Add(System.Xml.Linq.XName.Get("extent", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.extent));
            elementDictionary.Add(System.Xml.Linq.XName.Get("medium", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.medium));
            elementDictionary.Add(System.Xml.Linq.XName.Get("isVersionOf", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.isVersionOf));
            elementDictionary.Add(System.Xml.Linq.XName.Get("hasVersion", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.hasVersion));
            elementDictionary.Add(System.Xml.Linq.XName.Get("isReplacedBy", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.isReplacedBy));
            elementDictionary.Add(System.Xml.Linq.XName.Get("replaces", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.replaces));
            elementDictionary.Add(System.Xml.Linq.XName.Get("isRequiredBy", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.isRequiredBy));
            elementDictionary.Add(System.Xml.Linq.XName.Get("requires", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.requires));
            elementDictionary.Add(System.Xml.Linq.XName.Get("isPartOf", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.isPartOf));
            elementDictionary.Add(System.Xml.Linq.XName.Get("hasPart", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.hasPart));
            elementDictionary.Add(System.Xml.Linq.XName.Get("isReferencedBy", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.isReferencedBy));
            elementDictionary.Add(System.Xml.Linq.XName.Get("references", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.references));
            elementDictionary.Add(System.Xml.Linq.XName.Get("isFormatOf", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.isFormatOf));
            elementDictionary.Add(System.Xml.Linq.XName.Get("hasFormat", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.hasFormat));
            elementDictionary.Add(System.Xml.Linq.XName.Get("conformsTo", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.conformsTo));
            elementDictionary.Add(System.Xml.Linq.XName.Get("spatial", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.spatial));
            elementDictionary.Add(System.Xml.Linq.XName.Get("temporal", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.temporal));
            elementDictionary.Add(System.Xml.Linq.XName.Get("audience", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.audience));
            elementDictionary.Add(System.Xml.Linq.XName.Get("accrualMethod", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.accrualMethod));
            elementDictionary.Add(System.Xml.Linq.XName.Get("accrualPeriodicity", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.accrualPeriodicity));
            elementDictionary.Add(System.Xml.Linq.XName.Get("accrualPolicy", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.accrualPolicy));
            elementDictionary.Add(System.Xml.Linq.XName.Get("instructionalMethod", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.instructionalMethod));
            elementDictionary.Add(System.Xml.Linq.XName.Get("provenance", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.provenance));
            elementDictionary.Add(System.Xml.Linq.XName.Get("rightsHolder", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.rightsHolder));
            elementDictionary.Add(System.Xml.Linq.XName.Get("mediator", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.mediator));
            elementDictionary.Add(System.Xml.Linq.XName.Get("educationLevel", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.educationLevel));
            elementDictionary.Add(System.Xml.Linq.XName.Get("accessRights", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.accessRights));
            elementDictionary.Add(System.Xml.Linq.XName.Get("license", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.license));
            elementDictionary.Add(System.Xml.Linq.XName.Get("bibliographicCitation", "http://purl.org/dc/terms/"), typeof(global::purl.org.dc.termsQualified.bibliographicCitation));
            elementDictionary.Add(System.Xml.Linq.XName.Get("any", "http://purl.org/dc/elements/1.1/"), typeof(global::purl.org.dc.elementsQualified.any));
            elementDictionary.Add(System.Xml.Linq.XName.Get("title", "http://purl.org/dc/elements/1.1/"), typeof(global::purl.org.dc.elementsQualified.title));
            elementDictionary.Add(System.Xml.Linq.XName.Get("creator", "http://purl.org/dc/elements/1.1/"), typeof(global::purl.org.dc.elementsQualified.creator));
            elementDictionary.Add(System.Xml.Linq.XName.Get("subject", "http://purl.org/dc/elements/1.1/"), typeof(global::purl.org.dc.elementsQualified.subject));
            elementDictionary.Add(System.Xml.Linq.XName.Get("description", "http://purl.org/dc/elements/1.1/"), typeof(global::purl.org.dc.elementsQualified.description));
            elementDictionary.Add(System.Xml.Linq.XName.Get("publisher", "http://purl.org/dc/elements/1.1/"), typeof(global::purl.org.dc.elementsQualified.publisher));
            elementDictionary.Add(System.Xml.Linq.XName.Get("contributor", "http://purl.org/dc/elements/1.1/"), typeof(global::purl.org.dc.elementsQualified.contributor));
            elementDictionary.Add(System.Xml.Linq.XName.Get("date", "http://purl.org/dc/elements/1.1/"), typeof(global::purl.org.dc.elementsQualified.date));
            elementDictionary.Add(System.Xml.Linq.XName.Get("type", "http://purl.org/dc/elements/1.1/"), typeof(global::purl.org.dc.elementsQualified.type));
            elementDictionary.Add(System.Xml.Linq.XName.Get("format", "http://purl.org/dc/elements/1.1/"), typeof(global::purl.org.dc.elementsQualified.format));
            elementDictionary.Add(System.Xml.Linq.XName.Get("identifier", "http://purl.org/dc/elements/1.1/"), typeof(global::purl.org.dc.elementsQualified.identifier));
            elementDictionary.Add(System.Xml.Linq.XName.Get("source", "http://purl.org/dc/elements/1.1/"), typeof(global::purl.org.dc.elementsQualified.source));
            elementDictionary.Add(System.Xml.Linq.XName.Get("language", "http://purl.org/dc/elements/1.1/"), typeof(global::purl.org.dc.elementsQualified.language));
            elementDictionary.Add(System.Xml.Linq.XName.Get("relation", "http://purl.org/dc/elements/1.1/"), typeof(global::purl.org.dc.elementsQualified.relation));
            elementDictionary.Add(System.Xml.Linq.XName.Get("coverage", "http://purl.org/dc/elements/1.1/"), typeof(global::purl.org.dc.elementsQualified.coverage));
            elementDictionary.Add(System.Xml.Linq.XName.Get("rights", "http://purl.org/dc/elements/1.1/"), typeof(global::purl.org.dc.elementsQualified.rights));
        }
        
        private static Dictionary<System.Type, System.Type> wrapperDictionary = new Dictionary<System.Type, System.Type>();
        
        private static void BuildWrapperDictionary() {
            wrapperDictionary.Add(typeof(purl.org.dc.qualifiedContainer.qualifieddc), typeof(global::purl.org.dc.termsQualified.elementOrRefinementContainer));
            wrapperDictionary.Add(typeof(purl.org.dc.termsQualified.title), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.termsQualified.creator), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.termsQualified.subject), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.termsQualified.description), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.termsQualified.publisher), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.termsQualified.contributor), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.termsQualified.date), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.termsQualified.type), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.termsQualified.format), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.termsQualified.identifier), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.termsQualified.source), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.termsQualified.language), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.termsQualified.relation), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.termsQualified.coverage), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.termsQualified.rights), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.termsQualified.alternative), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.termsQualified.tableOfContents), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.termsQualified.@abstract), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.termsQualified.created), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.termsQualified.valid), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.termsQualified.available), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.termsQualified.issued), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.termsQualified.modified), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.termsQualified.dateAccepted), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.termsQualified.dateCopyrighted), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.termsQualified.dateSubmitted), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.termsQualified.extent), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.termsQualified.medium), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.termsQualified.isVersionOf), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.termsQualified.hasVersion), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.termsQualified.isReplacedBy), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.termsQualified.replaces), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.termsQualified.isRequiredBy), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.termsQualified.requires), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.termsQualified.isPartOf), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.termsQualified.hasPart), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.termsQualified.isReferencedBy), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.termsQualified.references), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.termsQualified.isFormatOf), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.termsQualified.hasFormat), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.termsQualified.conformsTo), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.termsQualified.spatial), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.termsQualified.temporal), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.termsQualified.audience), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.termsQualified.accrualMethod), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.termsQualified.accrualPeriodicity), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.termsQualified.accrualPolicy), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.termsQualified.instructionalMethod), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.termsQualified.provenance), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.termsQualified.rightsHolder), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.termsQualified.mediator), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.termsQualified.educationLevel), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.termsQualified.accessRights), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.termsQualified.license), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.termsQualified.bibliographicCitation), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.elementsQualified.any), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.elementsQualified.title), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.elementsQualified.creator), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.elementsQualified.subject), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.elementsQualified.description), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.elementsQualified.publisher), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.elementsQualified.contributor), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.elementsQualified.date), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.elementsQualified.type), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.elementsQualified.format), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.elementsQualified.identifier), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.elementsQualified.source), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.elementsQualified.language), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.elementsQualified.relation), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.elementsQualified.coverage), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
            wrapperDictionary.Add(typeof(purl.org.dc.elementsQualified.rights), typeof(global::purl.org.dc.elementsQualified.SimpleLiteral));
        }
        
        private static XmlSchemaSet schemaSet;
        
        XmlSchemaSet ILinqToXsdTypeManager.Schemas {
            get {
                if ((schemaSet == null)) {
                    XmlSchemaSet tempSet = new XmlSchemaSet();
                    System.Threading.Interlocked.CompareExchange(ref schemaSet, tempSet, null);
                }
                return schemaSet;
            }
            set {
                schemaSet = value;
            }
        }
        
        protected internal static void AddSchemas(XmlSchemaSet schemas) {
            schemas.Add(schemaSet);
        }
        
        Dictionary<System.Xml.Linq.XName, System.Type> ILinqToXsdTypeManager.GlobalTypeDictionary {
            get {
                return typeDictionary;
            }
        }
        
        Dictionary<System.Xml.Linq.XName, System.Type> ILinqToXsdTypeManager.GlobalElementDictionary {
            get {
                return elementDictionary;
            }
        }
        
        Dictionary<System.Type, System.Type> ILinqToXsdTypeManager.RootContentTypeMapping {
            get {
                return wrapperDictionary;
            }
        }
        
        static LinqToXsdTypeManager() {
            BuildTypeDictionary();
            BuildElementDictionary();
            BuildWrapperDictionary();
        }
        
        public static System.Type GetRootType() {
            return elementDictionary[System.Xml.Linq.XName.Get("qualifieddc", "")];
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static LinqToXsdTypeManager typeManagerSingleton = new LinqToXsdTypeManager();
        
        public static LinqToXsdTypeManager Instance {
            get {
                return typeManagerSingleton;
            }
        }
    }
    
    public partial class XRootNamespace {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XDocument doc;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedElement rootObject;
        
        private XRootNamespace() {
        }
        
        public static XRootNamespace Load(string xmlFile) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Load(xmlFile);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRootNamespace Load(string xmlFile, LoadOptions options) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Load(xmlFile, options);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRootNamespace Load(TextReader textReader) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Load(textReader);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRootNamespace Load(TextReader textReader, LoadOptions options) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Load(textReader, options);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRootNamespace Load(XmlReader xmlReader) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Load(xmlReader);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRootNamespace Parse(string text) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Parse(text);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRootNamespace Parse(string text, LoadOptions options) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Parse(text, options);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public virtual void Save(string fileName) {
            doc.Save(fileName);
        }
        
        public virtual void Save(TextWriter textWriter) {
            doc.Save(textWriter);
        }
        
        public virtual void Save(XmlWriter writer) {
            doc.Save(writer);
        }
        
        public virtual void Save(TextWriter textWriter, SaveOptions options) {
            doc.Save(textWriter, options);
        }
        
        public virtual void Save(string fileName, SaveOptions options) {
            doc.Save(fileName, options);
        }
        
        public virtual XDocument XDocument {
            get {
                return doc;
            }
        }
        
        public virtual XTypedElement Root {
            get {
                return rootObject;
            }
        }
        
        public XRootNamespace(qualifieddc root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public qualifieddc qualifieddc {  get {return rootObject as qualifieddc; } }
    }
    
    public partial class XRoot {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XDocument doc;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedElement rootObject;
        
        private XRoot() {
        }
        
        public static XRoot Load(string xmlFile) {
            XRoot root = new XRoot();
            root.doc = XDocument.Load(xmlFile);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRoot Load(string xmlFile, LoadOptions options) {
            XRoot root = new XRoot();
            root.doc = XDocument.Load(xmlFile, options);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRoot Load(TextReader textReader) {
            XRoot root = new XRoot();
            root.doc = XDocument.Load(textReader);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRoot Load(TextReader textReader, LoadOptions options) {
            XRoot root = new XRoot();
            root.doc = XDocument.Load(textReader, options);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRoot Load(XmlReader xmlReader) {
            XRoot root = new XRoot();
            root.doc = XDocument.Load(xmlReader);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRoot Parse(string text) {
            XRoot root = new XRoot();
            root.doc = XDocument.Parse(text);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRoot Parse(string text, LoadOptions options) {
            XRoot root = new XRoot();
            root.doc = XDocument.Parse(text, options);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public virtual void Save(string fileName) {
            doc.Save(fileName);
        }
        
        public virtual void Save(TextWriter textWriter) {
            doc.Save(textWriter);
        }
        
        public virtual void Save(XmlWriter writer) {
            doc.Save(writer);
        }
        
        public virtual void Save(TextWriter textWriter, SaveOptions options) {
            doc.Save(textWriter, options);
        }
        
        public virtual void Save(string fileName, SaveOptions options) {
            doc.Save(fileName, options);
        }
        
        public virtual XDocument XDocument {
            get {
                return doc;
            }
        }
        
        public virtual XTypedElement Root {
            get {
                return rootObject;
            }
        }
        
        public XRoot(global::purl.org.dc.qualifiedContainer.qualifieddc root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.qualifiedContainer.qualifieddc qualifieddc {  get {return rootObject as global::purl.org.dc.qualifiedContainer.qualifieddc; } }
        
        public XRoot(global::purl.org.dc.termsQualified.title root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.termsQualified.title title {  get {return rootObject as global::purl.org.dc.termsQualified.title; } }
        
        public XRoot(global::purl.org.dc.termsQualified.creator root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.termsQualified.creator creator {  get {return rootObject as global::purl.org.dc.termsQualified.creator; } }
        
        public XRoot(global::purl.org.dc.termsQualified.subject root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.termsQualified.subject subject {  get {return rootObject as global::purl.org.dc.termsQualified.subject; } }
        
        public XRoot(global::purl.org.dc.termsQualified.description root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.termsQualified.description description {  get {return rootObject as global::purl.org.dc.termsQualified.description; } }
        
        public XRoot(global::purl.org.dc.termsQualified.publisher root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.termsQualified.publisher publisher {  get {return rootObject as global::purl.org.dc.termsQualified.publisher; } }
        
        public XRoot(global::purl.org.dc.termsQualified.contributor root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.termsQualified.contributor contributor {  get {return rootObject as global::purl.org.dc.termsQualified.contributor; } }
        
        public XRoot(global::purl.org.dc.termsQualified.date root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.termsQualified.date date {  get {return rootObject as global::purl.org.dc.termsQualified.date; } }
        
        public XRoot(global::purl.org.dc.termsQualified.type root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.termsQualified.type type {  get {return rootObject as global::purl.org.dc.termsQualified.type; } }
        
        public XRoot(global::purl.org.dc.termsQualified.format root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.termsQualified.format format {  get {return rootObject as global::purl.org.dc.termsQualified.format; } }
        
        public XRoot(global::purl.org.dc.termsQualified.identifier root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.termsQualified.identifier identifier {  get {return rootObject as global::purl.org.dc.termsQualified.identifier; } }
        
        public XRoot(global::purl.org.dc.termsQualified.source root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.termsQualified.source source {  get {return rootObject as global::purl.org.dc.termsQualified.source; } }
        
        public XRoot(global::purl.org.dc.termsQualified.language root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.termsQualified.language language {  get {return rootObject as global::purl.org.dc.termsQualified.language; } }
        
        public XRoot(global::purl.org.dc.termsQualified.relation root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.termsQualified.relation relation {  get {return rootObject as global::purl.org.dc.termsQualified.relation; } }
        
        public XRoot(global::purl.org.dc.termsQualified.coverage root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.termsQualified.coverage coverage {  get {return rootObject as global::purl.org.dc.termsQualified.coverage; } }
        
        public XRoot(global::purl.org.dc.termsQualified.rights root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.termsQualified.rights rights {  get {return rootObject as global::purl.org.dc.termsQualified.rights; } }
        
        public XRoot(global::purl.org.dc.termsQualified.alternative root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.termsQualified.alternative alternative {  get {return rootObject as global::purl.org.dc.termsQualified.alternative; } }
        
        public XRoot(global::purl.org.dc.termsQualified.tableOfContents root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.termsQualified.tableOfContents tableOfContents {  get {return rootObject as global::purl.org.dc.termsQualified.tableOfContents; } }
        
        public XRoot(global::purl.org.dc.termsQualified.@abstract root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.termsQualified.@abstract @abstract {  get {return rootObject as global::purl.org.dc.termsQualified.@abstract; } }
        
        public XRoot(global::purl.org.dc.termsQualified.created root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.termsQualified.created created {  get {return rootObject as global::purl.org.dc.termsQualified.created; } }
        
        public XRoot(global::purl.org.dc.termsQualified.valid root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.termsQualified.valid valid {  get {return rootObject as global::purl.org.dc.termsQualified.valid; } }
        
        public XRoot(global::purl.org.dc.termsQualified.available root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.termsQualified.available available {  get {return rootObject as global::purl.org.dc.termsQualified.available; } }
        
        public XRoot(global::purl.org.dc.termsQualified.issued root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.termsQualified.issued issued {  get {return rootObject as global::purl.org.dc.termsQualified.issued; } }
        
        public XRoot(global::purl.org.dc.termsQualified.modified root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.termsQualified.modified modified {  get {return rootObject as global::purl.org.dc.termsQualified.modified; } }
        
        public XRoot(global::purl.org.dc.termsQualified.dateAccepted root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.termsQualified.dateAccepted dateAccepted {  get {return rootObject as global::purl.org.dc.termsQualified.dateAccepted; } }
        
        public XRoot(global::purl.org.dc.termsQualified.dateCopyrighted root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.termsQualified.dateCopyrighted dateCopyrighted {  get {return rootObject as global::purl.org.dc.termsQualified.dateCopyrighted; } }
        
        public XRoot(global::purl.org.dc.termsQualified.dateSubmitted root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.termsQualified.dateSubmitted dateSubmitted {  get {return rootObject as global::purl.org.dc.termsQualified.dateSubmitted; } }
        
        public XRoot(global::purl.org.dc.termsQualified.extent root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.termsQualified.extent extent {  get {return rootObject as global::purl.org.dc.termsQualified.extent; } }
        
        public XRoot(global::purl.org.dc.termsQualified.medium root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.termsQualified.medium medium {  get {return rootObject as global::purl.org.dc.termsQualified.medium; } }
        
        public XRoot(global::purl.org.dc.termsQualified.isVersionOf root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.termsQualified.isVersionOf isVersionOf {  get {return rootObject as global::purl.org.dc.termsQualified.isVersionOf; } }
        
        public XRoot(global::purl.org.dc.termsQualified.hasVersion root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.termsQualified.hasVersion hasVersion {  get {return rootObject as global::purl.org.dc.termsQualified.hasVersion; } }
        
        public XRoot(global::purl.org.dc.termsQualified.isReplacedBy root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.termsQualified.isReplacedBy isReplacedBy {  get {return rootObject as global::purl.org.dc.termsQualified.isReplacedBy; } }
        
        public XRoot(global::purl.org.dc.termsQualified.replaces root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.termsQualified.replaces replaces {  get {return rootObject as global::purl.org.dc.termsQualified.replaces; } }
        
        public XRoot(global::purl.org.dc.termsQualified.isRequiredBy root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.termsQualified.isRequiredBy isRequiredBy {  get {return rootObject as global::purl.org.dc.termsQualified.isRequiredBy; } }
        
        public XRoot(global::purl.org.dc.termsQualified.requires root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.termsQualified.requires requires {  get {return rootObject as global::purl.org.dc.termsQualified.requires; } }
        
        public XRoot(global::purl.org.dc.termsQualified.isPartOf root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.termsQualified.isPartOf isPartOf {  get {return rootObject as global::purl.org.dc.termsQualified.isPartOf; } }
        
        public XRoot(global::purl.org.dc.termsQualified.hasPart root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.termsQualified.hasPart hasPart {  get {return rootObject as global::purl.org.dc.termsQualified.hasPart; } }
        
        public XRoot(global::purl.org.dc.termsQualified.isReferencedBy root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.termsQualified.isReferencedBy isReferencedBy {  get {return rootObject as global::purl.org.dc.termsQualified.isReferencedBy; } }
        
        public XRoot(global::purl.org.dc.termsQualified.references root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.termsQualified.references references {  get {return rootObject as global::purl.org.dc.termsQualified.references; } }
        
        public XRoot(global::purl.org.dc.termsQualified.isFormatOf root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.termsQualified.isFormatOf isFormatOf {  get {return rootObject as global::purl.org.dc.termsQualified.isFormatOf; } }
        
        public XRoot(global::purl.org.dc.termsQualified.hasFormat root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.termsQualified.hasFormat hasFormat {  get {return rootObject as global::purl.org.dc.termsQualified.hasFormat; } }
        
        public XRoot(global::purl.org.dc.termsQualified.conformsTo root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.termsQualified.conformsTo conformsTo {  get {return rootObject as global::purl.org.dc.termsQualified.conformsTo; } }
        
        public XRoot(global::purl.org.dc.termsQualified.spatial root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.termsQualified.spatial spatial {  get {return rootObject as global::purl.org.dc.termsQualified.spatial; } }
        
        public XRoot(global::purl.org.dc.termsQualified.temporal root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.termsQualified.temporal temporal {  get {return rootObject as global::purl.org.dc.termsQualified.temporal; } }
        
        public XRoot(global::purl.org.dc.termsQualified.audience root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.termsQualified.audience audience {  get {return rootObject as global::purl.org.dc.termsQualified.audience; } }
        
        public XRoot(global::purl.org.dc.termsQualified.accrualMethod root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.termsQualified.accrualMethod accrualMethod {  get {return rootObject as global::purl.org.dc.termsQualified.accrualMethod; } }
        
        public XRoot(global::purl.org.dc.termsQualified.accrualPeriodicity root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.termsQualified.accrualPeriodicity accrualPeriodicity {  get {return rootObject as global::purl.org.dc.termsQualified.accrualPeriodicity; } }
        
        public XRoot(global::purl.org.dc.termsQualified.accrualPolicy root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.termsQualified.accrualPolicy accrualPolicy {  get {return rootObject as global::purl.org.dc.termsQualified.accrualPolicy; } }
        
        public XRoot(global::purl.org.dc.termsQualified.instructionalMethod root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.termsQualified.instructionalMethod instructionalMethod {  get {return rootObject as global::purl.org.dc.termsQualified.instructionalMethod; } }
        
        public XRoot(global::purl.org.dc.termsQualified.provenance root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.termsQualified.provenance provenance {  get {return rootObject as global::purl.org.dc.termsQualified.provenance; } }
        
        public XRoot(global::purl.org.dc.termsQualified.rightsHolder root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.termsQualified.rightsHolder rightsHolder {  get {return rootObject as global::purl.org.dc.termsQualified.rightsHolder; } }
        
        public XRoot(global::purl.org.dc.termsQualified.mediator root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.termsQualified.mediator mediator {  get {return rootObject as global::purl.org.dc.termsQualified.mediator; } }
        
        public XRoot(global::purl.org.dc.termsQualified.educationLevel root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.termsQualified.educationLevel educationLevel {  get {return rootObject as global::purl.org.dc.termsQualified.educationLevel; } }
        
        public XRoot(global::purl.org.dc.termsQualified.accessRights root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.termsQualified.accessRights accessRights {  get {return rootObject as global::purl.org.dc.termsQualified.accessRights; } }
        
        public XRoot(global::purl.org.dc.termsQualified.license root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.termsQualified.license license {  get {return rootObject as global::purl.org.dc.termsQualified.license; } }
        
        public XRoot(global::purl.org.dc.termsQualified.bibliographicCitation root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.termsQualified.bibliographicCitation bibliographicCitation {  get {return rootObject as global::purl.org.dc.termsQualified.bibliographicCitation; } }
        
        public XRoot(global::purl.org.dc.elementsQualified.any root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.elementsQualified.any any {  get {return rootObject as global::purl.org.dc.elementsQualified.any; } }
        
        public XRoot(global::purl.org.dc.elementsQualified.title root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.elementsQualified.title title1 {  get {return rootObject as global::purl.org.dc.elementsQualified.title; } }
        
        public XRoot(global::purl.org.dc.elementsQualified.creator root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.elementsQualified.creator creator1 {  get {return rootObject as global::purl.org.dc.elementsQualified.creator; } }
        
        public XRoot(global::purl.org.dc.elementsQualified.subject root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.elementsQualified.subject subject1 {  get {return rootObject as global::purl.org.dc.elementsQualified.subject; } }
        
        public XRoot(global::purl.org.dc.elementsQualified.description root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.elementsQualified.description description1 {  get {return rootObject as global::purl.org.dc.elementsQualified.description; } }
        
        public XRoot(global::purl.org.dc.elementsQualified.publisher root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.elementsQualified.publisher publisher1 {  get {return rootObject as global::purl.org.dc.elementsQualified.publisher; } }
        
        public XRoot(global::purl.org.dc.elementsQualified.contributor root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.elementsQualified.contributor contributor1 {  get {return rootObject as global::purl.org.dc.elementsQualified.contributor; } }
        
        public XRoot(global::purl.org.dc.elementsQualified.date root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.elementsQualified.date date1 {  get {return rootObject as global::purl.org.dc.elementsQualified.date; } }
        
        public XRoot(global::purl.org.dc.elementsQualified.type root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.elementsQualified.type type1 {  get {return rootObject as global::purl.org.dc.elementsQualified.type; } }
        
        public XRoot(global::purl.org.dc.elementsQualified.format root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.elementsQualified.format format1 {  get {return rootObject as global::purl.org.dc.elementsQualified.format; } }
        
        public XRoot(global::purl.org.dc.elementsQualified.identifier root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.elementsQualified.identifier identifier1 {  get {return rootObject as global::purl.org.dc.elementsQualified.identifier; } }
        
        public XRoot(global::purl.org.dc.elementsQualified.source root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.elementsQualified.source source1 {  get {return rootObject as global::purl.org.dc.elementsQualified.source; } }
        
        public XRoot(global::purl.org.dc.elementsQualified.language root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.elementsQualified.language language1 {  get {return rootObject as global::purl.org.dc.elementsQualified.language; } }
        
        public XRoot(global::purl.org.dc.elementsQualified.relation root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.elementsQualified.relation relation1 {  get {return rootObject as global::purl.org.dc.elementsQualified.relation; } }
        
        public XRoot(global::purl.org.dc.elementsQualified.coverage root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.elementsQualified.coverage coverage1 {  get {return rootObject as global::purl.org.dc.elementsQualified.coverage; } }
        
        public XRoot(global::purl.org.dc.elementsQualified.rights root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::purl.org.dc.elementsQualified.rights rights1 {  get {return rootObject as global::purl.org.dc.elementsQualified.rights; } }
    }
}
