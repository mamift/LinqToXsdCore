//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace W3C.XmlNs1 {
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.IO;
    using System.Linq;
    using System.Diagnostics;
    using System.Xml;
    using System.Xml.Schema;
    using System.Xml.Linq;
    using Xml.Schema.Linq;
    using Purl.Dcmes.Elements;
    
    
    public sealed class lang {
        
        private lang() {
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.UnionSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.AnyAtomicType), null, new Xml.Schema.Linq.SimpleTypeValidator[] {
                    new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Language), null),
                    new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                                    ""}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve))});
    }
}
namespace Purl.Dcmes.Elements {
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.IO;
    using System.Linq;
    using System.Diagnostics;
    using System.Xml;
    using System.Xml.Schema;
    using System.Xml.Linq;
    using Xml.Schema.Linq;
    using W3C.XmlNs1;
    
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class SimpleLiteral : XTypedElement, IXMetaData {
        
		public static explicit operator SimpleLiteral(XElement xe) { return XTypedServices.ToXTypedElement<SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<SimpleLiteral>(this);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public SimpleLiteral() {
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName langXName = System.Xml.Linq.XName.Get("lang", "http://www.w3.org/XML/1998/namespace");
        
        /// <summary>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual object lang {
            get {
                XAttribute x = this.Attribute(langXName);
                return XTypedServices.ParseUnionValue(x, global::W3C.XmlNs1.lang.TypeDefinition);
            }
            set {
                this.SetUnionAttribute(value, "lang", this, langXName, global::W3C.XmlNs1.lang.TypeDefinition);
            }
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("SimpleLiteral", "http://purl.org/dc/elements/1.1/");
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///    		This complexType is included as a convenience for schema authors who need to define a root
    ///    		or container element for all of the DC elements.
    ///    	
    /// </para>
    /// <para>
    /// Regular expression: (((any)*))
    /// </para>
    /// </summary>
    public partial class elementContainer : XTypedElement, IXMetaData {
        
		public static explicit operator elementContainer(XElement xe) { return XTypedServices.ToXTypedElement<elementContainer>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<elementContainer>(this);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///    		This complexType is included as a convenience for schema authors who need to define a root
        ///    		or container element for all of the DC elements.
        ///    	
        /// </para>
        /// <para>
        /// Regular expression: (((any)*))
        /// </para>
        /// </summary>
        public elementContainer() {
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName anyXName = System.Xml.Linq.XName.Get("any", "http://purl.org/dc/elements/1.1/");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedSubstitutedList<any> anyField;
        
        /// <summary>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Setter: Appends
        /// </para>
        /// <para>
        /// Substitution members: any, title, creator, subject, description, publisher, contributor, date, type, format, identifier, source, language, relation, coverage, rights
        /// </para>
        /// <para>
        /// Regular expression: (((any)*))
        /// </para>
        /// </summary>
        public virtual IList<any> any {
            get {
                if ((this.anyField == null)) {
                    this.anyField = new XTypedSubstitutedList<any>(this, LinqToXsdTypeManager.Instance, System.Xml.Linq.XName.Get("any", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("title", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("creator", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("subject", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("description", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("publisher", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("contributor", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("date", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("type", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("format", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("identifier", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("source", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("language", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("relation", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("coverage", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("rights", "http://purl.org/dc/elements/1.1/"));
                }
                return this.anyField;
            }
            set {
                if ((value == null)) {
                    this.anyField = null;
                }
                else {
                    if ((this.anyField == null)) {
                        this.anyField = XTypedSubstitutedList<any>.Initialize(this, LinqToXsdTypeManager.Instance, value, System.Xml.Linq.XName.Get("any", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("title", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("creator", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("subject", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("description", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("publisher", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("contributor", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("date", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("type", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("format", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("identifier", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("source", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("language", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("relation", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("coverage", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("rights", "http://purl.org/dc/elements/1.1/"));
                    }
                    else {
                        XTypedServices.SetList<any>(this.anyField, value);
                    }
                }
            }
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("elementContainer", "http://purl.org/dc/elements/1.1/");
        
        static elementContainer() {
            BuildElementDictionary();
            contentModel = new ChoiceContentModelEntity(new SequenceContentModelEntity(new ChoiceContentModelEntity(new SubstitutedContentModelEntity(System.Xml.Linq.XName.Get("any", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("title", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("creator", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("subject", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("description", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("publisher", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("contributor", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("date", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("type", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("format", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("identifier", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("source", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("language", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("relation", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("coverage", "http://purl.org/dc/elements/1.1/"), System.Xml.Linq.XName.Get("rights", "http://purl.org/dc/elements/1.1/")))));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(anyXName, typeof(any));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public abstract partial class any : XTypedElement, IXMetaData {
        
        public void Save(string xmlFile) {
            XTypedServices.Save(xmlFile, Untyped);
        }
        
        public void Save(System.IO.TextWriter tw) {
            XTypedServices.Save(tw, Untyped);
        }
        
        public void Save(System.Xml.XmlWriter xmlWriter) {
            XTypedServices.Save(xmlWriter, Untyped);
        }
        
        public static any Load(string xmlFile) {
            return ((any)(XTypedServices.ToXTypedElement(XElement.Load(xmlFile), LinqToXsdTypeManager.Instance)));
        }
        
        public static any Load(System.IO.TextReader xmlFile) {
            return ((any)(XTypedServices.ToXTypedElement(XElement.Load(xmlFile), LinqToXsdTypeManager.Instance)));
        }
        
        public static any Parse(string xml) {
            return ((any)(XTypedServices.ToXTypedElement(XElement.Parse(xml), LinqToXsdTypeManager.Instance)));
        }
        
		public static explicit operator any(XElement xe) {  return (any)XTypedServices.ToXTypedElement(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        protected any(bool setNull) {
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public any() {
            SetInnerType(new SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                if ((this.ContentField != null)) {
                    this.ContentField.Untyped = value;
                }
            }
        }
        
        public virtual SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(SimpleLiteral ContentField) {
            this.ContentField = ((SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
        }
        
        protected virtual void SetSubstitutionMember(SimpleLiteral ContentField) {
            this.ContentField = ContentField;
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public any(SimpleLiteral content) {
            SetInnerType(content);
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual object lang {
            get {
                return this.ContentField.lang;
            }
            set {
                this.ContentField.lang = value;
            }
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("any", "http://purl.org/dc/elements/1.1/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class title : global::Purl.Dcmes.Elements.any, IXMetaData {
        
        public new static title Load(string xmlFile) {
            return XTypedServices.Load<title, SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static title Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<title, SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static title Parse(string xml) {
            return XTypedServices.Parse<title, SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator title(XElement xe) { return XTypedServices.ToXTypedElement<title, SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new title(((SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public title() : 
                base(true) {
            SetInnerType(new SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(SimpleLiteral ContentField) {
            this.ContentField = ((SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public title(SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("title", "http://purl.org/dc/elements/1.1/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class creator : global::Purl.Dcmes.Elements.any, IXMetaData {
        
        public new static creator Load(string xmlFile) {
            return XTypedServices.Load<creator, SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static creator Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<creator, SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static creator Parse(string xml) {
            return XTypedServices.Parse<creator, SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator creator(XElement xe) { return XTypedServices.ToXTypedElement<creator, SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new creator(((SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public creator() : 
                base(true) {
            SetInnerType(new SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(SimpleLiteral ContentField) {
            this.ContentField = ((SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public creator(SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("creator", "http://purl.org/dc/elements/1.1/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class subject : global::Purl.Dcmes.Elements.any, IXMetaData {
        
        public new static subject Load(string xmlFile) {
            return XTypedServices.Load<subject, SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static subject Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<subject, SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static subject Parse(string xml) {
            return XTypedServices.Parse<subject, SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator subject(XElement xe) { return XTypedServices.ToXTypedElement<subject, SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new subject(((SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public subject() : 
                base(true) {
            SetInnerType(new SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(SimpleLiteral ContentField) {
            this.ContentField = ((SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public subject(SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("subject", "http://purl.org/dc/elements/1.1/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class description : global::Purl.Dcmes.Elements.any, IXMetaData {
        
        public new static description Load(string xmlFile) {
            return XTypedServices.Load<description, SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static description Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<description, SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static description Parse(string xml) {
            return XTypedServices.Parse<description, SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator description(XElement xe) { return XTypedServices.ToXTypedElement<description, SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new description(((SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public description() : 
                base(true) {
            SetInnerType(new SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(SimpleLiteral ContentField) {
            this.ContentField = ((SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public description(SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("description", "http://purl.org/dc/elements/1.1/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class publisher : global::Purl.Dcmes.Elements.any, IXMetaData {
        
        public new static publisher Load(string xmlFile) {
            return XTypedServices.Load<publisher, SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static publisher Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<publisher, SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static publisher Parse(string xml) {
            return XTypedServices.Parse<publisher, SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator publisher(XElement xe) { return XTypedServices.ToXTypedElement<publisher, SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new publisher(((SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public publisher() : 
                base(true) {
            SetInnerType(new SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(SimpleLiteral ContentField) {
            this.ContentField = ((SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public publisher(SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("publisher", "http://purl.org/dc/elements/1.1/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class contributor : global::Purl.Dcmes.Elements.any, IXMetaData {
        
        public new static contributor Load(string xmlFile) {
            return XTypedServices.Load<contributor, SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static contributor Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<contributor, SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static contributor Parse(string xml) {
            return XTypedServices.Parse<contributor, SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator contributor(XElement xe) { return XTypedServices.ToXTypedElement<contributor, SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new contributor(((SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public contributor() : 
                base(true) {
            SetInnerType(new SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(SimpleLiteral ContentField) {
            this.ContentField = ((SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public contributor(SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("contributor", "http://purl.org/dc/elements/1.1/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class date : global::Purl.Dcmes.Elements.any, IXMetaData {
        
        public new static date Load(string xmlFile) {
            return XTypedServices.Load<date, SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static date Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<date, SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static date Parse(string xml) {
            return XTypedServices.Parse<date, SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator date(XElement xe) { return XTypedServices.ToXTypedElement<date, SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new date(((SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public date() : 
                base(true) {
            SetInnerType(new SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(SimpleLiteral ContentField) {
            this.ContentField = ((SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public date(SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("date", "http://purl.org/dc/elements/1.1/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class type : global::Purl.Dcmes.Elements.any, IXMetaData {
        
        public new static type Load(string xmlFile) {
            return XTypedServices.Load<type, SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static type Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<type, SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static type Parse(string xml) {
            return XTypedServices.Parse<type, SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator type(XElement xe) { return XTypedServices.ToXTypedElement<type, SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new type(((SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public type() : 
                base(true) {
            SetInnerType(new SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(SimpleLiteral ContentField) {
            this.ContentField = ((SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public type(SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("type", "http://purl.org/dc/elements/1.1/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class format : global::Purl.Dcmes.Elements.any, IXMetaData {
        
        public new static format Load(string xmlFile) {
            return XTypedServices.Load<format, SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static format Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<format, SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static format Parse(string xml) {
            return XTypedServices.Parse<format, SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator format(XElement xe) { return XTypedServices.ToXTypedElement<format, SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new format(((SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public format() : 
                base(true) {
            SetInnerType(new SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(SimpleLiteral ContentField) {
            this.ContentField = ((SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public format(SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("format", "http://purl.org/dc/elements/1.1/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class identifier : global::Purl.Dcmes.Elements.any, IXMetaData {
        
        public new static identifier Load(string xmlFile) {
            return XTypedServices.Load<identifier, SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static identifier Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<identifier, SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static identifier Parse(string xml) {
            return XTypedServices.Parse<identifier, SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator identifier(XElement xe) { return XTypedServices.ToXTypedElement<identifier, SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new identifier(((SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public identifier() : 
                base(true) {
            SetInnerType(new SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(SimpleLiteral ContentField) {
            this.ContentField = ((SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public identifier(SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("identifier", "http://purl.org/dc/elements/1.1/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class source : global::Purl.Dcmes.Elements.any, IXMetaData {
        
        public new static source Load(string xmlFile) {
            return XTypedServices.Load<source, SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static source Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<source, SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static source Parse(string xml) {
            return XTypedServices.Parse<source, SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator source(XElement xe) { return XTypedServices.ToXTypedElement<source, SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new source(((SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public source() : 
                base(true) {
            SetInnerType(new SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(SimpleLiteral ContentField) {
            this.ContentField = ((SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public source(SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("source", "http://purl.org/dc/elements/1.1/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class language : global::Purl.Dcmes.Elements.any, IXMetaData {
        
        public new static language Load(string xmlFile) {
            return XTypedServices.Load<language, SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static language Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<language, SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static language Parse(string xml) {
            return XTypedServices.Parse<language, SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator language(XElement xe) { return XTypedServices.ToXTypedElement<language, SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new language(((SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public language() : 
                base(true) {
            SetInnerType(new SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(SimpleLiteral ContentField) {
            this.ContentField = ((SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public language(SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("language", "http://purl.org/dc/elements/1.1/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class relation : global::Purl.Dcmes.Elements.any, IXMetaData {
        
        public new static relation Load(string xmlFile) {
            return XTypedServices.Load<relation, SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static relation Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<relation, SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static relation Parse(string xml) {
            return XTypedServices.Parse<relation, SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator relation(XElement xe) { return XTypedServices.ToXTypedElement<relation, SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new relation(((SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public relation() : 
                base(true) {
            SetInnerType(new SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(SimpleLiteral ContentField) {
            this.ContentField = ((SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public relation(SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("relation", "http://purl.org/dc/elements/1.1/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class coverage : global::Purl.Dcmes.Elements.any, IXMetaData {
        
        public new static coverage Load(string xmlFile) {
            return XTypedServices.Load<coverage, SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static coverage Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<coverage, SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static coverage Parse(string xml) {
            return XTypedServices.Parse<coverage, SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator coverage(XElement xe) { return XTypedServices.ToXTypedElement<coverage, SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new coverage(((SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public coverage() : 
                base(true) {
            SetInnerType(new SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(SimpleLiteral ContentField) {
            this.ContentField = ((SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public coverage(SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("coverage", "http://purl.org/dc/elements/1.1/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///            This is the default type for all of the DC elements.
    ///            It permits text content only with optional
    ///            xml:lang attribute.
    ///            Text is allowed because mixed="true", but sub-elements
    ///            are disallowed because minOccurs="0" and maxOccurs="0" 
    ///            are on the xs:any tag.
    ///
    ///    	    This complexType allows for restriction or extension permitting
    ///            child elements.
    ///    	
    /// </para>
    /// </summary>
    public partial class rights : global::Purl.Dcmes.Elements.any, IXMetaData {
        
        public new static rights Load(string xmlFile) {
            return XTypedServices.Load<rights, SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static rights Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<rights, SimpleLiteral>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public new static rights Parse(string xml) {
            return XTypedServices.Parse<rights, SimpleLiteral>(xml, LinqToXsdTypeManager.Instance);
        }
        
		public static explicit operator rights(XElement xe) { return XTypedServices.ToXTypedElement<rights, SimpleLiteral>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public override XTypedElement Clone() {
            return new rights(((SimpleLiteral)(this.Content.Clone())));
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private SimpleLiteral ContentField;
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public rights() : 
                base(true) {
            SetInnerType(new SimpleLiteral());
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public new virtual SimpleLiteral Content {
            get {
                return ContentField;
            }
        }
        
        private void SetInnerType(SimpleLiteral ContentField) {
            this.ContentField = ((SimpleLiteral)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
            base.SetSubstitutionMember(ContentField);
        }
        
        /// <summary>
        /// <para>
        /// 
        ///            This is the default type for all of the DC elements.
        ///            It permits text content only with optional
        ///            xml:lang attribute.
        ///            Text is allowed because mixed="true", but sub-elements
        ///            are disallowed because minOccurs="0" and maxOccurs="0" 
        ///            are on the xs:any tag.
        ///
        ///    	    This complexType allows for restriction or extension permitting
        ///            child elements.
        ///    	
        /// </para>
        /// </summary>
        public rights(SimpleLiteral content) : 
                base(true) {
            SetInnerType(content);
        }
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("rights", "http://purl.org/dc/elements/1.1/");
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
    }
    
    public class LinqToXsdTypeManager : ILinqToXsdTypeManager {
        
        private LinqToXsdTypeManager() {
        }
        
        private static Dictionary<System.Xml.Linq.XName, System.Type> typeDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        private static void BuildTypeDictionary() {
            typeDictionary.Add(System.Xml.Linq.XName.Get("SimpleLiteral", "http://purl.org/dc/elements/1.1/"), typeof(global::Purl.Dcmes.Elements.SimpleLiteral));
            typeDictionary.Add(System.Xml.Linq.XName.Get("elementContainer", "http://purl.org/dc/elements/1.1/"), typeof(global::Purl.Dcmes.Elements.elementContainer));
        }
        
        private static Dictionary<System.Xml.Linq.XName, System.Type> elementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        private static void BuildElementDictionary() {
            elementDictionary.Add(System.Xml.Linq.XName.Get("any", "http://purl.org/dc/elements/1.1/"), typeof(global::Purl.Dcmes.Elements.any));
            elementDictionary.Add(System.Xml.Linq.XName.Get("title", "http://purl.org/dc/elements/1.1/"), typeof(global::Purl.Dcmes.Elements.title));
            elementDictionary.Add(System.Xml.Linq.XName.Get("creator", "http://purl.org/dc/elements/1.1/"), typeof(global::Purl.Dcmes.Elements.creator));
            elementDictionary.Add(System.Xml.Linq.XName.Get("subject", "http://purl.org/dc/elements/1.1/"), typeof(global::Purl.Dcmes.Elements.subject));
            elementDictionary.Add(System.Xml.Linq.XName.Get("description", "http://purl.org/dc/elements/1.1/"), typeof(global::Purl.Dcmes.Elements.description));
            elementDictionary.Add(System.Xml.Linq.XName.Get("publisher", "http://purl.org/dc/elements/1.1/"), typeof(global::Purl.Dcmes.Elements.publisher));
            elementDictionary.Add(System.Xml.Linq.XName.Get("contributor", "http://purl.org/dc/elements/1.1/"), typeof(global::Purl.Dcmes.Elements.contributor));
            elementDictionary.Add(System.Xml.Linq.XName.Get("date", "http://purl.org/dc/elements/1.1/"), typeof(global::Purl.Dcmes.Elements.date));
            elementDictionary.Add(System.Xml.Linq.XName.Get("type", "http://purl.org/dc/elements/1.1/"), typeof(global::Purl.Dcmes.Elements.type));
            elementDictionary.Add(System.Xml.Linq.XName.Get("format", "http://purl.org/dc/elements/1.1/"), typeof(global::Purl.Dcmes.Elements.format));
            elementDictionary.Add(System.Xml.Linq.XName.Get("identifier", "http://purl.org/dc/elements/1.1/"), typeof(global::Purl.Dcmes.Elements.identifier));
            elementDictionary.Add(System.Xml.Linq.XName.Get("source", "http://purl.org/dc/elements/1.1/"), typeof(global::Purl.Dcmes.Elements.source));
            elementDictionary.Add(System.Xml.Linq.XName.Get("language", "http://purl.org/dc/elements/1.1/"), typeof(global::Purl.Dcmes.Elements.language));
            elementDictionary.Add(System.Xml.Linq.XName.Get("relation", "http://purl.org/dc/elements/1.1/"), typeof(global::Purl.Dcmes.Elements.relation));
            elementDictionary.Add(System.Xml.Linq.XName.Get("coverage", "http://purl.org/dc/elements/1.1/"), typeof(global::Purl.Dcmes.Elements.coverage));
            elementDictionary.Add(System.Xml.Linq.XName.Get("rights", "http://purl.org/dc/elements/1.1/"), typeof(global::Purl.Dcmes.Elements.rights));
        }
        
        private static Dictionary<System.Type, System.Type> wrapperDictionary = new Dictionary<System.Type, System.Type>();
        
        private static void BuildWrapperDictionary() {
            wrapperDictionary.Add(typeof(Purl.Dcmes.Elements.any), typeof(global::Purl.Dcmes.Elements.SimpleLiteral));
            wrapperDictionary.Add(typeof(Purl.Dcmes.Elements.title), typeof(global::Purl.Dcmes.Elements.SimpleLiteral));
            wrapperDictionary.Add(typeof(Purl.Dcmes.Elements.creator), typeof(global::Purl.Dcmes.Elements.SimpleLiteral));
            wrapperDictionary.Add(typeof(Purl.Dcmes.Elements.subject), typeof(global::Purl.Dcmes.Elements.SimpleLiteral));
            wrapperDictionary.Add(typeof(Purl.Dcmes.Elements.description), typeof(global::Purl.Dcmes.Elements.SimpleLiteral));
            wrapperDictionary.Add(typeof(Purl.Dcmes.Elements.publisher), typeof(global::Purl.Dcmes.Elements.SimpleLiteral));
            wrapperDictionary.Add(typeof(Purl.Dcmes.Elements.contributor), typeof(global::Purl.Dcmes.Elements.SimpleLiteral));
            wrapperDictionary.Add(typeof(Purl.Dcmes.Elements.date), typeof(global::Purl.Dcmes.Elements.SimpleLiteral));
            wrapperDictionary.Add(typeof(Purl.Dcmes.Elements.type), typeof(global::Purl.Dcmes.Elements.SimpleLiteral));
            wrapperDictionary.Add(typeof(Purl.Dcmes.Elements.format), typeof(global::Purl.Dcmes.Elements.SimpleLiteral));
            wrapperDictionary.Add(typeof(Purl.Dcmes.Elements.identifier), typeof(global::Purl.Dcmes.Elements.SimpleLiteral));
            wrapperDictionary.Add(typeof(Purl.Dcmes.Elements.source), typeof(global::Purl.Dcmes.Elements.SimpleLiteral));
            wrapperDictionary.Add(typeof(Purl.Dcmes.Elements.language), typeof(global::Purl.Dcmes.Elements.SimpleLiteral));
            wrapperDictionary.Add(typeof(Purl.Dcmes.Elements.relation), typeof(global::Purl.Dcmes.Elements.SimpleLiteral));
            wrapperDictionary.Add(typeof(Purl.Dcmes.Elements.coverage), typeof(global::Purl.Dcmes.Elements.SimpleLiteral));
            wrapperDictionary.Add(typeof(Purl.Dcmes.Elements.rights), typeof(global::Purl.Dcmes.Elements.SimpleLiteral));
        }
        
        private static XmlSchemaSet schemaSet;
        
        XmlSchemaSet ILinqToXsdTypeManager.Schemas {
            get {
                if ((schemaSet == null)) {
                    XmlSchemaSet tempSet = new XmlSchemaSet();
                    System.Threading.Interlocked.CompareExchange(ref schemaSet, tempSet, null);
                }
                return schemaSet;
            }
            set {
                schemaSet = value;
            }
        }
        
        protected internal static void AddSchemas(XmlSchemaSet schemas) {
            schemas.Add(schemaSet);
        }
        
        Dictionary<System.Xml.Linq.XName, System.Type> ILinqToXsdTypeManager.GlobalTypeDictionary {
            get {
                return typeDictionary;
            }
        }
        
        Dictionary<System.Xml.Linq.XName, System.Type> ILinqToXsdTypeManager.GlobalElementDictionary {
            get {
                return elementDictionary;
            }
        }
        
        Dictionary<System.Type, System.Type> ILinqToXsdTypeManager.RootContentTypeMapping {
            get {
                return wrapperDictionary;
            }
        }
        
        static LinqToXsdTypeManager() {
            BuildTypeDictionary();
            BuildElementDictionary();
            BuildWrapperDictionary();
        }
        
        public static System.Type GetRootType() {
            return elementDictionary[System.Xml.Linq.XName.Get("any", "http://purl.org/dc/elements/1.1/")];
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static LinqToXsdTypeManager typeManagerSingleton = new LinqToXsdTypeManager();
        
        public static LinqToXsdTypeManager Instance {
            get {
                return typeManagerSingleton;
            }
        }
    }
    
    public partial class XRootNamespace {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XDocument doc;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedElement rootObject;
        
        private XRootNamespace() {
        }
        
        public static XRootNamespace Load(string xmlFile) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Load(xmlFile);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRootNamespace Load(string xmlFile, LoadOptions options) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Load(xmlFile, options);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRootNamespace Load(TextReader textReader) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Load(textReader);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRootNamespace Load(TextReader textReader, LoadOptions options) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Load(textReader, options);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRootNamespace Load(XmlReader xmlReader) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Load(xmlReader);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRootNamespace Parse(string text) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Parse(text);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRootNamespace Parse(string text, LoadOptions options) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Parse(text, options);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public virtual void Save(string fileName) {
            doc.Save(fileName);
        }
        
        public virtual void Save(TextWriter textWriter) {
            doc.Save(textWriter);
        }
        
        public virtual void Save(XmlWriter writer) {
            doc.Save(writer);
        }
        
        public virtual void Save(TextWriter textWriter, SaveOptions options) {
            doc.Save(textWriter, options);
        }
        
        public virtual void Save(string fileName, SaveOptions options) {
            doc.Save(fileName, options);
        }
        
        public virtual XDocument XDocument {
            get {
                return doc;
            }
        }
        
        public virtual XTypedElement Root {
            get {
                return rootObject;
            }
        }
        
        public XRootNamespace(any root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public any any {  get {return rootObject as any; } }
        
        public XRootNamespace(title root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public title title {  get {return rootObject as title; } }
        
        public XRootNamespace(creator root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public creator creator {  get {return rootObject as creator; } }
        
        public XRootNamespace(subject root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public subject subject {  get {return rootObject as subject; } }
        
        public XRootNamespace(description root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public description description {  get {return rootObject as description; } }
        
        public XRootNamespace(publisher root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public publisher publisher {  get {return rootObject as publisher; } }
        
        public XRootNamespace(contributor root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public contributor contributor {  get {return rootObject as contributor; } }
        
        public XRootNamespace(date root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public date date {  get {return rootObject as date; } }
        
        public XRootNamespace(type root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public type type {  get {return rootObject as type; } }
        
        public XRootNamespace(format root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public format format {  get {return rootObject as format; } }
        
        public XRootNamespace(identifier root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public identifier identifier {  get {return rootObject as identifier; } }
        
        public XRootNamespace(source root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public source source {  get {return rootObject as source; } }
        
        public XRootNamespace(language root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public language language {  get {return rootObject as language; } }
        
        public XRootNamespace(relation root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public relation relation {  get {return rootObject as relation; } }
        
        public XRootNamespace(coverage root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public coverage coverage {  get {return rootObject as coverage; } }
        
        public XRootNamespace(rights root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public rights rights {  get {return rootObject as rights; } }
    }
    
    public partial class XRoot {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XDocument doc;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedElement rootObject;
        
        private XRoot() {
        }
        
        public static XRoot Load(string xmlFile) {
            XRoot root = new XRoot();
            root.doc = XDocument.Load(xmlFile);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRoot Load(string xmlFile, LoadOptions options) {
            XRoot root = new XRoot();
            root.doc = XDocument.Load(xmlFile, options);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRoot Load(TextReader textReader) {
            XRoot root = new XRoot();
            root.doc = XDocument.Load(textReader);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRoot Load(TextReader textReader, LoadOptions options) {
            XRoot root = new XRoot();
            root.doc = XDocument.Load(textReader, options);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRoot Load(XmlReader xmlReader) {
            XRoot root = new XRoot();
            root.doc = XDocument.Load(xmlReader);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRoot Parse(string text) {
            XRoot root = new XRoot();
            root.doc = XDocument.Parse(text);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRoot Parse(string text, LoadOptions options) {
            XRoot root = new XRoot();
            root.doc = XDocument.Parse(text, options);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public virtual void Save(string fileName) {
            doc.Save(fileName);
        }
        
        public virtual void Save(TextWriter textWriter) {
            doc.Save(textWriter);
        }
        
        public virtual void Save(XmlWriter writer) {
            doc.Save(writer);
        }
        
        public virtual void Save(TextWriter textWriter, SaveOptions options) {
            doc.Save(textWriter, options);
        }
        
        public virtual void Save(string fileName, SaveOptions options) {
            doc.Save(fileName, options);
        }
        
        public virtual XDocument XDocument {
            get {
                return doc;
            }
        }
        
        public virtual XTypedElement Root {
            get {
                return rootObject;
            }
        }
        
        public XRoot(global::Purl.Dcmes.Elements.any root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::Purl.Dcmes.Elements.any any {  get {return rootObject as global::Purl.Dcmes.Elements.any; } }
        
        public XRoot(global::Purl.Dcmes.Elements.title root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::Purl.Dcmes.Elements.title title {  get {return rootObject as global::Purl.Dcmes.Elements.title; } }
        
        public XRoot(global::Purl.Dcmes.Elements.creator root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::Purl.Dcmes.Elements.creator creator {  get {return rootObject as global::Purl.Dcmes.Elements.creator; } }
        
        public XRoot(global::Purl.Dcmes.Elements.subject root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::Purl.Dcmes.Elements.subject subject {  get {return rootObject as global::Purl.Dcmes.Elements.subject; } }
        
        public XRoot(global::Purl.Dcmes.Elements.description root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::Purl.Dcmes.Elements.description description {  get {return rootObject as global::Purl.Dcmes.Elements.description; } }
        
        public XRoot(global::Purl.Dcmes.Elements.publisher root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::Purl.Dcmes.Elements.publisher publisher {  get {return rootObject as global::Purl.Dcmes.Elements.publisher; } }
        
        public XRoot(global::Purl.Dcmes.Elements.contributor root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::Purl.Dcmes.Elements.contributor contributor {  get {return rootObject as global::Purl.Dcmes.Elements.contributor; } }
        
        public XRoot(global::Purl.Dcmes.Elements.date root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::Purl.Dcmes.Elements.date date {  get {return rootObject as global::Purl.Dcmes.Elements.date; } }
        
        public XRoot(global::Purl.Dcmes.Elements.type root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::Purl.Dcmes.Elements.type type {  get {return rootObject as global::Purl.Dcmes.Elements.type; } }
        
        public XRoot(global::Purl.Dcmes.Elements.format root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::Purl.Dcmes.Elements.format format {  get {return rootObject as global::Purl.Dcmes.Elements.format; } }
        
        public XRoot(global::Purl.Dcmes.Elements.identifier root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::Purl.Dcmes.Elements.identifier identifier {  get {return rootObject as global::Purl.Dcmes.Elements.identifier; } }
        
        public XRoot(global::Purl.Dcmes.Elements.source root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::Purl.Dcmes.Elements.source source {  get {return rootObject as global::Purl.Dcmes.Elements.source; } }
        
        public XRoot(global::Purl.Dcmes.Elements.language root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::Purl.Dcmes.Elements.language language {  get {return rootObject as global::Purl.Dcmes.Elements.language; } }
        
        public XRoot(global::Purl.Dcmes.Elements.relation root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::Purl.Dcmes.Elements.relation relation {  get {return rootObject as global::Purl.Dcmes.Elements.relation; } }
        
        public XRoot(global::Purl.Dcmes.Elements.coverage root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::Purl.Dcmes.Elements.coverage coverage {  get {return rootObject as global::Purl.Dcmes.Elements.coverage; } }
        
        public XRoot(global::Purl.Dcmes.Elements.rights root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        

		public global::Purl.Dcmes.Elements.rights rights {  get {return rootObject as global::Purl.Dcmes.Elements.rights; } }
    }
}
